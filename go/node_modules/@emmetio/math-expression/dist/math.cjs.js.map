{"version":3,"file":"math.cjs.js","sources":["../src/parser.ts","../src/extract.ts","../src/index.ts"],"sourcesContent":["import Scanner, { isWhiteSpace, isNumber } from '@emmetio/scanner';\n\nexport const enum TokenType {\n    Number = 'num',\n    Op1 = 'op1',\n    Op2 = 'op2',\n    Null = 'null'\n}\n\nexport const enum Operator {\n    Plus = 43, // +\n    Minus = 45, // -\n    Multiply = 42, // *\n    Divide = 47, // /\n    IntDivide = 92, // \\\n    LeftParenthesis = 40, // (\n    RightParenthesis = 41, // )\n    Dot = 46, // .\n}\n\nconst enum ParserState {\n    Primary = 1 << 0,\n    Operator = 1 << 1,\n    LParen = 1 << 2,\n    RParen = 1 << 3,\n    Sign = 1 << 4,\n    NullaryCall = 1 << 5,\n}\n\nexport interface Token {\n    type: TokenType;\n    value: number;\n    priority: number;\n}\n\nexport const nullary = token(TokenType.Null, 0);\n\n/**\n * Parses given expression in forward direction\n */\nexport default function parse(expr: string | Scanner): Token[] | null {\n    const scanner = typeof expr === 'string' ? new Scanner(expr) : expr;\n    let ch: number;\n    let priority = 0;\n    let expected: ParserState = (ParserState.Primary | ParserState.LParen | ParserState.Sign);\n    const tokens: Token[] = [];\n\n    while (!scanner.eof()) {\n        scanner.eatWhile(isWhiteSpace);\n        scanner.start = scanner.pos;\n\n        if (consumeNumber(scanner)) {\n            if ((expected & ParserState.Primary) === 0) {\n                error('Unexpected number', scanner);\n            }\n\n            tokens.push(number(scanner.current()));\n            expected = (ParserState.Operator | ParserState.RParen);\n        } else if (isOperator(scanner.peek())) {\n            ch = scanner.next()!;\n            if (isSign(ch) && (expected & ParserState.Sign)) {\n                if (isNegativeSign(ch)) {\n                    tokens.push(op1(ch, priority));\n                }\n                expected = (ParserState.Primary | ParserState.LParen | ParserState.Sign);\n            } else {\n                if ((expected & ParserState.Operator) === 0) {\n                    error('Unexpected operator', scanner);\n                }\n                tokens.push(op2(ch, priority));\n                expected = (ParserState.Primary | ParserState.LParen | ParserState.Sign);\n            }\n        } else if (scanner.eat(Operator.LeftParenthesis)) {\n            if ((expected & ParserState.LParen) === 0) {\n                error('Unexpected \"(\"', scanner);\n            }\n\n            priority += 10;\n            expected = (ParserState.Primary | ParserState.LParen | ParserState.Sign | ParserState.NullaryCall);\n        } else if (scanner.eat(Operator.RightParenthesis)) {\n            priority -= 10;\n\n            if (expected & ParserState.NullaryCall) {\n                tokens.push(nullary);\n            } else if ((expected & ParserState.RParen) === 0) {\n                error('Unexpected \")\"', scanner);\n            }\n\n            expected = (ParserState.Operator | ParserState.RParen | ParserState.LParen);\n        } else {\n            error('Unknown character', scanner);\n        }\n    }\n\n    if (priority < 0 || priority >= 10) {\n        error('Unmatched \"()\"', scanner);\n    }\n\n    const result = orderTokens(tokens);\n\n    if (result === null) {\n        error('Parity', scanner);\n    }\n\n    return result;\n}\n\n/**\n * Consumes number from given stream\n * @return Returns `true` if number was consumed\n */\nfunction consumeNumber(scanner: Scanner): boolean {\n    const start = scanner.pos;\n    if (scanner.eat(Operator.Dot) && scanner.eatWhile(isNumber)) {\n        // short decimal notation: .025\n        return true;\n    }\n\n    if (scanner.eatWhile(isNumber) && (!scanner.eat(Operator.Dot) || scanner.eatWhile(isNumber))) {\n        // either integer or decimal: 10, 10.25\n        return true;\n    }\n\n    scanner.pos = start;\n    return false;\n}\n\n/**\n * Orders parsed tokens (operands and operators) in given array so that they are\n * laid off in order of execution\n */\nfunction orderTokens(tokens: Token[]): Token[] | null {\n    const operators: Token[] = [];\n    const operands: Token[] = [];\n    let nOperators = 0;\n\n    for (let i = 0; i < tokens.length; i++) {\n        const t = tokens[i];\n\n        if (t.type === TokenType.Number) {\n            operands.push(t);\n        } else {\n            nOperators += t.type === TokenType.Op1 ? 1 : 2;\n\n            while (operators.length) {\n                if (t.priority <= operators[operators.length - 1].priority) {\n                    operands.push(operators.pop()!);\n                } else {\n                    break;\n                }\n            }\n\n            operators.push(t);\n        }\n    }\n\n    return nOperators + 1 === operands.length + operators.length\n        ? operands.concat(operators.reverse())\n        : null /* parity */;\n}\n\n/**\n * Number token factory\n */\nfunction number(value: string, priority?: number): Token {\n    return token(TokenType.Number, parseFloat(value), priority);\n}\n\n/**\n * Unary operator factory\n * @param value    Operator  character code\n * @param priority Operator execution priority\n */\nfunction op1(value: number, priority = 0) {\n    if (value === Operator.Minus) {\n        priority += 2;\n    }\n    return token(TokenType.Op1, value, priority);\n}\n\n/**\n * Binary operator factory\n * @param value Operator  character code\n * @param priority Operator execution priority\n */\nfunction op2(value: number, priority = 0): Token {\n    if (value === Operator.Multiply) {\n        priority += 1;\n    } else if (value === Operator.Divide || value === Operator.IntDivide) {\n        priority += 2;\n    }\n\n    return token(TokenType.Op2, value, priority);\n}\n\nfunction error(name: string, scanner?: Scanner) {\n    if (scanner) {\n        name += ` at column ${scanner.pos} of expression`;\n    }\n    throw new Error(name);\n}\n\nexport function isSign(ch: number): boolean {\n    return isPositiveSign(ch) || isNegativeSign(ch);\n}\n\nfunction isPositiveSign(ch: number) {\n    return ch === Operator.Plus;\n}\n\nfunction isNegativeSign(ch: number) {\n    return ch === Operator.Minus;\n}\n\nexport function isOperator(ch: number): ch is Operator {\n    return ch === Operator.Plus || ch === Operator.Minus || ch === Operator.Multiply\n        || ch === Operator.Divide || ch === Operator.IntDivide;\n}\n\nexport function token(type: TokenType, value: number, priority: number = 0): Token {\n    return { type, value, priority };\n}\n","import { Operator, isSign, isOperator } from './parser';\nimport { isSpace, isNumber } from '@emmetio/scanner';\n\nexport interface ExtractOptions {\n    /**\n     * Allow capturing extra expression characters right after start position.\n     * Useful for extracting expressions from text editor source which inserts\n     * paired characters like `(` and `)` to properly extract expression past\n     * caret position\n     */\n    lookAhead: boolean;\n\n    /**\n     * Allow whitespace in extracted expressions\n     */\n    whitespace: boolean;\n}\n\ninterface BackwardScanner {\n    text: string;\n    pos: number;\n}\n\nconst defaultOptions: ExtractOptions = {\n    lookAhead: true,\n    whitespace: true\n};\n\nexport default function extract(text: string, pos = text.length, options?: Partial<ExtractOptions>): [number, number] | null {\n    const opt = { ...defaultOptions, ...options };\n    const scanner: BackwardScanner = { text, pos };\n    let ch: number;\n\n    if (opt.lookAhead && cur(scanner) === Operator.RightParenthesis) {\n        // Basically, we should consume right parenthesis only with optional whitespace\n        scanner.pos++;\n        const len = text.length;\n        while (scanner.pos < len) {\n            ch = cur(scanner);\n            if (ch !== Operator.RightParenthesis && !(opt.whitespace && isSpace(ch))) {\n                break;\n            }\n            scanner.pos++;\n        }\n    }\n\n    const end = scanner.pos;\n    let braces = 0;\n    while (scanner.pos >= 0) {\n        if (number(scanner)) {\n            continue;\n        }\n\n        ch = prev(scanner);\n        if (ch === Operator.RightParenthesis) {\n            braces++;\n        } else if (ch === Operator.LeftParenthesis) {\n            if (!braces) {\n                break;\n            }\n            braces--;\n        } else if (!((opt.whitespace && isSpace(ch)) || isSign(ch) || isOperator(ch))) {\n            break;\n        }\n\n        scanner.pos--;\n    }\n\n    if (scanner.pos !== end && !braces) {\n        // Trim whitespace\n        while (isSpace(cur(scanner))) {\n            scanner.pos++;\n        }\n\n        return [scanner.pos, end];\n    }\n\n    return null;\n}\n\n/**\n * Backward-consumes number from given scanner, if possible\n */\nfunction number(scanner: BackwardScanner): boolean {\n    if (isNumber(prev(scanner))) {\n        scanner.pos--;\n        let dot = false;\n        let ch: number;\n\n        while (scanner.pos >= 0) {\n            ch = prev(scanner);\n            if (ch === 46 /* . */) {\n                if (dot) {\n                    // Decimal delimiter already consumed, abort\n                    break;\n                }\n                dot = true;\n            } else if (!isNumber(ch)) {\n                break;\n            }\n            scanner.pos--;\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\nfunction prev(scanner: BackwardScanner): number {\n    return scanner.text.charCodeAt(scanner.pos - 1);\n}\n\nfunction cur(scanner: BackwardScanner): number {\n    return scanner.text.charCodeAt(scanner.pos);\n}\n","import Scanner from '@emmetio/scanner';\nimport parse, { TokenType, Operator, Token } from './parser';\n\nexport { default as extract, ExtractOptions } from './extract';\n\ntype UnaryAction = { [op in Operator]?: (n: number) => number };\ntype BinaryAction = { [op in Operator]?: (n1: number, n2: number) => number };\n\nconst ops1: UnaryAction = {\n    [Operator.Minus]: num => -num\n};\n\nconst ops2: BinaryAction = {\n    [Operator.Plus]: (a, b) => a + b,\n    [Operator.Minus]: (a, b) => a - b,\n    [Operator.Multiply]: (a, b) => a * b,\n    [Operator.Divide]: (a, b) => a / b,\n    [Operator.IntDivide]: (a, b) => Math.floor(a / b)\n};\n\n/**\n * Evaluates given math expression\n * @param expr Expression to evaluate\n */\nexport default function evaluate(expr: string | Scanner | Token[]): number | null {\n    if (!Array.isArray(expr)) {\n        expr = parse(expr)!;\n    }\n\n    if (!expr || !expr.length) {\n        return null;\n    }\n\n    const nStack: number[] = [];\n    let n1: number;\n    let n2: number;\n    let f: (n1: number, n2?: number) => number;\n\n    for (let i = 0, il = expr.length; i < il; i++) {\n        const token = expr[i];\n        if (token.type === TokenType.Number) {\n            nStack.push(token.value);\n        } else if (token.type === TokenType.Op2) {\n            n2 = nStack.pop()!;\n            n1 = nStack.pop()!;\n            f = ops2[token.value];\n            nStack.push(f(n1, n2));\n        } else if (token.type === TokenType.Op1) {\n            n1 = nStack.pop()!;\n            f = ops1[token.value];\n            nStack.push(f(n1));\n        } else {\n            throw new Error('Invalid expression');\n        }\n    }\n\n    if (nStack.length > 1) {\n        throw new Error('Invalid Expression (parity)');\n    }\n\n    return nStack[0];\n}\n\nexport { parse, Token };\n"],"names":["Scanner","isWhiteSpace","isNumber","isSpace","number"],"mappings":"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"}