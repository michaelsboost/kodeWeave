{"version":3,"file":"plugin.js","sources":["../../emmet/node_modules/@emmetio/scanner/scanner.es.js","../../emmet/node_modules/@emmetio/abbreviation/dist/abbreviation.es.js","../../emmet/node_modules/@emmetio/css-abbreviation/dist/css-abbreviation.es.js","../../emmet/dist/emmet.es.js","../src/lib/utils.ts","../src/lib/context.ts","../src/lib/syntax.ts","../src/lib/emmet.ts","../src/lib/config.ts","../src/lib/output.ts","../src/tracker/AbbreviationPreviewWidget.ts","../src/completion-icon.svg","../src/tracker/index.ts","../src/commands/expand.ts","../src/commands/balance.ts","../src/commands/comment.ts","../node_modules/@emmetio/scanner/scanner.es.js","../node_modules/@emmetio/math-expression/dist/math.es.js","../src/commands/evaluate-math.ts","../src/commands/go-to-edit-point.ts","../src/commands/go-to-tag-pair.ts","../src/commands/inc-dec-number.ts","../src/commands/remove-tag.ts","../src/commands/select-item.ts","../src/commands/split-join-tag.ts","../src/commands/wrap-with-abbreviation.ts"],"sourcesContent":["const defaultQuotedOptions = {\n    escape: 92,\n    throws: false\n};\n/**\n * Check if given code is a number\n */\nfunction isNumber(code) {\n    return code > 47 && code < 58;\n}\n/**\n * Check if given character code is alpha code (letter through A to Z)\n */\nfunction isAlpha(code, from, to) {\n    from = from || 65; // A\n    to = to || 90; // Z\n    code &= ~32; // quick hack to convert any char code to uppercase char code\n    return code >= from && code <= to;\n}\n/**\n * Check if given character code is alpha-numeric (letter through A to Z or number)\n */\nfunction isAlphaNumeric(code) {\n    return isNumber(code) || isAlpha(code);\n}\nfunction isAlphaNumericWord(code) {\n    return isNumber(code) || isAlphaWord(code);\n}\nfunction isAlphaWord(code) {\n    return code === 95 /* _ */ || isAlpha(code);\n}\n/**\n * Check if given character code is a white-space character: a space character\n * or line breaks\n */\nfunction isWhiteSpace(code) {\n    return code === 32 /* space */\n        || code === 9 /* tab */\n        || code === 160; /* non-breaking space */\n}\n/**\n * Check if given character code is a space character\n */\nfunction isSpace(code) {\n    return isWhiteSpace(code)\n        || code === 10 /* LF */\n        || code === 13; /* CR */\n}\n/**\n * Consumes 'single' or \"double\"-quoted string from given string, if possible\n * @return `true` if quoted string was consumed. The contents of quoted string\n * will be available as `stream.current()`\n */\nfunction eatQuoted(stream, options) {\n    options = Object.assign(Object.assign({}, defaultQuotedOptions), options);\n    const start = stream.pos;\n    const quote = stream.peek();\n    if (stream.eat(isQuote)) {\n        while (!stream.eof()) {\n            switch (stream.next()) {\n                case quote:\n                    stream.start = start;\n                    return true;\n                case options.escape:\n                    stream.next();\n                    break;\n            }\n        }\n        // If we’re here then stream wasn’t properly consumed.\n        // Revert stream and decide what to do\n        stream.pos = start;\n        if (options.throws) {\n            throw stream.error('Unable to consume quoted string');\n        }\n    }\n    return false;\n}\n/**\n * Check if given character code is a quote character\n */\nfunction isQuote(code) {\n    return code === 39 /* ' */ || code === 34 /* \" */;\n}\n/**\n * Eats paired characters substring, for example `(foo)` or `[bar]`\n * @param open Character code of pair opening\n * @param close Character code of pair closing\n * @return Returns `true` if character pair was successfully consumed, it’s\n * content will be available as `stream.current()`\n */\nfunction eatPair(stream, open, close, options) {\n    options = Object.assign(Object.assign({}, defaultQuotedOptions), options);\n    const start = stream.pos;\n    if (stream.eat(open)) {\n        let stack = 1;\n        let ch;\n        while (!stream.eof()) {\n            if (eatQuoted(stream, options)) {\n                continue;\n            }\n            ch = stream.next();\n            if (ch === open) {\n                stack++;\n            }\n            else if (ch === close) {\n                stack--;\n                if (!stack) {\n                    stream.start = start;\n                    return true;\n                }\n            }\n            else if (ch === options.escape) {\n                stream.next();\n            }\n        }\n        // If we’re here then paired character can’t be consumed\n        stream.pos = start;\n        if (options.throws) {\n            throw stream.error(`Unable to find matching pair for ${String.fromCharCode(open)}`);\n        }\n    }\n    return false;\n}\n\n/**\n * A streaming, character code-based string reader\n */\nclass Scanner {\n    constructor(str, start, end) {\n        if (end == null && typeof str === 'string') {\n            end = str.length;\n        }\n        this.string = str;\n        this.pos = this.start = start || 0;\n        this.end = end || 0;\n    }\n    /**\n     * Returns true only if the stream is at the end of the file.\n     */\n    eof() {\n        return this.pos >= this.end;\n    }\n    /**\n     * Creates a new stream instance which is limited to given `start` and `end`\n     * range. E.g. its `eof()` method will look at `end` property, not actual\n     * stream end\n     */\n    limit(start, end) {\n        return new Scanner(this.string, start, end);\n    }\n    /**\n     * Returns the next character code in the stream without advancing it.\n     * Will return NaN at the end of the file.\n     */\n    peek() {\n        return this.string.charCodeAt(this.pos);\n    }\n    /**\n     * Returns the next character in the stream and advances it.\n     * Also returns <code>undefined</code> when no more characters are available.\n     */\n    next() {\n        if (this.pos < this.string.length) {\n            return this.string.charCodeAt(this.pos++);\n        }\n    }\n    /**\n     * `match` can be a character code or a function that takes a character code\n     * and returns a boolean. If the next character in the stream 'matches'\n     * the given argument, it is consumed and returned.\n     * Otherwise, `false` is returned.\n     */\n    eat(match) {\n        const ch = this.peek();\n        const ok = typeof match === 'function' ? match(ch) : ch === match;\n        if (ok) {\n            this.next();\n        }\n        return ok;\n    }\n    /**\n     * Repeatedly calls <code>eat</code> with the given argument, until it\n     * fails. Returns <code>true</code> if any characters were eaten.\n     */\n    eatWhile(match) {\n        const start = this.pos;\n        while (!this.eof() && this.eat(match)) { /* */ }\n        return this.pos !== start;\n    }\n    /**\n     * Backs up the stream n characters. Backing it up further than the\n     * start of the current token will cause things to break, so be careful.\n     */\n    backUp(n) {\n        this.pos -= (n || 1);\n    }\n    /**\n     * Get the string between the start of the current token and the\n     * current stream position.\n     */\n    current() {\n        return this.substring(this.start, this.pos);\n    }\n    /**\n     * Returns substring for given range\n     */\n    substring(start, end) {\n        return this.string.slice(start, end);\n    }\n    /**\n     * Creates error object with current stream state\n     */\n    error(message, pos = this.pos) {\n        return new ScannerError(`${message} at ${pos + 1}`, pos, this.string);\n    }\n}\nclass ScannerError extends Error {\n    constructor(message, pos, str) {\n        super(message);\n        this.pos = pos;\n        this.string = str;\n    }\n}\n\nexport default Scanner;\nexport { ScannerError, eatPair, eatQuoted, isAlpha, isAlphaNumeric, isAlphaNumericWord, isAlphaWord, isNumber, isQuote, isSpace, isWhiteSpace };\n//# sourceMappingURL=scanner.es.js.map\n","import Scanner, { isAlphaNumericWord, isSpace, isQuote as isQuote$1, isNumber, isAlpha, ScannerError } from '@emmetio/scanner';\n\nfunction tokenScanner(tokens) {\n    return {\n        tokens,\n        start: 0,\n        pos: 0,\n        size: tokens.length\n    };\n}\nfunction peek(scanner) {\n    return scanner.tokens[scanner.pos];\n}\nfunction next(scanner) {\n    return scanner.tokens[scanner.pos++];\n}\nfunction slice(scanner, from = scanner.start, to = scanner.pos) {\n    return scanner.tokens.slice(from, to);\n}\nfunction readable(scanner) {\n    return scanner.pos < scanner.size;\n}\nfunction consume(scanner, test) {\n    const token = peek(scanner);\n    if (token && test(token)) {\n        scanner.pos++;\n        return true;\n    }\n    return false;\n}\nfunction error(scanner, message, token = peek(scanner)) {\n    if (token && token.start != null) {\n        message += ` at ${token.start}`;\n    }\n    const err = new Error(message);\n    err['pos'] = token && token.start;\n    return err;\n}\n\nfunction abbreviation(abbr, options = {}) {\n    const scanner = tokenScanner(abbr);\n    const result = statements(scanner, options);\n    if (readable(scanner)) {\n        throw error(scanner, 'Unexpected character');\n    }\n    return result;\n}\nfunction statements(scanner, options) {\n    const result = {\n        type: 'TokenGroup',\n        elements: []\n    };\n    let ctx = result;\n    let node;\n    const stack = [];\n    while (readable(scanner)) {\n        if (node = element(scanner, options) || group(scanner, options)) {\n            ctx.elements.push(node);\n            if (consume(scanner, isChildOperator)) {\n                stack.push(ctx);\n                ctx = node;\n            }\n            else if (consume(scanner, isSiblingOperator)) {\n                continue;\n            }\n            else if (consume(scanner, isClimbOperator)) {\n                do {\n                    if (stack.length) {\n                        ctx = stack.pop();\n                    }\n                } while (consume(scanner, isClimbOperator));\n            }\n        }\n        else {\n            break;\n        }\n    }\n    return result;\n}\n/**\n * Consumes group from given scanner\n */\nfunction group(scanner, options) {\n    if (consume(scanner, isGroupStart)) {\n        const result = statements(scanner, options);\n        const token = next(scanner);\n        if (isBracket(token, 'group', false)) {\n            result.repeat = repeater(scanner);\n        }\n        return result;\n    }\n}\n/**\n * Consumes single element from given scanner\n */\nfunction element(scanner, options) {\n    let attr;\n    const elem = {\n        type: 'TokenElement',\n        name: void 0,\n        attributes: void 0,\n        value: void 0,\n        repeat: void 0,\n        selfClose: false,\n        elements: []\n    };\n    if (elementName(scanner, options)) {\n        elem.name = slice(scanner);\n    }\n    while (readable(scanner)) {\n        scanner.start = scanner.pos;\n        if (!elem.repeat && !isEmpty(elem) && consume(scanner, isRepeater)) {\n            elem.repeat = scanner.tokens[scanner.pos - 1];\n        }\n        else if (!elem.value && text(scanner)) {\n            elem.value = getText(scanner);\n        }\n        else if (attr = shortAttribute(scanner, 'id', options) || shortAttribute(scanner, 'class', options) || attributeSet(scanner)) {\n            if (!elem.attributes) {\n                elem.attributes = Array.isArray(attr) ? attr.slice() : [attr];\n            }\n            else {\n                elem.attributes = elem.attributes.concat(attr);\n            }\n        }\n        else {\n            if (!isEmpty(elem) && consume(scanner, isCloseOperator)) {\n                elem.selfClose = true;\n                if (!elem.repeat && consume(scanner, isRepeater)) {\n                    elem.repeat = scanner.tokens[scanner.pos - 1];\n                }\n            }\n            break;\n        }\n    }\n    return !isEmpty(elem) ? elem : void 0;\n}\n/**\n * Consumes attribute set from given scanner\n */\nfunction attributeSet(scanner) {\n    if (consume(scanner, isAttributeSetStart)) {\n        const attributes = [];\n        let attr;\n        while (readable(scanner)) {\n            if (attr = attribute(scanner)) {\n                attributes.push(attr);\n            }\n            else if (consume(scanner, isAttributeSetEnd)) {\n                break;\n            }\n            else if (!consume(scanner, isWhiteSpace)) {\n                throw error(scanner, `Unexpected \"${peek(scanner).type}\" token`);\n            }\n        }\n        return attributes;\n    }\n}\n/**\n * Consumes attribute shorthand (class or id) from given scanner\n */\nfunction shortAttribute(scanner, type, options) {\n    if (isOperator(peek(scanner), type)) {\n        scanner.pos++;\n        const attr = {\n            name: [createLiteral(type)]\n        };\n        // Consume expression after shorthand start for React-like components\n        if (options.jsx && text(scanner)) {\n            attr.value = getText(scanner);\n            attr.expression = true;\n        }\n        else {\n            attr.value = literal(scanner) ? slice(scanner) : void 0;\n        }\n        return attr;\n    }\n}\n/**\n * Consumes single attribute from given scanner\n */\nfunction attribute(scanner) {\n    if (quoted(scanner)) {\n        // Consumed quoted value: it’s a value for default attribute\n        return {\n            value: slice(scanner)\n        };\n    }\n    if (literal(scanner, true)) {\n        return {\n            name: slice(scanner),\n            value: consume(scanner, isEquals) && (quoted(scanner) || literal(scanner, true))\n                ? slice(scanner)\n                : void 0\n        };\n    }\n}\nfunction repeater(scanner) {\n    return isRepeater(peek(scanner))\n        ? scanner.tokens[scanner.pos++]\n        : void 0;\n}\n/**\n * Consumes quoted value from given scanner, if possible\n */\nfunction quoted(scanner) {\n    const start = scanner.pos;\n    const quote = peek(scanner);\n    if (isQuote(quote)) {\n        scanner.pos++;\n        while (readable(scanner)) {\n            if (isQuote(next(scanner), quote.single)) {\n                scanner.start = start;\n                return true;\n            }\n        }\n        throw error(scanner, 'Unclosed quote', quote);\n    }\n    return false;\n}\n/**\n * Consumes literal (unquoted value) from given scanner\n */\nfunction literal(scanner, allowBrackets) {\n    const start = scanner.pos;\n    const brackets = {\n        attribute: 0,\n        expression: 0,\n        group: 0\n    };\n    while (readable(scanner)) {\n        const token = peek(scanner);\n        if (brackets.expression) {\n            // If we’re inside expression, we should consume all content in it\n            if (isBracket(token, 'expression')) {\n                brackets[token.context] += token.open ? 1 : -1;\n            }\n        }\n        else if (isQuote(token) || isOperator(token) || isWhiteSpace(token) || isRepeater(token)) {\n            break;\n        }\n        else if (isBracket(token)) {\n            if (!allowBrackets) {\n                break;\n            }\n            if (token.open) {\n                brackets[token.context]++;\n            }\n            else if (!brackets[token.context]) {\n                // Stop if found unmatched closing brace: it must be handled\n                // by parent consumer\n                break;\n            }\n            else {\n                brackets[token.context]--;\n            }\n        }\n        scanner.pos++;\n    }\n    if (start !== scanner.pos) {\n        scanner.start = start;\n        return true;\n    }\n    return false;\n}\n/**\n * Consumes element name from given scanner\n */\nfunction elementName(scanner, options) {\n    const start = scanner.pos;\n    if (options.jsx && consume(scanner, isCapitalizedLiteral)) {\n        // Check for edge case: consume immediate capitalized class names\n        // for React-like components, e.g. `Foo.Bar.Baz`\n        while (readable(scanner)) {\n            const { pos } = scanner;\n            if (!consume(scanner, isClassNameOperator) || !consume(scanner, isCapitalizedLiteral)) {\n                scanner.pos = pos;\n                break;\n            }\n        }\n    }\n    while (readable(scanner) && consume(scanner, isElementName)) {\n        // empty\n    }\n    if (scanner.pos !== start) {\n        scanner.start = start;\n        return true;\n    }\n    return false;\n}\n/**\n * Consumes text value from given scanner\n */\nfunction text(scanner) {\n    const start = scanner.pos;\n    if (consume(scanner, isTextStart)) {\n        let brackets = 0;\n        while (readable(scanner)) {\n            const token = next(scanner);\n            if (isBracket(token, 'expression')) {\n                if (token.open) {\n                    brackets++;\n                }\n                else if (!brackets) {\n                    break;\n                }\n                else {\n                    brackets--;\n                }\n            }\n        }\n        scanner.start = start;\n        return true;\n    }\n    return false;\n}\nfunction getText(scanner) {\n    let from = scanner.start;\n    let to = scanner.pos;\n    if (isBracket(scanner.tokens[from], 'expression', true)) {\n        from++;\n    }\n    if (isBracket(scanner.tokens[to - 1], 'expression', false)) {\n        to--;\n    }\n    return slice(scanner, from, to);\n}\nfunction isBracket(token, context, isOpen) {\n    return Boolean(token && token.type === 'Bracket'\n        && (!context || token.context === context)\n        && (isOpen == null || token.open === isOpen));\n}\nfunction isOperator(token, type) {\n    return Boolean(token && token.type === 'Operator' && (!type || token.operator === type));\n}\nfunction isQuote(token, isSingle) {\n    return Boolean(token && token.type === 'Quote' && (isSingle == null || token.single === isSingle));\n}\nfunction isWhiteSpace(token) {\n    return Boolean(token && token.type === 'WhiteSpace');\n}\nfunction isEquals(token) {\n    return isOperator(token, 'equal');\n}\nfunction isRepeater(token) {\n    return Boolean(token && token.type === 'Repeater');\n}\nfunction isLiteral(token) {\n    return token.type === 'Literal';\n}\nfunction isCapitalizedLiteral(token) {\n    if (isLiteral(token)) {\n        const ch = token.value.charCodeAt(0);\n        return ch >= 65 && ch <= 90;\n    }\n    return false;\n}\nfunction isElementName(token) {\n    return token.type === 'Literal' || token.type === 'RepeaterNumber' || token.type === 'RepeaterPlaceholder';\n}\nfunction isClassNameOperator(token) {\n    return isOperator(token, 'class');\n}\nfunction isAttributeSetStart(token) {\n    return isBracket(token, 'attribute', true);\n}\nfunction isAttributeSetEnd(token) {\n    return isBracket(token, 'attribute', false);\n}\nfunction isTextStart(token) {\n    return isBracket(token, 'expression', true);\n}\nfunction isGroupStart(token) {\n    return isBracket(token, 'group', true);\n}\nfunction createLiteral(value) {\n    return { type: 'Literal', value };\n}\nfunction isEmpty(elem) {\n    return !elem.name && !elem.value && !elem.attributes;\n}\nfunction isChildOperator(token) {\n    return isOperator(token, 'child');\n}\nfunction isSiblingOperator(token) {\n    return isOperator(token, 'sibling');\n}\nfunction isClimbOperator(token) {\n    return isOperator(token, 'climb');\n}\nfunction isCloseOperator(token) {\n    return isOperator(token, 'close');\n}\n\n/**\n * If consumes escape character, sets current stream range to escaped value\n */\nfunction escaped(scanner) {\n    if (scanner.eat(92 /* Escape */)) {\n        scanner.start = scanner.pos;\n        if (!scanner.eof()) {\n            scanner.pos++;\n        }\n        return true;\n    }\n    return false;\n}\n\nfunction tokenize(source) {\n    const scanner = new Scanner(source);\n    const result = [];\n    const ctx = {\n        group: 0,\n        attribute: 0,\n        expression: 0,\n        quote: 0\n    };\n    let ch = 0;\n    let token;\n    while (!scanner.eof()) {\n        ch = scanner.peek();\n        token = getToken(scanner, ctx);\n        if (token) {\n            result.push(token);\n            if (token.type === 'Quote') {\n                ctx.quote = ch === ctx.quote ? 0 : ch;\n            }\n            else if (token.type === 'Bracket') {\n                ctx[token.context] += token.open ? 1 : -1;\n            }\n        }\n        else {\n            throw scanner.error('Unexpected character');\n        }\n    }\n    return result;\n}\n/**\n * Returns next token from given scanner, if possible\n */\nfunction getToken(scanner, ctx) {\n    return field(scanner, ctx)\n        || repeaterPlaceholder(scanner)\n        || repeaterNumber(scanner)\n        || repeater$1(scanner)\n        || whiteSpace(scanner)\n        || literal$1(scanner, ctx)\n        || operator(scanner)\n        || quote(scanner)\n        || bracket(scanner);\n}\n/**\n * Consumes literal from given scanner\n */\nfunction literal$1(scanner, ctx) {\n    const start = scanner.pos;\n    let value = '';\n    while (!scanner.eof()) {\n        // Consume escaped sequence no matter of context\n        if (escaped(scanner)) {\n            value += scanner.current();\n            continue;\n        }\n        const ch = scanner.peek();\n        if (ch === ctx.quote || ch === 36 /* Dollar */ || isAllowedOperator(ch, ctx)) {\n            // 1. Found matching quote\n            // 2. The `$` character has special meaning in every context\n            // 3. Depending on context, some characters should be treated as operators\n            break;\n        }\n        if (ctx.expression && ch === 125 /* CurlyBracketClose */) {\n            break;\n        }\n        if (!ctx.quote && !ctx.expression) {\n            // Consuming element name\n            if (!ctx.attribute && !isElementName$1(ch)) {\n                break;\n            }\n            if (isAllowedSpace(ch, ctx) || isAllowedRepeater(ch, ctx) || isQuote$1(ch) || bracketType(ch)) {\n                // Stop for characters not allowed in unquoted literal\n                break;\n            }\n        }\n        value += scanner.string[scanner.pos++];\n    }\n    if (start !== scanner.pos) {\n        scanner.start = start;\n        return {\n            type: 'Literal',\n            value,\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes white space characters as string literal from given scanner\n */\nfunction whiteSpace(scanner) {\n    const start = scanner.pos;\n    if (scanner.eatWhile(isSpace)) {\n        return {\n            type: 'WhiteSpace',\n            start,\n            end: scanner.pos,\n            value: scanner.substring(start, scanner.pos)\n        };\n    }\n}\n/**\n * Consumes quote from given scanner\n */\nfunction quote(scanner) {\n    const ch = scanner.peek();\n    if (isQuote$1(ch)) {\n        return {\n            type: 'Quote',\n            single: ch === 39 /* SingleQuote */,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes bracket from given scanner\n */\nfunction bracket(scanner) {\n    const ch = scanner.peek();\n    const context = bracketType(ch);\n    if (context) {\n        return {\n            type: 'Bracket',\n            open: isOpenBracket(ch),\n            context,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes operator from given scanner\n */\nfunction operator(scanner) {\n    const op = operatorType(scanner.peek());\n    if (op) {\n        return {\n            type: 'Operator',\n            operator: op,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes node repeat token from current stream position and returns its\n * parsed value\n */\nfunction repeater$1(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(42 /* Asterisk */)) {\n        scanner.start = scanner.pos;\n        let count = 1;\n        let implicit = false;\n        if (scanner.eatWhile(isNumber)) {\n            count = Number(scanner.current());\n        }\n        else {\n            implicit = true;\n        }\n        return {\n            type: 'Repeater',\n            count,\n            value: 0,\n            implicit,\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes repeater placeholder `$#` from given scanner\n */\nfunction repeaterPlaceholder(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(36 /* Dollar */) && scanner.eat(35 /* Hash */)) {\n        return {\n            type: 'RepeaterPlaceholder',\n            value: void 0,\n            start,\n            end: scanner.pos\n        };\n    }\n    scanner.pos = start;\n}\n/**\n * Consumes numbering token like `$` from given scanner state\n */\nfunction repeaterNumber(scanner) {\n    const start = scanner.pos;\n    if (scanner.eatWhile(36 /* Dollar */)) {\n        const size = scanner.pos - start;\n        let reverse = false;\n        let base = 1;\n        let parent = 0;\n        if (scanner.eat(64 /* At */)) {\n            // Consume numbering modifiers\n            while (scanner.eat(94 /* Climb */)) {\n                parent++;\n            }\n            reverse = scanner.eat(45 /* Dash */);\n            scanner.start = scanner.pos;\n            if (scanner.eatWhile(isNumber)) {\n                base = Number(scanner.current());\n            }\n        }\n        scanner.start = start;\n        return {\n            type: 'RepeaterNumber',\n            size,\n            reverse,\n            base,\n            parent,\n            start,\n            end: scanner.pos\n        };\n    }\n}\nfunction field(scanner, ctx) {\n    const start = scanner.pos;\n    // Fields are allowed inside expressions and attributes\n    if ((ctx.expression || ctx.attribute) && scanner.eat(36 /* Dollar */) && scanner.eat(123 /* CurlyBracketOpen */)) {\n        scanner.start = scanner.pos;\n        let index;\n        let name = '';\n        if (scanner.eatWhile(isNumber)) {\n            // It’s a field\n            index = Number(scanner.current());\n            name = scanner.eat(58 /* Colon */) ? consumePlaceholder(scanner) : '';\n        }\n        else if (isAlpha(scanner.peek())) {\n            // It’s a variable\n            name = consumePlaceholder(scanner);\n        }\n        if (scanner.eat(125 /* CurlyBracketClose */)) {\n            return {\n                type: 'Field',\n                index, name,\n                start,\n                end: scanner.pos\n            };\n        }\n        throw scanner.error('Expecting }');\n    }\n    // If we reached here then there’s no valid field here, revert\n    // back to starting position\n    scanner.pos = start;\n}\n/**\n * Consumes a placeholder: value right after `:` in field. Could be empty\n */\nfunction consumePlaceholder(stream) {\n    const stack = [];\n    stream.start = stream.pos;\n    while (!stream.eof()) {\n        if (stream.eat(123 /* CurlyBracketOpen */)) {\n            stack.push(stream.pos);\n        }\n        else if (stream.eat(125 /* CurlyBracketClose */)) {\n            if (!stack.length) {\n                stream.pos--;\n                break;\n            }\n            stack.pop();\n        }\n        else {\n            stream.pos++;\n        }\n    }\n    if (stack.length) {\n        stream.pos = stack.pop();\n        throw stream.error(`Expecting }`);\n    }\n    return stream.current();\n}\n/**\n * Check if given character code is an operator and it’s allowed in current context\n */\nfunction isAllowedOperator(ch, ctx) {\n    const op = operatorType(ch);\n    if (!op || ctx.quote || ctx.expression) {\n        // No operators inside quoted values or expressions\n        return false;\n    }\n    // Inside attributes, only `equals` is allowed\n    return !ctx.attribute || op === 'equal';\n}\n/**\n * Check if given character is a space character and is allowed to be consumed\n * as a space token in current context\n */\nfunction isAllowedSpace(ch, ctx) {\n    return isSpace(ch) && !ctx.expression;\n}\n/**\n * Check if given character can be consumed as repeater in current context\n */\nfunction isAllowedRepeater(ch, ctx) {\n    return ch === 42 /* Asterisk */ && !ctx.attribute && !ctx.expression;\n}\n/**\n * If given character is a bracket, returns it’s type\n */\nfunction bracketType(ch) {\n    if (ch === 40 /* RoundBracketOpen */ || ch === 41 /* RoundBracketClose */) {\n        return 'group';\n    }\n    if (ch === 91 /* SquareBracketOpen */ || ch === 93 /* SquareBracketClose */) {\n        return 'attribute';\n    }\n    if (ch === 123 /* CurlyBracketOpen */ || ch === 125 /* CurlyBracketClose */) {\n        return 'expression';\n    }\n}\n/**\n * If given character is an operator, returns it’s type\n */\nfunction operatorType(ch) {\n    return (ch === 62 /* Child */ && 'child')\n        || (ch === 43 /* Sibling */ && 'sibling')\n        || (ch === 94 /* Climb */ && 'climb')\n        || (ch === 46 /* Dot */ && 'class')\n        || (ch === 35 /* Hash */ && 'id')\n        || (ch === 47 /* Slash */ && 'close')\n        || (ch === 61 /* Equals */ && 'equal')\n        || void 0;\n}\n/**\n * Check if given character is an open bracket\n */\nfunction isOpenBracket(ch) {\n    return ch === 123 /* CurlyBracketOpen */\n        || ch === 91 /* SquareBracketOpen */\n        || ch === 40 /* RoundBracketOpen */;\n}\n/**\n * Check if given character is allowed in element name\n */\nfunction isElementName$1(ch) {\n    return isAlphaNumericWord(ch)\n        || ch === 45 /* Dash */\n        || ch === 58 /* Colon */\n        || ch === 33 /* Excl */;\n}\n\nconst operators = {\n    child: '>',\n    class: '.',\n    climb: '^',\n    id: '#',\n    equal: '=',\n    close: '/',\n    sibling: '+'\n};\nconst tokenVisitor = {\n    Literal(token) {\n        return token.value;\n    },\n    Quote(token) {\n        return token.single ? '\\'' : '\"';\n    },\n    Bracket(token) {\n        if (token.context === 'attribute') {\n            return token.open ? '[' : ']';\n        }\n        else if (token.context === 'expression') {\n            return token.open ? '{' : '}';\n        }\n        else {\n            return token.open ? '(' : '}';\n        }\n    },\n    Operator(token) {\n        return operators[token.operator];\n    },\n    Field(token, state) {\n        if (token.index != null) {\n            // It’s a field: by default, return TextMate-compatible field\n            return token.name\n                ? `\\${${token.index}:${token.name}}`\n                : `\\${${token.index}`;\n        }\n        else if (token.name) {\n            // It’s a variable\n            return state.getVariable(token.name);\n        }\n        return '';\n    },\n    RepeaterPlaceholder(token, state) {\n        // Find closest implicit repeater\n        let repeater;\n        for (let i = state.repeaters.length - 1; i >= 0; i--) {\n            if (state.repeaters[i].implicit) {\n                repeater = state.repeaters[i];\n                break;\n            }\n        }\n        state.inserted = true;\n        return state.getText(repeater && repeater.value);\n    },\n    RepeaterNumber(token, state) {\n        let value = 1;\n        const lastIx = state.repeaters.length - 1;\n        // const repeaterIx = Math.max(0, state.repeaters.length - 1 - token.parent);\n        const repeater = state.repeaters[lastIx];\n        if (repeater) {\n            value = token.reverse\n                ? token.base + repeater.count - repeater.value - 1\n                : token.base + repeater.value;\n            if (token.parent) {\n                const parentIx = Math.max(0, lastIx - token.parent);\n                if (parentIx !== lastIx) {\n                    const parentRepeater = state.repeaters[parentIx];\n                    value += repeater.count * parentRepeater.value;\n                }\n            }\n        }\n        let result = String(value);\n        while (result.length < token.size) {\n            result = '0' + result;\n        }\n        return result;\n    },\n    WhiteSpace(token) {\n        return token.value;\n    }\n};\n/**\n * Converts given value token to string\n */\nfunction stringify(token, state) {\n    if (!tokenVisitor[token.type]) {\n        throw new Error(`Unknown token ${token.type}`);\n    }\n    return tokenVisitor[token.type](token, state);\n}\n\nconst urlRegex = /^((https?:|ftp:|file:)?\\/\\/|(www|ftp)\\.)[^ ]*$/;\nconst emailRegex = /^[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,5}$/;\n/**\n * Converts given token-based abbreviation into simplified and unrolled node-based\n * abbreviation\n */\nfunction convert(abbr, options = {}) {\n    let textInserted = false;\n    let cleanText;\n    if (options.text) {\n        if (Array.isArray(options.text)) {\n            cleanText = options.text.filter(s => s.trim());\n        }\n        else {\n            cleanText = options.text;\n        }\n    }\n    const result = {\n        type: 'Abbreviation',\n        children: convertGroup(abbr, {\n            inserted: false,\n            repeaters: [],\n            text: options.text,\n            cleanText,\n            repeatGuard: options.maxRepeat || Number.POSITIVE_INFINITY,\n            getText(pos) {\n                var _a;\n                textInserted = true;\n                let value;\n                if (Array.isArray(options.text)) {\n                    if (pos !== undefined && pos >= 0 && pos < cleanText.length) {\n                        return cleanText[pos];\n                    }\n                    value = pos !== undefined ? options.text[pos] : options.text.join('\\n');\n                }\n                else {\n                    value = (_a = options.text) !== null && _a !== void 0 ? _a : '';\n                }\n                return value;\n            },\n            getVariable(name) {\n                const varValue = options.variables && options.variables[name];\n                return varValue != null ? varValue : name;\n            }\n        })\n    };\n    if (options.text != null && !textInserted) {\n        // Text given but no implicitly repeated elements: insert it into\n        // deepest child\n        const deepest = deepestNode(last(result.children));\n        if (deepest) {\n            const text = Array.isArray(options.text) ? options.text.join('\\n') : options.text;\n            insertText(deepest, text);\n            if (deepest.name === 'a' && options.href) {\n                // Automatically update value of `<a>` element if inserting URL or email\n                insertHref(deepest, text);\n            }\n        }\n    }\n    return result;\n}\n/**\n * Converts given statement to abbreviation nodes\n */\nfunction convertStatement(node, state) {\n    let result = [];\n    if (node.repeat) {\n        // Node is repeated: we should create copies of given node\n        // and supply context token with actual repeater state\n        const original = node.repeat;\n        const repeat = Object.assign({}, original);\n        repeat.count = repeat.implicit && Array.isArray(state.text)\n            ? state.cleanText.length\n            : (repeat.count || 1);\n        let items;\n        state.repeaters.push(repeat);\n        for (let i = 0; i < repeat.count; i++) {\n            repeat.value = i;\n            node.repeat = repeat;\n            items = isGroup(node)\n                ? convertGroup(node, state)\n                : convertElement(node, state);\n            if (repeat.implicit && !state.inserted) {\n                // It’s an implicit repeater but no repeater placeholders found inside,\n                // we should insert text into deepest node\n                const target = last(items);\n                const deepest = target && deepestNode(target);\n                if (deepest) {\n                    insertText(deepest, state.getText(repeat.value));\n                }\n            }\n            result = result.concat(items);\n            // We should output at least one repeated item even if it’s reached\n            // repeat limit\n            if (--state.repeatGuard <= 0) {\n                break;\n            }\n        }\n        state.repeaters.pop();\n        node.repeat = original;\n        if (repeat.implicit) {\n            state.inserted = true;\n        }\n    }\n    else {\n        result = result.concat(isGroup(node) ? convertGroup(node, state) : convertElement(node, state));\n    }\n    return result;\n}\nfunction convertElement(node, state) {\n    let children = [];\n    const elem = {\n        type: 'AbbreviationNode',\n        name: node.name && stringifyName(node.name, state),\n        value: node.value && stringifyValue(node.value, state),\n        attributes: void 0,\n        children,\n        repeat: node.repeat && Object.assign({}, node.repeat),\n        selfClosing: node.selfClose,\n    };\n    let result = [elem];\n    for (const child of node.elements) {\n        children = children.concat(convertStatement(child, state));\n    }\n    if (node.attributes) {\n        elem.attributes = [];\n        for (const attr of node.attributes) {\n            elem.attributes.push(convertAttribute(attr, state));\n        }\n    }\n    // In case if current node is a text-only snippet without fields, we should\n    // put all children as siblings\n    if (!elem.name && !elem.attributes && elem.value && !elem.value.some(isField)) {\n        // XXX it’s unclear that `children` is not bound to `elem`\n        // due to concat operation\n        result = result.concat(children);\n    }\n    else {\n        elem.children = children;\n    }\n    return result;\n}\nfunction convertGroup(node, state) {\n    let result = [];\n    for (const child of node.elements) {\n        result = result.concat(convertStatement(child, state));\n    }\n    if (node.repeat) {\n        result = attachRepeater(result, node.repeat);\n    }\n    return result;\n}\nfunction convertAttribute(node, state) {\n    let implied = false;\n    let isBoolean = false;\n    let valueType = node.expression ? 'expression' : 'raw';\n    let value;\n    const name = node.name && stringifyName(node.name, state);\n    if (name && name[0] === '!') {\n        implied = true;\n    }\n    if (name && name[name.length - 1] === '.') {\n        isBoolean = true;\n    }\n    if (node.value) {\n        const tokens = node.value.slice();\n        if (isQuote(tokens[0])) {\n            // It’s a quoted value: remove quotes from output but mark attribute\n            // value as quoted\n            const quote = tokens.shift();\n            if (tokens.length && last(tokens).type === quote.type) {\n                tokens.pop();\n            }\n            valueType = quote.single ? 'singleQuote' : 'doubleQuote';\n        }\n        else if (isBracket(tokens[0], 'expression', true)) {\n            // Value is expression: remove brackets but mark value type\n            valueType = 'expression';\n            tokens.shift();\n            if (isBracket(last(tokens), 'expression', false)) {\n                tokens.pop();\n            }\n        }\n        value = stringifyValue(tokens, state);\n    }\n    return {\n        name: isBoolean || implied\n            ? name.slice(implied ? 1 : 0, isBoolean ? -1 : void 0)\n            : name,\n        value,\n        boolean: isBoolean,\n        implied,\n        valueType\n    };\n}\n/**\n * Converts given token list to string\n */\nfunction stringifyName(tokens, state) {\n    let str = '';\n    for (let i = 0; i < tokens.length; i++) {\n        str += stringify(tokens[i], state);\n    }\n    return str;\n}\n/**\n * Converts given token list to value list\n */\nfunction stringifyValue(tokens, state) {\n    const result = [];\n    let str = '';\n    for (let i = 0, token; i < tokens.length; i++) {\n        token = tokens[i];\n        if (isField(token)) {\n            // We should keep original fields in output since some editors has their\n            // own syntax for field or doesn’t support fields at all so we should\n            // capture actual field location in output stream\n            if (str) {\n                result.push(str);\n                str = '';\n            }\n            result.push(token);\n        }\n        else {\n            str += stringify(token, state);\n        }\n    }\n    if (str) {\n        result.push(str);\n    }\n    return result;\n}\nfunction isGroup(node) {\n    return node.type === 'TokenGroup';\n}\nfunction isField(token) {\n    return typeof token === 'object' && token.type === 'Field' && token.index != null;\n}\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\nfunction deepestNode(node) {\n    return node.children.length ? deepestNode(last(node.children)) : node;\n}\nfunction insertText(node, text) {\n    if (node.value) {\n        const lastToken = last(node.value);\n        if (typeof lastToken === 'string') {\n            node.value[node.value.length - 1] += text;\n        }\n        else {\n            node.value.push(text);\n        }\n    }\n    else {\n        node.value = [text];\n    }\n}\nfunction insertHref(node, text) {\n    var _a;\n    let href = '';\n    if (urlRegex.test(text)) {\n        href = text;\n        if (!/\\w+:/.test(href) && !href.startsWith('//')) {\n            href = `http://${href}`;\n        }\n    }\n    else if (emailRegex.test(text)) {\n        href = `mailto:${text}`;\n    }\n    const hrefAttribute = (_a = node.attributes) === null || _a === void 0 ? void 0 : _a.find(attr => attr.name === 'href');\n    if (!hrefAttribute) {\n        node.attributes = [{ name: 'href', value: [href], valueType: 'doubleQuote' }];\n    }\n    else if (!hrefAttribute.value) {\n        hrefAttribute.value = [href];\n    }\n}\nfunction attachRepeater(items, repeater) {\n    for (const item of items) {\n        if (!item.repeat) {\n            item.repeat = Object.assign({}, repeater);\n        }\n    }\n    return items;\n}\n\n/**\n * Parses given abbreviation into node tree\n */\nfunction parseAbbreviation(abbr, options) {\n    try {\n        const tokens = typeof abbr === 'string' ? tokenize(abbr) : abbr;\n        return convert(abbreviation(tokens, options), options);\n    }\n    catch (err) {\n        if (err instanceof ScannerError && typeof abbr === 'string') {\n            err.message += `\\n${abbr}\\n${'-'.repeat(err.pos)}^`;\n        }\n        throw err;\n    }\n}\n\nexport default parseAbbreviation;\nexport { convert, getToken, abbreviation as parse, tokenize };\n//# sourceMappingURL=abbreviation.es.js.map\n","import Scanner, { isNumber, isAlpha, isAlphaWord, isQuote, isSpace, isAlphaNumericWord, ScannerError } from '@emmetio/scanner';\n\nfunction tokenize(abbr, isValue) {\n    let brackets = 0;\n    let token;\n    const scanner = new Scanner(abbr);\n    const tokens = [];\n    while (!scanner.eof()) {\n        token = getToken(scanner, brackets === 0 && !isValue);\n        if (!token) {\n            throw scanner.error('Unexpected character');\n        }\n        if (token.type === 'Bracket') {\n            if (!brackets && token.open) {\n                mergeTokens(scanner, tokens);\n            }\n            brackets += token.open ? 1 : -1;\n            if (brackets < 0) {\n                throw scanner.error('Unexpected bracket', token.start);\n            }\n        }\n        tokens.push(token);\n        // Forcibly consume next operator after unit-less numeric value or color:\n        // next dash `-` must be used as value delimiter\n        if (shouldConsumeDashAfter(token) && (token = operator(scanner))) {\n            tokens.push(token);\n        }\n    }\n    return tokens;\n}\n/**\n * Returns next token from given scanner, if possible\n */\nfunction getToken(scanner, short) {\n    return field(scanner)\n        || numberValue(scanner)\n        || colorValue(scanner)\n        || stringValue(scanner)\n        || bracket(scanner)\n        || operator(scanner)\n        || whiteSpace(scanner)\n        || literal(scanner, short);\n}\nfunction field(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(36 /* Dollar */) && scanner.eat(123 /* CurlyBracketOpen */)) {\n        scanner.start = scanner.pos;\n        let index;\n        let name = '';\n        if (scanner.eatWhile(isNumber)) {\n            // It’s a field\n            index = Number(scanner.current());\n            name = scanner.eat(58 /* Colon */) ? consumePlaceholder(scanner) : '';\n        }\n        else if (isAlpha(scanner.peek())) {\n            // It’s a variable\n            name = consumePlaceholder(scanner);\n        }\n        if (scanner.eat(125 /* CurlyBracketClose */)) {\n            return {\n                type: 'Field',\n                index, name,\n                start,\n                end: scanner.pos\n            };\n        }\n        throw scanner.error('Expecting }');\n    }\n    // If we reached here then there’s no valid field here, revert\n    // back to starting position\n    scanner.pos = start;\n}\n/**\n * Consumes a placeholder: value right after `:` in field. Could be empty\n */\nfunction consumePlaceholder(stream) {\n    const stack = [];\n    stream.start = stream.pos;\n    while (!stream.eof()) {\n        if (stream.eat(123 /* CurlyBracketOpen */)) {\n            stack.push(stream.pos);\n        }\n        else if (stream.eat(125 /* CurlyBracketClose */)) {\n            if (!stack.length) {\n                stream.pos--;\n                break;\n            }\n            stack.pop();\n        }\n        else {\n            stream.pos++;\n        }\n    }\n    if (stack.length) {\n        stream.pos = stack.pop();\n        throw stream.error(`Expecting }`);\n    }\n    return stream.current();\n}\n/**\n * Consumes literal from given scanner\n * @param short Use short notation for consuming value.\n * The difference between “short” and “full” notation is that first one uses\n * alpha characters only and used for extracting keywords from abbreviation,\n * while “full” notation also supports numbers and dashes\n */\nfunction literal(scanner, short) {\n    const start = scanner.pos;\n    if (scanner.eat(isIdentPrefix)) {\n        // SCSS or LESS variable\n        // NB a bit dirty hack: if abbreviation starts with identifier prefix,\n        // consume alpha characters only to allow embedded variables\n        scanner.eatWhile(start ? isKeyword : isLiteral);\n    }\n    else if (scanner.eat(isAlphaWord)) {\n        scanner.eatWhile(short ? isLiteral : isKeyword);\n    }\n    else {\n        // Allow dots only at the beginning of literal\n        scanner.eat(46 /* Dot */);\n        scanner.eatWhile(isLiteral);\n    }\n    if (start !== scanner.pos) {\n        scanner.start = start;\n        return createLiteral(scanner, scanner.start = start);\n    }\n}\nfunction createLiteral(scanner, start = scanner.start, end = scanner.pos) {\n    return {\n        type: 'Literal',\n        value: scanner.substring(start, end),\n        start,\n        end\n    };\n}\n/**\n * Consumes numeric CSS value (number with optional unit) from current stream,\n * if possible\n */\nfunction numberValue(scanner) {\n    const start = scanner.pos;\n    if (consumeNumber(scanner)) {\n        scanner.start = start;\n        const rawValue = scanner.current();\n        // eat unit, which can be a % or alpha word\n        scanner.start = scanner.pos;\n        scanner.eat(37 /* Percent */) || scanner.eatWhile(isAlphaWord);\n        return {\n            type: 'NumberValue',\n            value: Number(rawValue),\n            rawValue,\n            unit: scanner.current(),\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes quoted string value from given scanner\n */\nfunction stringValue(scanner) {\n    const ch = scanner.peek();\n    const start = scanner.pos;\n    let finished = false;\n    if (isQuote(ch)) {\n        scanner.pos++;\n        while (!scanner.eof()) {\n            // Do not throw error on malformed string\n            if (scanner.eat(ch)) {\n                finished = true;\n                break;\n            }\n            else {\n                scanner.pos++;\n            }\n        }\n        scanner.start = start;\n        return {\n            type: 'StringValue',\n            value: scanner.substring(start + 1, scanner.pos - (finished ? 1 : 0)),\n            quote: ch === 39 /* SingleQuote */ ? 'single' : 'double',\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes a color token from given string\n */\nfunction colorValue(scanner) {\n    // supported color variations:\n    // #abc   → #aabbccc\n    // #0     → #000000\n    // #fff.5 → rgba(255, 255, 255, 0.5)\n    // #t     → transparent\n    const start = scanner.pos;\n    if (scanner.eat(35 /* Hash */)) {\n        const valueStart = scanner.pos;\n        let color = '';\n        let alpha = '';\n        if (scanner.eatWhile(isHex)) {\n            color = scanner.substring(valueStart, scanner.pos);\n            alpha = colorAlpha(scanner);\n        }\n        else if (scanner.eat(116 /* Transparent */)) {\n            color = '0';\n            alpha = colorAlpha(scanner) || '0';\n        }\n        else {\n            alpha = colorAlpha(scanner);\n        }\n        if (color || alpha || scanner.eof()) {\n            const { r, g, b, a } = parseColor(color, alpha);\n            return {\n                type: 'ColorValue',\n                r, g, b, a,\n                raw: scanner.substring(start + 1, scanner.pos),\n                start,\n                end: scanner.pos\n            };\n        }\n        else {\n            // Consumed # but no actual value: invalid color value, treat it as literal\n            return createLiteral(scanner, start);\n        }\n    }\n    scanner.pos = start;\n}\n/**\n * Consumes alpha value of color: `.1`\n */\nfunction colorAlpha(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(46 /* Dot */)) {\n        scanner.start = start;\n        if (scanner.eatWhile(isNumber)) {\n            return scanner.current();\n        }\n        return '1';\n    }\n    return '';\n}\n/**\n * Consumes white space characters as string literal from given scanner\n */\nfunction whiteSpace(scanner) {\n    const start = scanner.pos;\n    if (scanner.eatWhile(isSpace)) {\n        return {\n            type: 'WhiteSpace',\n            start,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes bracket from given scanner\n */\nfunction bracket(scanner) {\n    const ch = scanner.peek();\n    if (isBracket(ch)) {\n        return {\n            type: 'Bracket',\n            open: ch === 40 /* RoundBracketOpen */,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Consumes operator from given scanner\n */\nfunction operator(scanner) {\n    const op = operatorType(scanner.peek());\n    if (op) {\n        return {\n            type: 'Operator',\n            operator: op,\n            start: scanner.pos++,\n            end: scanner.pos\n        };\n    }\n}\n/**\n * Eats number value from given stream\n * @return Returns `true` if number was consumed\n */\nfunction consumeNumber(stream) {\n    const start = stream.pos;\n    stream.eat(45 /* Dash */);\n    const afterNegative = stream.pos;\n    const hasDecimal = stream.eatWhile(isNumber);\n    const prevPos = stream.pos;\n    if (stream.eat(46 /* Dot */)) {\n        // It’s perfectly valid to have numbers like `1.`, which enforces\n        // value to float unit type\n        const hasFloat = stream.eatWhile(isNumber);\n        if (!hasDecimal && !hasFloat) {\n            // Lone dot\n            stream.pos = prevPos;\n        }\n    }\n    // Edge case: consumed dash only: not a number, bail-out\n    if (stream.pos === afterNegative) {\n        stream.pos = start;\n    }\n    return stream.pos !== start;\n}\nfunction isIdentPrefix(code) {\n    return code === 64 /* At */ || code === 36 /* Dollar */;\n}\n/**\n * If given character is an operator, returns it’s type\n */\nfunction operatorType(ch) {\n    return (ch === 43 /* Sibling */ && \"+\" /* Sibling */)\n        || (ch === 33 /* Excl */ && \"!\" /* Important */)\n        || (ch === 44 /* Comma */ && \",\" /* ArgumentDelimiter */)\n        || (ch === 58 /* Colon */ && \":\" /* PropertyDelimiter */)\n        || (ch === 45 /* Dash */ && \"-\" /* ValueDelimiter */)\n        || void 0;\n}\n/**\n * Check if given code is a hex value (/0-9a-f/)\n */\nfunction isHex(code) {\n    return isNumber(code) || isAlpha(code, 65, 70); // A-F\n}\nfunction isKeyword(code) {\n    return isAlphaNumericWord(code) || code === 45 /* Dash */;\n}\nfunction isBracket(code) {\n    return code === 40 /* RoundBracketOpen */ || code === 41 /* RoundBracketClose */;\n}\nfunction isLiteral(code) {\n    return isAlphaWord(code) || code === 37 /* Percent */ || code === 47 /* Slash */;\n}\n/**\n * Parses given color value from abbreviation into RGBA format\n */\nfunction parseColor(value, alpha) {\n    let r = '0';\n    let g = '0';\n    let b = '0';\n    let a = Number(alpha != null && alpha !== '' ? alpha : 1);\n    if (value === 't') {\n        a = 0;\n    }\n    else {\n        switch (value.length) {\n            case 0:\n                break;\n            case 1:\n                r = g = b = value + value;\n                break;\n            case 2:\n                r = g = b = value;\n                break;\n            case 3:\n                r = value[0] + value[0];\n                g = value[1] + value[1];\n                b = value[2] + value[2];\n                break;\n            default:\n                value += value;\n                r = value.slice(0, 2);\n                g = value.slice(2, 4);\n                b = value.slice(4, 6);\n        }\n    }\n    return {\n        r: parseInt(r, 16),\n        g: parseInt(g, 16),\n        b: parseInt(b, 16),\n        a\n    };\n}\n/**\n * Check if scanner reader must consume dash after given token.\n * Used in cases where user must explicitly separate numeric values\n */\nfunction shouldConsumeDashAfter(token) {\n    return token.type === 'ColorValue' || (token.type === 'NumberValue' && !token.unit);\n}\n/**\n * Merges last adjacent tokens into a single literal.\n * This function is used to overcome edge case when function name was parsed\n * as a list of separate tokens. For example, a `scale3d()` value will be\n * parsed as literal and number tokens (`scale` and `3d`) which is a perfectly\n * valid abbreviation but undesired result. This function will detect last adjacent\n * literal and number values and combine them into single literal\n */\nfunction mergeTokens(scanner, tokens) {\n    let start = 0;\n    let end = 0;\n    while (tokens.length) {\n        const token = last(tokens);\n        if (token.type === 'Literal' || token.type === 'NumberValue') {\n            start = token.start;\n            if (!end) {\n                end = token.end;\n            }\n            tokens.pop();\n        }\n        else {\n            break;\n        }\n    }\n    if (start !== end) {\n        tokens.push(createLiteral(scanner, start, end));\n    }\n}\nfunction last(arr) {\n    return arr[arr.length - 1];\n}\n\nfunction tokenScanner(tokens) {\n    return {\n        tokens,\n        start: 0,\n        pos: 0,\n        size: tokens.length\n    };\n}\nfunction peek(scanner) {\n    return scanner.tokens[scanner.pos];\n}\nfunction readable(scanner) {\n    return scanner.pos < scanner.size;\n}\nfunction consume(scanner, test) {\n    if (test(peek(scanner))) {\n        scanner.pos++;\n        return true;\n    }\n    return false;\n}\nfunction error(scanner, message, token = peek(scanner)) {\n    if (token && token.start != null) {\n        message += ` at ${token.start}`;\n    }\n    const err = new Error(message);\n    err['pos'] = token && token.start;\n    return err;\n}\n\nfunction parser(tokens, options = {}) {\n    const scanner = tokenScanner(tokens);\n    const result = [];\n    let property;\n    while (readable(scanner)) {\n        if (property = consumeProperty(scanner, options)) {\n            result.push(property);\n        }\n        else if (!consume(scanner, isSiblingOperator)) {\n            throw error(scanner, 'Unexpected token');\n        }\n    }\n    return result;\n}\n/**\n * Consumes single CSS property\n */\nfunction consumeProperty(scanner, options) {\n    let name;\n    let important = false;\n    let valueFragment;\n    const value = [];\n    const token = peek(scanner);\n    const valueMode = !!options.value;\n    if (!valueMode && isLiteral$1(token) && !isFunctionStart(scanner)) {\n        scanner.pos++;\n        name = token.value;\n        // Consume any following value delimiter after property name\n        consume(scanner, isValueDelimiter);\n    }\n    // Skip whitespace right after property name, if any\n    if (valueMode) {\n        consume(scanner, isWhiteSpace);\n    }\n    while (readable(scanner)) {\n        if (consume(scanner, isImportant)) {\n            important = true;\n        }\n        else if (valueFragment = consumeValue(scanner, valueMode)) {\n            value.push(valueFragment);\n        }\n        else if (!consume(scanner, isFragmentDelimiter)) {\n            break;\n        }\n    }\n    if (name || value.length || important) {\n        return { name, value, important };\n    }\n}\n/**\n * Consumes single value fragment, e.g. all value tokens before comma\n */\nfunction consumeValue(scanner, inArgument) {\n    const result = [];\n    let token;\n    let args;\n    while (readable(scanner)) {\n        token = peek(scanner);\n        if (isValue(token)) {\n            scanner.pos++;\n            if (isLiteral$1(token) && (args = consumeArguments(scanner))) {\n                result.push({\n                    type: 'FunctionCall',\n                    name: token.value,\n                    arguments: args\n                });\n            }\n            else {\n                result.push(token);\n            }\n        }\n        else if (isValueDelimiter(token) || (inArgument && isWhiteSpace(token))) {\n            scanner.pos++;\n        }\n        else {\n            break;\n        }\n    }\n    return result.length\n        ? { type: 'CSSValue', value: result }\n        : void 0;\n}\nfunction consumeArguments(scanner) {\n    const start = scanner.pos;\n    if (consume(scanner, isOpenBracket)) {\n        const args = [];\n        let value;\n        while (readable(scanner) && !consume(scanner, isCloseBracket)) {\n            if (value = consumeValue(scanner, true)) {\n                args.push(value);\n            }\n            else if (!consume(scanner, isWhiteSpace) && !consume(scanner, isArgumentDelimiter)) {\n                throw error(scanner, 'Unexpected token');\n            }\n        }\n        scanner.start = start;\n        return args;\n    }\n}\nfunction isLiteral$1(token) {\n    return token && token.type === 'Literal';\n}\nfunction isBracket$1(token, open) {\n    return token && token.type === 'Bracket' && (open == null || token.open === open);\n}\nfunction isOpenBracket(token) {\n    return isBracket$1(token, true);\n}\nfunction isCloseBracket(token) {\n    return isBracket$1(token, false);\n}\nfunction isWhiteSpace(token) {\n    return token && token.type === 'WhiteSpace';\n}\nfunction isOperator(token, operator) {\n    return token && token.type === 'Operator' && (!operator || token.operator === operator);\n}\nfunction isSiblingOperator(token) {\n    return isOperator(token, \"+\" /* Sibling */);\n}\nfunction isArgumentDelimiter(token) {\n    return isOperator(token, \",\" /* ArgumentDelimiter */);\n}\nfunction isFragmentDelimiter(token) {\n    return isArgumentDelimiter(token);\n}\nfunction isImportant(token) {\n    return isOperator(token, \"!\" /* Important */);\n}\nfunction isValue(token) {\n    return token.type === 'StringValue'\n        || token.type === 'ColorValue'\n        || token.type === 'NumberValue'\n        || token.type === 'Literal'\n        || token.type === 'Field';\n}\nfunction isValueDelimiter(token) {\n    return isOperator(token, \":\" /* PropertyDelimiter */)\n        || isOperator(token, \"-\" /* ValueDelimiter */);\n}\nfunction isFunctionStart(scanner) {\n    const t1 = scanner.tokens[scanner.pos];\n    const t2 = scanner.tokens[scanner.pos + 1];\n    return t1 && t2 && isLiteral$1(t1) && t2.type === 'Bracket';\n}\n\n/**\n * Parses given abbreviation into property set\n */\nfunction parse(abbr, options) {\n    try {\n        const tokens = typeof abbr === 'string' ? tokenize(abbr, options && options.value) : abbr;\n        return parser(tokens, options);\n    }\n    catch (err) {\n        if (err instanceof ScannerError && typeof abbr === 'string') {\n            err.message += `\\n${abbr}\\n${'-'.repeat(err.pos)}^`;\n        }\n        throw err;\n    }\n}\n\nexport default parse;\nexport { getToken, parser, tokenize };\n","import parse$2 from '@emmetio/abbreviation';\nexport { default as markupAbbreviation } from '@emmetio/abbreviation';\nimport parse$3 from '@emmetio/css-abbreviation';\nexport { default as stylesheetAbbreviation } from '@emmetio/css-abbreviation';\n\n/**\n * Merges attributes in current node: de-duplicates attributes with the same name\n * and merges class names\n */\nfunction mergeAttributes(node, config) {\n    if (!node.attributes) {\n        return;\n    }\n    const attributes = [];\n    const lookup = {};\n    for (const attr of node.attributes) {\n        if (attr.name) {\n            const attrName = attr.name;\n            if (attrName in lookup) {\n                const prev = lookup[attrName];\n                if (attrName === 'class') {\n                    prev.value = mergeValue(prev.value, attr.value, ' ');\n                }\n                else {\n                    mergeDeclarations(prev, attr, config);\n                }\n            }\n            else {\n                // Create new attribute instance so we can safely modify it later\n                attributes.push(lookup[attrName] = Object.assign({}, attr));\n            }\n        }\n        else {\n            attributes.push(attr);\n        }\n    }\n    node.attributes = attributes;\n}\n/**\n * Merges two token lists into single list. Adjacent strings are merged together\n */\nfunction mergeValue(prev, next, glue) {\n    if (prev && next) {\n        if (prev.length && glue) {\n            append(prev, glue);\n        }\n        for (const t of next) {\n            append(prev, t);\n        }\n        return prev;\n    }\n    const result = prev || next;\n    return result && result.slice();\n}\n/**\n * Merges data from `src` attribute into `dest` and returns it\n */\nfunction mergeDeclarations(dest, src, config) {\n    dest.name = src.name;\n    if (!config.options['output.reverseAttributes']) {\n        dest.value = src.value;\n    }\n    // Keep high-priority properties\n    if (!dest.implied) {\n        dest.implied = src.implied;\n    }\n    if (!dest.boolean) {\n        dest.boolean = src.boolean;\n    }\n    if (dest.valueType !== 'expression') {\n        dest.valueType = src.valueType;\n    }\n    return dest;\n}\nfunction append(tokens, value) {\n    const lastIx = tokens.length - 1;\n    if (typeof tokens[lastIx] === 'string' && typeof value === 'string') {\n        tokens[lastIx] += value;\n    }\n    else {\n        tokens.push(value);\n    }\n}\n\n/**\n * Walks over each child node of given markup abbreviation AST node (not including\n * given one) and invokes `fn` on each node.\n * The `fn` callback accepts context node, list of ancestor nodes and optional\n * state object\n */\nfunction walk(node, fn, state) {\n    const ancestors = [node];\n    const callback = (ctx) => {\n        fn(ctx, ancestors, state);\n        ancestors.push(ctx);\n        ctx.children.forEach(callback);\n        ancestors.pop();\n    };\n    node.children.forEach(callback);\n}\n/**\n * Finds node which is the deepest for in current node or node itself.\n */\nfunction findDeepest(node) {\n    let parent;\n    while (node.children.length) {\n        parent = node;\n        node = node.children[node.children.length - 1];\n    }\n    return { parent, node };\n}\nfunction isNode(node) {\n    return node.type === 'AbbreviationNode';\n}\n\n/**\n * Finds matching snippet from `registry` and resolves it into a parsed abbreviation.\n * Resolved node is then updated or replaced with matched abbreviation tree.\n *\n * A HTML registry basically contains aliases to another Emmet abbreviations,\n * e.g. a predefined set of name, attributes and so on, possibly a complex\n * abbreviation with multiple elements. So we have to get snippet, parse it\n * and recursively resolve it.\n */\nfunction resolveSnippets(abbr, config) {\n    const stack = [];\n    const reversed = config.options['output.reverseAttributes'];\n    const resolve = (child) => {\n        const snippet = child.name && config.snippets[child.name];\n        // A snippet in stack means circular reference.\n        // It can be either a user error or a perfectly valid snippet like\n        // \"img\": \"img[src alt]/\", e.g. an element with predefined shape.\n        // In any case, simply stop parsing and keep element as is\n        if (!snippet || stack.includes(snippet)) {\n            return null;\n        }\n        const snippetAbbr = parse$2(snippet, config);\n        stack.push(snippet);\n        walkResolve(snippetAbbr, resolve);\n        stack.pop();\n        // Add attributes from current node into every top-level node of parsed abbreviation\n        for (const topNode of snippetAbbr.children) {\n            if (child.attributes) {\n                const from = topNode.attributes || [];\n                const to = child.attributes || [];\n                topNode.attributes = reversed ? to.concat(from) : from.concat(to);\n            }\n            mergeNodes(child, topNode);\n        }\n        return snippetAbbr;\n    };\n    walkResolve(abbr, resolve);\n    return abbr;\n}\nfunction walkResolve(node, resolve, config) {\n    let children = [];\n    for (const child of node.children) {\n        const resolved = resolve(child);\n        if (resolved) {\n            children = children.concat(resolved.children);\n            const deepest = findDeepest(resolved);\n            if (isNode(deepest.node)) {\n                deepest.node.children = deepest.node.children.concat(walkResolve(child, resolve));\n            }\n        }\n        else {\n            children.push(child);\n            child.children = walkResolve(child, resolve);\n        }\n    }\n    return node.children = children;\n}\n/**\n * Adds data from first node into second node\n */\nfunction mergeNodes(from, to) {\n    if (from.selfClosing) {\n        to.selfClosing = true;\n    }\n    if (from.value != null) {\n        to.value = from.value;\n    }\n    if (from.repeat) {\n        to.repeat = from.repeat;\n    }\n}\n\nfunction createOutputStream(options, level = 0) {\n    return {\n        options,\n        value: '',\n        level,\n        offset: 0,\n        line: 0,\n        column: 0\n    };\n}\n/**\n * Pushes plain string into output stream without newline processing\n */\nfunction push(stream, text) {\n    const processText = stream.options['output.text'];\n    _push(stream, processText(text, stream.offset, stream.line, stream.column));\n}\n/**\n * Pushes given string with possible newline formatting into output\n */\nfunction pushString(stream, value) {\n    // If given value contains newlines, we should push content line-by-line and\n    // use `pushNewline()` to maintain proper line/column state\n    const lines = splitByLines(value);\n    for (let i = 0, il = lines.length - 1; i <= il; i++) {\n        push(stream, lines[i]);\n        if (i !== il) {\n            pushNewline(stream, true);\n        }\n    }\n}\n/**\n * Pushes new line into given output stream\n */\nfunction pushNewline(stream, indent) {\n    const baseIndent = stream.options['output.baseIndent'];\n    const newline = stream.options['output.newline'];\n    push(stream, newline + baseIndent);\n    stream.line++;\n    stream.column = baseIndent.length;\n    if (indent) {\n        pushIndent(stream, indent === true ? stream.level : indent);\n    }\n}\n/**\n * Adds indentation of `size` to current output stream\n */\nfunction pushIndent(stream, size = stream.level) {\n    const indent = stream.options['output.indent'];\n    push(stream, indent.repeat(Math.max(size, 0)));\n}\n/**\n * Pushes field/tabstop into output stream\n */\nfunction pushField(stream, index, placeholder) {\n    const field = stream.options['output.field'];\n    // NB: use `_push` instead of `push` to skip text processing\n    _push(stream, field(index, placeholder, stream.offset, stream.line, stream.column));\n}\n/**\n * Returns given tag name formatted according to given config\n */\nfunction tagName(name, config) {\n    return strCase(name, config.options['output.tagCase']);\n}\n/**\n * Returns given attribute name formatted according to given config\n */\nfunction attrName(name, config) {\n    return strCase(name, config.options['output.attributeCase']);\n}\n/**\n * Returns character for quoting value of given attribute\n */\nfunction attrQuote(attr, config, isOpen) {\n    if (attr.valueType === 'expression') {\n        return isOpen ? '{' : '}';\n    }\n    return config.options['output.attributeQuotes'] === 'single' ? '\\'' : '\"';\n}\n/**\n * Check if given attribute is boolean\n */\nfunction isBooleanAttribute(attr, config) {\n    return attr.boolean\n        || config.options['output.booleanAttributes'].includes((attr.name || '').toLowerCase());\n}\n/**\n * Returns a token for self-closing tag, depending on current options\n */\nfunction selfClose(config) {\n    switch (config.options['output.selfClosingStyle']) {\n        case 'xhtml': return ' /';\n        case 'xml': return '/';\n        default: return '';\n    }\n}\n/**\n * Check if given tag name belongs to inline-level element\n * @param node Parsed node or tag name\n */\nfunction isInline(node, config) {\n    if (typeof node === 'string') {\n        return config.options.inlineElements.includes(node.toLowerCase());\n    }\n    // inline node is a node either with inline-level name or text-only node\n    return node.name ? isInline(node.name, config) : Boolean(node.value && !node.attributes);\n}\n/**\n * Splits given text by lines\n */\nfunction splitByLines(text) {\n    return text.split(/\\r\\n|\\r|\\n/g);\n}\n/**\n * Pushes raw string into output stream without any processing\n */\nfunction _push(stream, text) {\n    stream.value += text;\n    stream.offset += text.length;\n    stream.column += text.length;\n}\nfunction strCase(str, type) {\n    if (type) {\n        return type === 'upper' ? str.toUpperCase() : str.toLowerCase();\n    }\n    return str;\n}\n\nconst elementMap = {\n    p: 'span',\n    ul: 'li',\n    ol: 'li',\n    table: 'tr',\n    tr: 'td',\n    tbody: 'tr',\n    thead: 'tr',\n    tfoot: 'tr',\n    colgroup: 'col',\n    select: 'option',\n    optgroup: 'option',\n    audio: 'source',\n    video: 'source',\n    object: 'param',\n    map: 'area'\n};\nfunction implicitTag(node, ancestors, config) {\n    if (!node.name && node.attributes) {\n        resolveImplicitTag(node, ancestors, config);\n    }\n}\nfunction resolveImplicitTag(node, ancestors, config) {\n    const parent = getParentElement(ancestors);\n    const contextName = config.context ? config.context.name : '';\n    const parentName = lowercase(parent ? parent.name : contextName);\n    node.name = elementMap[parentName]\n        || (isInline(parentName, config) ? 'span' : 'div');\n}\nfunction lowercase(str) {\n    return (str || '').toLowerCase();\n}\n/**\n * Returns closest element node from given ancestors list\n */\nfunction getParentElement(ancestors) {\n    for (let i = ancestors.length - 1; i >= 0; i--) {\n        const elem = ancestors[i];\n        if (isNode(elem)) {\n            return elem;\n        }\n    }\n}\n\nvar latin = {\n\t\"common\": [\"lorem\", \"ipsum\", \"dolor\", \"sit\", \"amet\", \"consectetur\", \"adipisicing\", \"elit\"],\n\t\"words\": [\"exercitationem\", \"perferendis\", \"perspiciatis\", \"laborum\", \"eveniet\",\n\t\t\"sunt\", \"iure\", \"nam\", \"nobis\", \"eum\", \"cum\", \"officiis\", \"excepturi\",\n\t\t\"odio\", \"consectetur\", \"quasi\", \"aut\", \"quisquam\", \"vel\", \"eligendi\",\n\t\t\"itaque\", \"non\", \"odit\", \"tempore\", \"quaerat\", \"dignissimos\",\n\t\t\"facilis\", \"neque\", \"nihil\", \"expedita\", \"vitae\", \"vero\", \"ipsum\",\n\t\t\"nisi\", \"animi\", \"cumque\", \"pariatur\", \"velit\", \"modi\", \"natus\",\n\t\t\"iusto\", \"eaque\", \"sequi\", \"illo\", \"sed\", \"ex\", \"et\", \"voluptatibus\",\n\t\t\"tempora\", \"veritatis\", \"ratione\", \"assumenda\", \"incidunt\", \"nostrum\",\n\t\t\"placeat\", \"aliquid\", \"fuga\", \"provident\", \"praesentium\", \"rem\",\n\t\t\"necessitatibus\", \"suscipit\", \"adipisci\", \"quidem\", \"possimus\",\n\t\t\"voluptas\", \"debitis\", \"sint\", \"accusantium\", \"unde\", \"sapiente\",\n\t\t\"voluptate\", \"qui\", \"aspernatur\", \"laudantium\", \"soluta\", \"amet\",\n\t\t\"quo\", \"aliquam\", \"saepe\", \"culpa\", \"libero\", \"ipsa\", \"dicta\",\n\t\t\"reiciendis\", \"nesciunt\", \"doloribus\", \"autem\", \"impedit\", \"minima\",\n\t\t\"maiores\", \"repudiandae\", \"ipsam\", \"obcaecati\", \"ullam\", \"enim\",\n\t\t\"totam\", \"delectus\", \"ducimus\", \"quis\", \"voluptates\", \"dolores\",\n\t\t\"molestiae\", \"harum\", \"dolorem\", \"quia\", \"voluptatem\", \"molestias\",\n\t\t\"magni\", \"distinctio\", \"omnis\", \"illum\", \"dolorum\", \"voluptatum\", \"ea\",\n\t\t\"quas\", \"quam\", \"corporis\", \"quae\", \"blanditiis\", \"atque\", \"deserunt\",\n\t\t\"laboriosam\", \"earum\", \"consequuntur\", \"hic\", \"cupiditate\",\n\t\t\"quibusdam\", \"accusamus\", \"ut\", \"rerum\", \"error\", \"minus\", \"eius\",\n\t\t\"ab\", \"ad\", \"nemo\", \"fugit\", \"officia\", \"at\", \"in\", \"id\", \"quos\",\n\t\t\"reprehenderit\", \"numquam\", \"iste\", \"fugiat\", \"sit\", \"inventore\",\n\t\t\"beatae\", \"repellendus\", \"magnam\", \"recusandae\", \"quod\", \"explicabo\",\n\t\t\"doloremque\", \"aperiam\", \"consequatur\", \"asperiores\", \"commodi\",\n\t\t\"optio\", \"dolor\", \"labore\", \"temporibus\", \"repellat\", \"veniam\",\n\t\t\"architecto\", \"est\", \"esse\", \"mollitia\", \"nulla\", \"a\", \"similique\",\n\t\t\"eos\", \"alias\", \"dolore\", \"tenetur\", \"deleniti\", \"porro\", \"facere\",\n\t\t\"maxime\", \"corrupti\"]\n};\n\nvar ru = {\n\t\"common\": [\"далеко-далеко\", \"за\", \"словесными\", \"горами\", \"в стране\", \"гласных\", \"и согласных\", \"живут\", \"рыбные\", \"тексты\"],\n\t\"words\": [\"вдали\", \"от всех\", \"они\", \"буквенных\", \"домах\", \"на берегу\", \"семантика\",\n\t\t\"большого\", \"языкового\", \"океана\", \"маленький\", \"ручеек\", \"даль\",\n\t\t\"журчит\", \"по всей\", \"обеспечивает\", \"ее\",\"всеми\", \"необходимыми\",\n\t\t\"правилами\", \"эта\", \"парадигматическая\", \"страна\", \"которой\", \"жаренные\",\n\t\t\"предложения\", \"залетают\", \"прямо\", \"рот\", \"даже\", \"всемогущая\",\n\t\t\"пунктуация\", \"не\", \"имеет\", \"власти\", \"над\", \"рыбными\", \"текстами\",\n\t\t\"ведущими\", \"безорфографичный\", \"образ\", \"жизни\", \"однажды\", \"одна\",\n\t\t\"маленькая\", \"строчка\",\"рыбного\", \"текста\", \"имени\", \"lorem\", \"ipsum\",\n\t\t\"решила\", \"выйти\", \"большой\", \"мир\", \"грамматики\", \"великий\", \"оксмокс\",\n\t\t\"предупреждал\", \"о\", \"злых\", \"запятых\", \"диких\", \"знаках\", \"вопроса\",\n\t\t\"коварных\", \"точках\", \"запятой\", \"но\", \"текст\", \"дал\", \"сбить\",\n\t\t\"себя\", \"толку\", \"он\", \"собрал\", \"семь\", \"своих\", \"заглавных\", \"букв\",\n\t\t\"подпоясал\", \"инициал\", \"за\", \"пояс\", \"пустился\", \"дорогу\",\n\t\t\"взобравшись\", \"первую\", \"вершину\", \"курсивных\", \"гор\", \"бросил\",\n\t\t\"последний\", \"взгляд\", \"назад\", \"силуэт\", \"своего\", \"родного\", \"города\",\n\t\t\"буквоград\", \"заголовок\", \"деревни\", \"алфавит\", \"подзаголовок\", \"своего\",\n\t\t\"переулка\", \"грустный\", \"реторический\", \"вопрос\", \"скатился\", \"его\",\n\t\t\"щеке\", \"продолжил\", \"свой\", \"путь\", \"дороге\", \"встретил\", \"рукопись\",\n\t\t\"она\", \"предупредила\",  \"моей\", \"все\", \"переписывается\", \"несколько\",\n\t\t\"раз\", \"единственное\", \"что\", \"меня\", \"осталось\", \"это\", \"приставка\",\n\t\t\"возвращайся\", \"ты\", \"лучше\", \"свою\", \"безопасную\", \"страну\", \"послушавшись\",\n\t\t\"рукописи\", \"наш\", \"продолжил\", \"свой\", \"путь\", \"вскоре\", \"ему\",\n\t\t\"повстречался\", \"коварный\", \"составитель\", \"рекламных\", \"текстов\",\n\t\t\"напоивший\", \"языком\", \"речью\", \"заманивший\", \"свое\", \"агентство\",\n\t\t\"которое\", \"использовало\", \"снова\", \"снова\", \"своих\", \"проектах\",\n\t\t\"если\", \"переписали\", \"то\", \"живет\", \"там\", \"до\", \"сих\", \"пор\"]\n};\n\nvar sp = {\n\t\"common\": [\"mujer\", \"uno\", \"dolor\", \"más\", \"de\", \"poder\", \"mismo\", \"si\"],\n\t\"words\": [\"ejercicio\", \"preferencia\", \"perspicacia\", \"laboral\", \"paño\",\n\t\t\"suntuoso\", \"molde\", \"namibia\", \"planeador\", \"mirar\", \"demás\", \"oficinista\", \"excepción\",\n\t\t\"odio\", \"consecuencia\", \"casi\", \"auto\", \"chicharra\", \"velo\", \"elixir\",\n\t\t\"ataque\", \"no\", \"odio\", \"temporal\", \"cuórum\", \"dignísimo\",\n\t\t\"facilismo\", \"letra\", \"nihilista\", \"expedición\", \"alma\", \"alveolar\", \"aparte\",\n\t\t\"león\", \"animal\", \"como\", \"paria\", \"belleza\", \"modo\", \"natividad\",\n\t\t\"justo\", \"ataque\", \"séquito\", \"pillo\", \"sed\", \"ex\", \"y\", \"voluminoso\",\n\t\t\"temporalidad\", \"verdades\", \"racional\", \"asunción\", \"incidente\", \"marejada\",\n\t\t\"placenta\", \"amanecer\", \"fuga\", \"previsor\", \"presentación\", \"lejos\",\n\t\t\"necesariamente\", \"sospechoso\", \"adiposidad\", \"quindío\", \"pócima\",\n\t\t\"voluble\", \"débito\", \"sintió\", \"accesorio\", \"falda\", \"sapiencia\",\n\t\t\"volutas\", \"queso\", \"permacultura\", \"laudo\", \"soluciones\", \"entero\",\n\t\t\"pan\", \"litro\", \"tonelada\", \"culpa\", \"libertario\", \"mosca\", \"dictado\",\n\t\t\"reincidente\", \"nascimiento\", \"dolor\", \"escolar\", \"impedimento\", \"mínima\",\n\t\t\"mayores\", \"repugnante\", \"dulce\", \"obcecado\", \"montaña\", \"enigma\",\n\t\t\"total\", \"deletéreo\", \"décima\", \"cábala\", \"fotografía\", \"dolores\",\n\t\t\"molesto\", \"olvido\", \"paciencia\", \"resiliencia\", \"voluntad\", \"molestias\",\n\t\t\"magnífico\", \"distinción\", \"ovni\", \"marejada\", \"cerro\", \"torre\", \"y\",\n\t\t\"abogada\", \"manantial\", \"corporal\", \"agua\", \"crepúsculo\", \"ataque\", \"desierto\",\n\t\t\"laboriosamente\", \"angustia\", \"afortunado\", \"alma\", \"encefalograma\",\n\t\t\"materialidad\", \"cosas\", \"o\", \"renuncia\", \"error\", \"menos\", \"conejo\",\n\t\t\"abadía\", \"analfabeto\", \"remo\", \"fugacidad\", \"oficio\", \"en\", \"almácigo\", \"vos\", \"pan\",\n\t\t\"represión\", \"números\", \"triste\", \"refugiado\", \"trote\", \"inventor\",\n\t\t\"corchea\", \"repelente\", \"magma\", \"recusado\", \"patrón\", \"explícito\",\n\t\t\"paloma\", \"síndrome\", \"inmune\", \"autoinmune\", \"comodidad\",\n\t\t\"ley\", \"vietnamita\", \"demonio\", \"tasmania\", \"repeler\", \"apéndice\",\n\t\t\"arquitecto\", \"columna\", \"yugo\", \"computador\", \"mula\", \"a\", \"propósito\",\n\t\t\"fantasía\", \"alias\", \"rayo\", \"tenedor\", \"deleznable\", \"ventana\", \"cara\",\n\t\t\"anemia\", \"corrupto\"]\n};\n\nconst vocabularies = { ru, sp, latin };\nconst reLorem = /^lorem([a-z]*)(\\d*)(-\\d*)?$/i;\nfunction lorem(node, ancestors, config) {\n    let m;\n    if (node.name && (m = node.name.match(reLorem))) {\n        const db = vocabularies[m[1]] || vocabularies.latin;\n        const minWordCount = m[2] ? Math.max(1, Number(m[2])) : 30;\n        const maxWordCount = m[3] ? Math.max(minWordCount, Number(m[3].slice(1))) : minWordCount;\n        const wordCount = rand(minWordCount, maxWordCount);\n        const repeat = node.repeat || findRepeater(ancestors);\n        node.name = node.attributes = void 0;\n        node.value = [paragraph(db, wordCount, !repeat || repeat.value === 0)];\n        if (node.repeat && ancestors.length > 1) {\n            resolveImplicitTag(node, ancestors, config);\n        }\n    }\n}\n/**\n * Returns random integer between <code>from</code> and <code>to</code> values\n */\nfunction rand(from, to) {\n    return Math.floor(Math.random() * (to - from) + from);\n}\nfunction sample(arr, count) {\n    const len = arr.length;\n    const iterations = Math.min(len, count);\n    const result = [];\n    while (result.length < iterations) {\n        const str = arr[rand(0, len)];\n        if (!result.includes(str)) {\n            result.push(str);\n        }\n    }\n    return result;\n}\nfunction choice(val) {\n    return val[rand(0, val.length - 1)];\n}\nfunction sentence(words, end) {\n    if (words.length) {\n        words = [capitalize(words[0])].concat(words.slice(1));\n    }\n    return words.join(' ') + (end || choice('?!...')); // more dots than question marks\n}\nfunction capitalize(word) {\n    return word[0].toUpperCase() + word.slice(1);\n}\n/**\n * Insert commas at randomly selected words. This function modifies values\n * inside `words` array\n */\nfunction insertCommas(words) {\n    if (words.length < 2) {\n        return words;\n    }\n    words = words.slice();\n    const len = words.length;\n    const hasComma = /,$/;\n    let totalCommas = 0;\n    if (len > 3 && len <= 6) {\n        totalCommas = rand(0, 1);\n    }\n    else if (len > 6 && len <= 12) {\n        totalCommas = rand(0, 2);\n    }\n    else {\n        totalCommas = rand(1, 4);\n    }\n    for (let i = 0, pos; i < totalCommas; i++) {\n        pos = rand(0, len - 2);\n        if (!hasComma.test(words[pos])) {\n            words[pos] += ',';\n        }\n    }\n    return words;\n}\n/**\n * Generate a paragraph of \"Lorem ipsum\" text\n * @param dict Words dictionary\n * @param wordCount Words count in paragraph\n * @param startWithCommon Should paragraph start with common \"lorem ipsum\" sentence.\n */\nfunction paragraph(dict, wordCount, startWithCommon) {\n    const result = [];\n    let totalWords = 0;\n    let words;\n    if (startWithCommon && dict.common) {\n        words = dict.common.slice(0, wordCount);\n        totalWords += words.length;\n        result.push(sentence(insertCommas(words), '.'));\n    }\n    while (totalWords < wordCount) {\n        words = sample(dict.words, Math.min(rand(2, 30), wordCount - totalWords));\n        totalWords += words.length;\n        result.push(sentence(insertCommas(words)));\n    }\n    return result.join(' ');\n}\nfunction findRepeater(ancestors) {\n    for (let i = ancestors.length - 1; i >= 0; i--) {\n        const element = ancestors[i];\n        if (element.type === 'AbbreviationNode' && element.repeat) {\n            return element.repeat;\n        }\n    }\n}\n\n/**\n * JSX transformer: replaces `class` and `for` attributes with `className` and\n * `htmlFor` attributes respectively\n */\nfunction jsx(node) {\n    if (node.attributes) {\n        node.attributes.forEach(rename);\n    }\n}\nfunction rename(attr) {\n    if (attr.name === 'class') {\n        attr.name = 'className';\n    }\n    else if (attr.name === 'for') {\n        attr.name = 'htmlFor';\n    }\n}\n\n/**\n * XSL transformer: removes `select` attributes from certain nodes that contain\n * children\n */\nfunction xsl(node) {\n    if (matchesName(node.name) && node.attributes && (node.children.length || node.value)) {\n        node.attributes = node.attributes.filter(isAllowed);\n    }\n}\nfunction isAllowed(attr) {\n    return attr.name !== 'select';\n}\nfunction matchesName(name) {\n    return name === 'xsl:variable' || name === 'xsl:with-param';\n}\n\nconst reElement = /^(-+)([a-z0-9]+[a-z0-9-]*)/i;\nconst reModifier = /^(_+)([a-z0-9]+[a-z0-9-_]*)/i;\nconst blockCandidates1 = (className) => /^[a-z]\\-/i.test(className);\nconst blockCandidates2 = (className) => /^[a-z]/i.test(className);\nfunction bem(node, ancestors, config) {\n    expandClassNames(node);\n    expandShortNotation(node, ancestors, config);\n}\n/**\n * Expands existing class names in BEM notation in given `node`.\n * For example, if node contains `b__el_mod` class name, this method ensures\n * that element contains `b__el` class as well\n */\nfunction expandClassNames(node) {\n    const data = getBEMData(node);\n    const classNames = [];\n    for (const cl of data.classNames) {\n        // remove all modifiers and element prefixes from class name to get a base element name\n        const ix = cl.indexOf('_');\n        if (ix > 0 && !cl.startsWith('-')) {\n            classNames.push(cl.slice(0, ix));\n            classNames.push(cl.slice(ix));\n        }\n        else {\n            classNames.push(cl);\n        }\n    }\n    if (classNames.length) {\n        data.classNames = classNames.filter(uniqueClass);\n        data.block = findBlockName(data.classNames);\n        updateClass(node, data.classNames.join(' '));\n    }\n}\n/**\n * Expands short BEM notation, e.g. `-element` and `_modifier`\n */\nfunction expandShortNotation(node, ancestors, config) {\n    const data = getBEMData(node);\n    const classNames = [];\n    const { options } = config;\n    const path = ancestors.slice(1).concat(node);\n    for (let cl of data.classNames) {\n        let prefix = '';\n        let m;\n        const originalClass = cl;\n        // parse element definition (could be only one)\n        if (m = cl.match(reElement)) {\n            prefix = getBlockName(path, m[1].length, config.context) + options['bem.element'] + m[2];\n            classNames.push(prefix);\n            cl = cl.slice(m[0].length);\n        }\n        // parse modifiers definitions\n        if (m = cl.match(reModifier)) {\n            if (!prefix) {\n                prefix = getBlockName(path, m[1].length);\n                classNames.push(prefix);\n            }\n            classNames.push(`${prefix}${options['bem.modifier']}${m[2]}`);\n            cl = cl.slice(m[0].length);\n        }\n        if (cl === originalClass) {\n            // class name wasn’t modified: it’s not a BEM-specific class,\n            // add it as-is into output\n            classNames.push(originalClass);\n        }\n    }\n    const arrClassNames = classNames.filter(uniqueClass);\n    if (arrClassNames.length) {\n        updateClass(node, arrClassNames.join(' '));\n    }\n}\n/**\n * Returns BEM data from given abbreviation node\n */\nfunction getBEMData(node) {\n    if (!node._bem) {\n        let classValue = '';\n        if (node.attributes) {\n            for (const attr of node.attributes) {\n                if (attr.name === 'class' && attr.value) {\n                    classValue = stringifyValue(attr.value);\n                    break;\n                }\n            }\n        }\n        node._bem = parseBEM(classValue);\n    }\n    return node._bem;\n}\nfunction getBEMDataFromContext(context) {\n    if (!context._bem) {\n        context._bem = parseBEM(context.attributes && context.attributes.class || '');\n    }\n    return context._bem;\n}\n/**\n * Parses BEM data from given class name\n */\nfunction parseBEM(classValue) {\n    const classNames = classValue ? classValue.split(/\\s+/) : [];\n    return {\n        classNames,\n        block: findBlockName(classNames)\n    };\n}\n/**\n * Returns block name for given `node` by `prefix`, which tells the depth of\n * of parent node lookup\n */\nfunction getBlockName(ancestors, depth = 0, context) {\n    const maxParentIx = 0;\n    let parentIx = Math.max(ancestors.length - depth, maxParentIx);\n    do {\n        const parent = ancestors[parentIx];\n        if (parent) {\n            const data = getBEMData(parent);\n            if (data.block) {\n                return data.block;\n            }\n        }\n    } while (maxParentIx < parentIx--);\n    if (context) {\n        const data = getBEMDataFromContext(context);\n        if (data.block) {\n            return data.block;\n        }\n    }\n    return '';\n}\nfunction findBlockName(classNames) {\n    return find(classNames, blockCandidates1)\n        || find(classNames, blockCandidates2)\n        || void 0;\n}\n/**\n * Finds class name from given list which may be used as block name\n */\nfunction find(classNames, filter) {\n    for (const cl of classNames) {\n        if (reElement.test(cl) || reModifier.test(cl)) {\n            break;\n        }\n        if (filter(cl)) {\n            return cl;\n        }\n    }\n}\nfunction updateClass(node, value) {\n    for (const attr of node.attributes) {\n        if (attr.name === 'class') {\n            attr.value = [value];\n            break;\n        }\n    }\n}\nfunction stringifyValue(value) {\n    let result = '';\n    for (const t of value) {\n        result += typeof t === 'string' ? t : t.name;\n    }\n    return result;\n}\nfunction uniqueClass(item, ix, arr) {\n    return !!item && arr.indexOf(item) === ix;\n}\n\nfunction walk$1(abbr, visitor, state) {\n    const callback = (ctx, index, items) => {\n        const { parent, current } = state;\n        state.parent = current;\n        state.current = ctx;\n        visitor(ctx, index, items, state, next);\n        state.current = current;\n        state.parent = parent;\n    };\n    const next = (node, index, items) => {\n        state.ancestors.push(state.current);\n        callback(node, index, items);\n        state.ancestors.pop();\n    };\n    abbr.children.forEach(callback);\n}\nfunction createWalkState(config) {\n    return {\n        // @ts-ignore: Will set value in iterator\n        current: null,\n        parent: void 0,\n        ancestors: [],\n        config,\n        field: 1,\n        out: createOutputStream(config.options)\n    };\n}\n\nconst caret = [{ type: 'Field', index: 0, name: '' }];\n/**\n * Check if given node is a snippet: a node without name and attributes\n */\nfunction isSnippet(node) {\n    return node ? !node.name && !node.attributes : false;\n}\n/**\n * Check if given node is inline-level element, e.g. element with explicitly\n * defined node name\n */\nfunction isInlineElement(node, config) {\n    return node ? isInline(node, config) : false;\n}\n/**\n * Check if given value token is a field\n */\nfunction isField(token) {\n    return typeof token === 'object' && token.type === 'Field';\n}\nfunction pushTokens(tokens, state) {\n    const { out } = state;\n    let largestIndex = -1;\n    for (const t of tokens) {\n        if (typeof t === 'string') {\n            pushString(out, t);\n        }\n        else {\n            pushField(out, state.field + t.index, t.name);\n            if (t.index > largestIndex) {\n                largestIndex = t.index;\n            }\n        }\n    }\n    if (largestIndex !== -1) {\n        state.field += largestIndex + 1;\n    }\n}\n/**\n * Splits given value token by lines: returns array where each entry is a token list\n * for a single line\n */\nfunction splitByLines$1(tokens) {\n    const result = [];\n    let line = [];\n    for (const t of tokens) {\n        if (typeof t === 'string') {\n            const lines = t.split(/\\r\\n?|\\n/g);\n            line.push(lines.shift() || '');\n            while (lines.length) {\n                result.push(line);\n                line = [lines.shift() || ''];\n            }\n        }\n        else {\n            line.push(t);\n        }\n    }\n    line.length && result.push(line);\n    return result;\n}\n/**\n * Check if given attribute should be outputted\n */\nfunction shouldOutputAttribute(attr) {\n    // In case if attribute is implied, check if it has a defined value:\n    // either non-empty value or quoted empty value\n    return !attr.implied || attr.valueType !== 'raw' || (!!attr.value && attr.value.length > 0);\n}\n\n/**\n * Splits given string into template tokens.\n * Template is a string which contains placeholders which are uppercase names\n * between `[` and `]`, for example: `[PLACEHOLDER]`.\n * Unlike other templates, a placeholder may contain extra characters before and\n * after name: `[%PLACEHOLDER.]`. If data for `PLACEHOLDER` is defined, it will\n * be outputted with with these extra character, otherwise will be completely omitted.\n */\nfunction template(text) {\n    const tokens = [];\n    const scanner = { pos: 0, text };\n    let placeholder;\n    let offset = scanner.pos;\n    let pos = scanner.pos;\n    while (scanner.pos < scanner.text.length) {\n        pos = scanner.pos;\n        if (placeholder = consumePlaceholder(scanner)) {\n            if (offset !== scanner.pos) {\n                tokens.push(text.slice(offset, pos));\n            }\n            tokens.push(placeholder);\n            offset = scanner.pos;\n        }\n        else {\n            scanner.pos++;\n        }\n    }\n    if (offset !== scanner.pos) {\n        tokens.push(text.slice(offset));\n    }\n    return tokens;\n}\n/**\n * Consumes placeholder like `[#ID]` from given scanner\n */\nfunction consumePlaceholder(scanner) {\n    if (peek(scanner) === 91 /* Start */) {\n        const start = ++scanner.pos;\n        let namePos = start;\n        let afterPos = start;\n        let stack = 1;\n        while (scanner.pos < scanner.text.length) {\n            const code = peek(scanner);\n            if (isTokenStart(code)) {\n                namePos = scanner.pos;\n                while (isToken(peek(scanner))) {\n                    scanner.pos++;\n                }\n                afterPos = scanner.pos;\n            }\n            else {\n                if (code === 91 /* Start */) {\n                    stack++;\n                }\n                else if (code === 93 /* End */) {\n                    if (--stack === 0) {\n                        return {\n                            before: scanner.text.slice(start, namePos),\n                            after: scanner.text.slice(afterPos, scanner.pos++),\n                            name: scanner.text.slice(namePos, afterPos)\n                        };\n                    }\n                }\n                scanner.pos++;\n            }\n        }\n    }\n}\nfunction peek(scanner, pos = scanner.pos) {\n    return scanner.text.charCodeAt(pos);\n}\nfunction isTokenStart(code) {\n    return code >= 65 && code <= 90; // A-Z\n}\nfunction isToken(code) {\n    return isTokenStart(code)\n        || (code > 47 && code < 58) /* 0-9 */\n        || code === 95 /* Underscore */\n        || code === 45 /* Dash */;\n}\n\nfunction createCommentState(config) {\n    const { options } = config;\n    return {\n        enabled: options['comment.enabled'],\n        trigger: options['comment.trigger'],\n        before: options['comment.before'] ? template(options['comment.before']) : void 0,\n        after: options['comment.after'] ? template(options['comment.after']) : void 0\n    };\n}\n/**\n * Adds comment prefix for given node, if required\n */\nfunction commentNodeBefore(node, state) {\n    if (shouldComment(node, state) && state.comment.before) {\n        output(node, state.comment.before, state);\n    }\n}\n/**\n * Adds comment suffix for given node, if required\n */\nfunction commentNodeAfter(node, state) {\n    if (shouldComment(node, state) && state.comment.after) {\n        output(node, state.comment.after, state);\n    }\n}\n/**\n * Check if given node should be commented\n */\nfunction shouldComment(node, state) {\n    const { comment } = state;\n    if (!comment.enabled || !comment.trigger || !node.name || !node.attributes) {\n        return false;\n    }\n    for (const attr of node.attributes) {\n        if (attr.name && comment.trigger.includes(attr.name)) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Pushes given template tokens into output stream\n */\nfunction output(node, tokens, state) {\n    const attrs = {};\n    const { out } = state;\n    // Collect attributes payload\n    for (const attr of node.attributes) {\n        if (attr.name && attr.value) {\n            attrs[attr.name.toUpperCase()] = attr.value;\n        }\n    }\n    // Output parsed tokens\n    for (const token of tokens) {\n        if (typeof token === 'string') {\n            pushString(out, token);\n        }\n        else if (attrs[token.name]) {\n            pushString(out, token.before);\n            pushTokens(attrs[token.name], state);\n            pushString(out, token.after);\n        }\n    }\n}\n\nconst htmlTagRegex = /^<([\\w\\-:]+)[\\s>]/;\nfunction html(abbr, config) {\n    const state = createWalkState(config);\n    state.comment = createCommentState(config);\n    walk$1(abbr, element, state);\n    return state.out.value;\n}\n/**\n * Outputs `node` content to output stream of `state`\n * @param node Context node\n * @param index Index of `node` in `items`\n * @param items List of `node`’s siblings\n * @param state Current walk state\n */\nfunction element(node, index, items, state, next) {\n    const { out, config } = state;\n    const format = shouldFormat(node, index, items, state);\n    // Pick offset level for current node\n    const level = getIndent(state);\n    out.level += level;\n    format && pushNewline(out, true);\n    if (node.name) {\n        const name = tagName(node.name, config);\n        commentNodeBefore(node, state);\n        pushString(out, `<${name}`);\n        if (node.attributes) {\n            for (const attr of node.attributes) {\n                if (shouldOutputAttribute(attr)) {\n                    pushAttribute(attr, state);\n                }\n            }\n        }\n        if (node.selfClosing && !node.children.length && !node.value) {\n            pushString(out, `${selfClose(config)}>`);\n        }\n        else {\n            pushString(out, '>');\n            if (!pushSnippet(node, state, next)) {\n                if (node.value) {\n                    const innerFormat = node.value.some(hasNewline) || startsWithBlockTag(node.value, config);\n                    innerFormat && pushNewline(state.out, ++out.level);\n                    pushTokens(node.value, state);\n                    innerFormat && pushNewline(state.out, --out.level);\n                }\n                node.children.forEach(next);\n                if (!node.value && !node.children.length) {\n                    const innerFormat = config.options['output.formatLeafNode']\n                        || config.options['output.formatForce'].includes(node.name);\n                    innerFormat && pushNewline(state.out, ++out.level);\n                    pushTokens(caret, state);\n                    innerFormat && pushNewline(state.out, --out.level);\n                }\n            }\n            pushString(out, `</${name}>`);\n            commentNodeAfter(node, state);\n        }\n    }\n    else if (!pushSnippet(node, state, next) && node.value) {\n        // A text-only node (snippet)\n        pushTokens(node.value, state);\n        node.children.forEach(next);\n    }\n    if (format && index === items.length - 1 && state.parent) {\n        const offset = isSnippet(state.parent) ? 0 : 1;\n        pushNewline(out, out.level - offset);\n    }\n    out.level -= level;\n}\n/**\n * Outputs given attribute’s content into output stream\n */\nfunction pushAttribute(attr, state) {\n    const { out, config } = state;\n    if (attr.name) {\n        const name = attrName(attr.name, config);\n        const lQuote = attrQuote(attr, config, true);\n        const rQuote = attrQuote(attr, config);\n        let value = attr.value;\n        if (isBooleanAttribute(attr, config) && !value) {\n            // If attribute value is omitted and it’s a boolean value, check for\n            // `compactBoolean` option: if it’s disabled, set value to attribute name\n            // (XML style)\n            if (!config.options['output.compactBoolean']) {\n                value = [name];\n            }\n        }\n        else if (!value) {\n            value = caret;\n        }\n        pushString(out, ' ' + name);\n        if (value) {\n            pushString(out, '=' + lQuote);\n            pushTokens(value, state);\n            pushString(out, rQuote);\n        }\n        else if (config.options['output.selfClosingStyle'] !== 'html') {\n            pushString(out, '=' + lQuote + rQuote);\n        }\n    }\n}\nfunction pushSnippet(node, state, next) {\n    if (node.value && node.children.length) {\n        // We have a value and child nodes. In case if value contains fields,\n        // we should output children as a content of first field\n        const fieldIx = node.value.findIndex(isField);\n        if (fieldIx !== -1) {\n            pushTokens(node.value.slice(0, fieldIx), state);\n            const line = state.out.line;\n            let pos = fieldIx + 1;\n            node.children.forEach(next);\n            // If there was a line change, trim leading whitespace for better result\n            if (state.out.line !== line && typeof node.value[pos] === 'string') {\n                pushString(state.out, node.value[pos++].trimLeft());\n            }\n            pushTokens(node.value.slice(pos), state);\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Check if given node should be formatted in its parent context\n */\nfunction shouldFormat(node, index, items, state) {\n    const { config, parent } = state;\n    if (!config.options['output.format']) {\n        return false;\n    }\n    if (index === 0 && !parent) {\n        // Do not format very first node\n        return false;\n    }\n    // Do not format single child of snippet\n    if (parent && isSnippet(parent) && items.length === 1) {\n        return false;\n    }\n    /**\n     * Adjacent text-only/snippet nodes\n     */\n    if (isSnippet(node)) {\n        // Adjacent text-only/snippet nodes\n        const format = isSnippet(items[index - 1]) || isSnippet(items[index + 1])\n            // Has newlines: looks like wrapping code fragment\n            || node.value.some(hasNewline)\n            // Format as wrapper: contains children which will be outputted as field content\n            || (node.value.some(isField) && node.children.length);\n        if (format) {\n            return true;\n        }\n    }\n    if (isInline(node, config)) {\n        // Check if inline node is the next sibling of block-level node\n        if (index === 0) {\n            // First node in parent: format if it’s followed by a block-level element\n            for (let i = 0; i < items.length; i++) {\n                if (!isInline(items[i], config)) {\n                    return true;\n                }\n            }\n        }\n        else if (!isInline(items[index - 1], config)) {\n            // Node is right after block-level element\n            return true;\n        }\n        if (config.options['output.inlineBreak']) {\n            // check for adjacent inline elements before and after current element\n            let adjacentInline = 1;\n            let before = index;\n            let after = index;\n            while (isInlineElement(items[--before], config)) {\n                adjacentInline++;\n            }\n            while (isInlineElement(items[++after], config)) {\n                adjacentInline++;\n            }\n            if (adjacentInline >= config.options['output.inlineBreak']) {\n                return true;\n            }\n        }\n        // Edge case: inline node contains node that should receive formatting\n        for (let i = 0, il = node.children.length; i < il; i++) {\n            if (shouldFormat(node.children[i], i, node.children, state)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    return true;\n}\n/**\n * Returns indentation offset for given node\n */\nfunction getIndent(state) {\n    const { config, parent } = state;\n    if (!parent || isSnippet(parent) || (parent.name && config.options['output.formatSkip'].includes(parent.name))) {\n        return 0;\n    }\n    return 1;\n}\n/**\n * Check if given node value contains newlines\n */\nfunction hasNewline(value) {\n    return typeof value === 'string' && /\\r|\\n/.test(value);\n}\n/**\n * Check if given node value starts with block-level tag\n */\nfunction startsWithBlockTag(value, config) {\n    if (value.length && typeof value[0] === 'string') {\n        const matches = htmlTagRegex.exec(value[0]);\n        if ((matches === null || matches === void 0 ? void 0 : matches.length) && !config.options['inlineElements'].includes(matches[1].toLowerCase())) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction indentFormat(abbr, config, options) {\n    const state = createWalkState(config);\n    state.options = options || {};\n    walk$1(abbr, element$1, state);\n    return state.out.value;\n}\n/**\n * Outputs `node` content to output stream of `state`\n * @param node Context node\n * @param index Index of `node` in `items`\n * @param items List of `node`’s siblings\n * @param state Current walk state\n */\nfunction element$1(node, index, items, state, next) {\n    const { out, options } = state;\n    const { primary, secondary } = collectAttributes(node);\n    // Pick offset level for current node\n    const level = state.parent ? 1 : 0;\n    out.level += level;\n    // Do not indent top-level elements\n    if (shouldFormat$1(node, index, items, state)) {\n        pushNewline(out, true);\n    }\n    if (node.name && (node.name !== 'div' || !primary.length)) {\n        pushString(out, (options.beforeName || '') + node.name + (options.afterName || ''));\n    }\n    pushPrimaryAttributes(primary, state);\n    pushSecondaryAttributes(secondary.filter(shouldOutputAttribute), state);\n    if (node.selfClosing && !node.value && !node.children.length) {\n        if (state.options.selfClose) {\n            pushString(out, state.options.selfClose);\n        }\n    }\n    else {\n        pushValue(node, state);\n        node.children.forEach(next);\n    }\n    out.level -= level;\n}\n/**\n * From given node, collects all attributes as `primary` (id, class) and\n * `secondary` (all the rest) lists. In most indent-based syntaxes, primary attribute\n * has special syntax\n */\nfunction collectAttributes(node) {\n    const primary = [];\n    const secondary = [];\n    if (node.attributes) {\n        for (const attr of node.attributes) {\n            if (isPrimaryAttribute(attr)) {\n                primary.push(attr);\n            }\n            else {\n                secondary.push(attr);\n            }\n        }\n    }\n    return { primary, secondary };\n}\n/**\n * Outputs given attributes as primary into output stream\n */\nfunction pushPrimaryAttributes(attrs, state) {\n    for (const attr of attrs) {\n        if (attr.value) {\n            if (attr.name === 'class') {\n                pushString(state.out, '.');\n                // All whitespace characters must be replaced with dots in class names\n                const tokens = attr.value.map(t => typeof t === 'string' ? t.replace(/\\s+/g, '.') : t);\n                pushTokens(tokens, state);\n            }\n            else {\n                // ID attribute\n                pushString(state.out, '#');\n                pushTokens(attr.value, state);\n            }\n        }\n    }\n}\n/**\n * Outputs given attributes as secondary into output stream\n */\nfunction pushSecondaryAttributes(attrs, state) {\n    if (attrs.length) {\n        const { out, config, options } = state;\n        options.beforeAttribute && pushString(out, options.beforeAttribute);\n        for (let i = 0; i < attrs.length; i++) {\n            const attr = attrs[i];\n            pushString(out, attrName(attr.name || '', config));\n            if (isBooleanAttribute(attr, config) && !attr.value) {\n                if (!config.options['output.compactBoolean'] && options.booleanValue) {\n                    pushString(out, '=' + options.booleanValue);\n                }\n            }\n            else {\n                pushString(out, '=' + attrQuote(attr, config, true));\n                pushTokens(attr.value || caret, state);\n                pushString(out, attrQuote(attr, config));\n            }\n            if (i !== attrs.length - 1 && options.glueAttribute) {\n                pushString(out, options.glueAttribute);\n            }\n        }\n        options.afterAttribute && pushString(out, options.afterAttribute);\n    }\n}\n/**\n * Outputs given node value into state output stream\n */\nfunction pushValue(node, state) {\n    // We should either output value or add caret but for leaf nodes only (no children)\n    if (!node.value && node.children.length) {\n        return;\n    }\n    const value = node.value || caret;\n    const lines = splitByLines$1(value);\n    const { out, options } = state;\n    if (lines.length === 1) {\n        if (node.name || node.attributes) {\n            push(out, ' ');\n        }\n        pushTokens(value, state);\n    }\n    else {\n        // We should format multi-line value with terminating `|` character\n        // and same line length\n        const lineLengths = [];\n        let maxLength = 0;\n        // Calculate lengths of all lines and max line length\n        for (const line of lines) {\n            const len = valueLength(line);\n            lineLengths.push(len);\n            if (len > maxLength) {\n                maxLength = len;\n            }\n        }\n        // Output each line, padded to max length\n        out.level++;\n        for (let i = 0; i < lines.length; i++) {\n            pushNewline(out, true);\n            options.beforeTextLine && push(out, options.beforeTextLine);\n            pushTokens(lines[i], state);\n            if (options.afterTextLine) {\n                push(out, ' '.repeat(maxLength - lineLengths[i]));\n                push(out, options.afterTextLine);\n            }\n        }\n        out.level--;\n    }\n}\nfunction isPrimaryAttribute(attr) {\n    return attr.name === 'class' || attr.name === 'id';\n}\n/**\n * Calculates string length from given tokens\n */\nfunction valueLength(tokens) {\n    let len = 0;\n    for (const token of tokens) {\n        len += typeof token === 'string' ? token.length : token.name.length;\n    }\n    return len;\n}\nfunction shouldFormat$1(node, index, items, state) {\n    // Do not format first top-level element or snippets\n    if (!state.parent && index === 0) {\n        return false;\n    }\n    return !isSnippet(node);\n}\n\nfunction haml(abbr, config) {\n    return indentFormat(abbr, config, {\n        beforeName: '%',\n        beforeAttribute: '(',\n        afterAttribute: ')',\n        glueAttribute: ' ',\n        afterTextLine: ' |',\n        booleanValue: 'true',\n        selfClose: '/'\n    });\n}\n\nfunction slim(abbr, config) {\n    return indentFormat(abbr, config, {\n        beforeAttribute: ' ',\n        glueAttribute: ' ',\n        beforeTextLine: '| ',\n        selfClose: '/'\n    });\n}\n\nfunction pug(abbr, config) {\n    return indentFormat(abbr, config, {\n        beforeAttribute: '(',\n        afterAttribute: ')',\n        glueAttribute: ', ',\n        beforeTextLine: '| ',\n        selfClose: config.options['output.selfClosingStyle'] === 'xml' ? '/' : ''\n    });\n}\n\nconst formatters = { html, haml, slim, pug };\n/**\n * Parses given Emmet abbreviation into a final abbreviation tree with all\n * required transformations applied\n */\nfunction parse(abbr, config) {\n    let oldTextValue;\n    if (typeof abbr === 'string') {\n        let parseOpt = config;\n        if (config.options['jsx.enabled']) {\n            parseOpt = Object.assign(Object.assign({}, parseOpt), { jsx: true });\n        }\n        if (config.options['markup.href']) {\n            parseOpt = Object.assign(Object.assign({}, parseOpt), { href: true });\n        }\n        abbr = parse$2(abbr, parseOpt);\n        // remove text field before snippets(abbr, config) call\n        // as abbreviation(abbr, parseOpt) already handled it\n        oldTextValue = config.text;\n        config.text = undefined;\n    }\n    // Run abbreviation resolve in two passes:\n    // 1. Map each node to snippets, which are abbreviations as well. A single snippet\n    // may produce multiple nodes\n    // 2. Transform every resolved node\n    abbr = resolveSnippets(abbr, config);\n    walk(abbr, transform, config);\n    config.text = oldTextValue !== null && oldTextValue !== void 0 ? oldTextValue : config.text;\n    return abbr;\n}\n/**\n * Converts given abbreviation to string according to provided `config`\n */\nfunction stringify(abbr, config) {\n    const formatter = formatters[config.syntax] || html;\n    return formatter(abbr, config);\n}\n/**\n * Modifies given node and prepares it for output\n */\nfunction transform(node, ancestors, config) {\n    implicitTag(node, ancestors, config);\n    mergeAttributes(node, config);\n    lorem(node, ancestors, config);\n    if (config.syntax === 'xsl') {\n        xsl(node);\n    }\n    if (config.options['jsx.enabled']) {\n        jsx(node);\n    }\n    if (config.options['bem.enabled']) {\n        bem(node, ancestors, config);\n    }\n}\n\nconst reProperty = /^([a-z-]+)(?:\\s*:\\s*([^\\n\\r;]+?);*)?$/;\nconst opt = { value: true };\n/**\n * Creates structure for holding resolved CSS snippet\n */\nfunction createSnippet(key, value) {\n    // A snippet could be a raw text snippet (e.g. arbitrary text string) or a\n    // CSS property with possible values separated by `|`.\n    // In latter case, we have to parse snippet as CSS abbreviation\n    const m = value.match(reProperty);\n    if (m) {\n        const keywords = {};\n        const parsed = m[2] ? m[2].split('|').map(parseValue) : [];\n        for (const item of parsed) {\n            for (const cssVal of item) {\n                collectKeywords(cssVal, keywords);\n            }\n        }\n        return {\n            type: \"Property\" /* Property */,\n            key,\n            property: m[1],\n            value: parsed,\n            keywords,\n            dependencies: []\n        };\n    }\n    return { type: \"Raw\" /* Raw */, key, value };\n}\n/**\n * Nests more specific CSS properties into shorthand ones, e.g.\n * `background-position-x` -> `background-position` -> `background`\n */\nfunction nest(snippets) {\n    snippets = snippets.slice().sort(snippetsSort);\n    const stack = [];\n    let prev;\n    // For sorted list of CSS properties, create dependency graph where each\n    // shorthand property contains its more specific one, e.g.\n    // background -> background-position -> background-position-x\n    for (const cur of snippets.filter(isProperty)) {\n        // Check if current property belongs to one from parent stack.\n        // Since `snippets` array is sorted, items are perfectly aligned\n        // from shorthands to more specific variants\n        while (stack.length) {\n            prev = stack[stack.length - 1];\n            if (cur.property.startsWith(prev.property)\n                && cur.property.charCodeAt(prev.property.length) === 45 /* - */) {\n                prev.dependencies.push(cur);\n                stack.push(cur);\n                break;\n            }\n            stack.pop();\n        }\n        if (!stack.length) {\n            stack.push(cur);\n        }\n    }\n    return snippets;\n}\n/**\n * A sorting function for array of snippets\n */\nfunction snippetsSort(a, b) {\n    if (a.key === b.key) {\n        return 0;\n    }\n    return a.key < b.key ? -1 : 1;\n}\nfunction parseValue(value) {\n    return parse$3(value.trim(), opt)[0].value;\n}\nfunction isProperty(snippet) {\n    return snippet.type === \"Property\" /* Property */;\n}\nfunction collectKeywords(cssVal, dest) {\n    for (const v of cssVal.value) {\n        if (v.type === 'Literal') {\n            dest[v.value] = v;\n        }\n        else if (v.type === 'FunctionCall') {\n            dest[v.name] = v;\n        }\n        else if (v.type === 'Field') {\n            // Create literal from field, if available\n            const value = v.name.trim();\n            if (value) {\n                dest[value] = { type: 'Literal', value };\n            }\n        }\n    }\n}\n\n/**\n * Calculates how close `str1` matches `str2` using fuzzy match.\n * How matching works:\n * – first characters of both `str1` and `str2` *must* match\n * – `str1` length larger than `str2` length is allowed only when `unmatched` is true\n * – ideal match is when `str1` equals to `str2` (score: 1)\n * – next best match is `str2` starts with `str1` (score: 1 × percent of matched characters)\n * – other scores depend on how close characters of `str1` to the beginning of `str2`\n * @param partialMatch Allow length `str1` to be greater than `str2` length\n */\nfunction scoreMatch(str1, str2, partialMatch = false) {\n    str1 = str1.toLowerCase();\n    str2 = str2.toLowerCase();\n    if (str1 === str2) {\n        return 1;\n    }\n    // Both strings MUST start with the same character\n    if (!str1 || !str2 || str1.charCodeAt(0) !== str2.charCodeAt(0)) {\n        return 0;\n    }\n    const str1Len = str1.length;\n    const str2Len = str2.length;\n    if (!partialMatch && str1Len > str2Len) {\n        return 0;\n    }\n    // Characters from `str1` which are closer to the beginning of a `str2` should\n    // have higher score.\n    // For example, if `str2` is `abcde`, it’s max score is:\n    // 5 + 4 + 3 + 2 + 1 = 15 (sum of character positions in reverse order)\n    // Matching `abd` against `abcde` should produce:\n    // 5 + 4 + 2 = 11\n    // Acronym bonus for match right after `-`. Matching `abd` against `abc-de`\n    // should produce:\n    // 6 + 5 + 4 (use `d` position in `abd`, not in abc-de`)\n    const minLength = Math.min(str1Len, str2Len);\n    const maxLength = Math.max(str1Len, str2Len);\n    let i = 1;\n    let j = 1;\n    let score = maxLength;\n    let ch1 = 0;\n    let ch2 = 0;\n    let found = false;\n    let acronym = false;\n    while (i < str1Len) {\n        ch1 = str1.charCodeAt(i);\n        found = false;\n        acronym = false;\n        while (j < str2Len) {\n            ch2 = str2.charCodeAt(j);\n            if (ch1 === ch2) {\n                found = true;\n                score += maxLength - (acronym ? i : j);\n                break;\n            }\n            // add acronym bonus for exactly next match after unmatched `-`\n            acronym = ch2 === 45 /* - */;\n            j++;\n        }\n        if (!found) {\n            if (!partialMatch) {\n                return 0;\n            }\n            break;\n        }\n        i++;\n    }\n    const matchRatio = i / maxLength;\n    const delta = maxLength - minLength;\n    const maxScore = sum(maxLength) - sum(delta);\n    return (score * matchRatio) / maxScore;\n}\n/**\n * Calculates sum of first `n` numbers, e.g. 1+2+3+...n\n */\nfunction sum(n) {\n    return n * (n + 1) / 2;\n}\n\nfunction color(token, shortHex) {\n    if (!token.r && !token.g && !token.b && !token.a) {\n        return 'transparent';\n    }\n    else if (token.a === 1) {\n        return asHex(token, shortHex);\n    }\n    return asRGB(token);\n}\n/**\n * Output given color as hex value\n * @param short Produce short value (e.g. #fff instead of #ffffff), if possible\n */\nfunction asHex(token, short) {\n    const fn = (short && isShortHex(token.r) && isShortHex(token.g) && isShortHex(token.b))\n        ? toShortHex : toHex;\n    return '#' + fn(token.r) + fn(token.g) + fn(token.b);\n}\n/**\n * Output current color as `rgba?(...)` CSS color\n */\nfunction asRGB(token) {\n    const values = [token.r, token.g, token.b];\n    if (token.a !== 1) {\n        values.push(frac(token.a, 8));\n    }\n    return `${values.length === 3 ? 'rgb' : 'rgba'}(${values.join(', ')})`;\n}\nfunction frac(num, digits = 4) {\n    return num.toFixed(digits).replace(/\\.?0+$/, '');\n}\nfunction isShortHex(hex) {\n    return !(hex % 17);\n}\nfunction toShortHex(num) {\n    return (num >> 4).toString(16);\n}\nfunction toHex(num) {\n    return pad(num.toString(16), 2);\n}\nfunction pad(value, len) {\n    while (value.length < len) {\n        value = '0' + value;\n    }\n    return value;\n}\n\nfunction css(abbr, config) {\n    var _a;\n    const out = createOutputStream(config.options);\n    const format = config.options['output.format'];\n    if (((_a = config.context) === null || _a === void 0 ? void 0 : _a.name) === \"@@section\" /* Section */) {\n        // For section context, filter out unmatched snippets\n        abbr = abbr.filter(node => node.snippet);\n    }\n    for (let i = 0; i < abbr.length; i++) {\n        if (format && i !== 0) {\n            pushNewline(out, true);\n        }\n        property(abbr[i], out, config);\n    }\n    return out.value;\n}\n/**\n * Outputs given abbreviation node into output stream\n */\nfunction property(node, out, config) {\n    const isJSON = config.options['stylesheet.json'];\n    if (node.name) {\n        // It’s a CSS property\n        const name = isJSON ? toCamelCase(node.name) : node.name;\n        pushString(out, name + config.options['stylesheet.between']);\n        if (node.value.length) {\n            propertyValue(node, out, config);\n        }\n        else {\n            pushField(out, 0, '');\n        }\n        if (isJSON) {\n            // For CSS-in-JS, always finalize property with comma\n            // NB: seems like `important` is not available in CSS-in-JS syntaxes\n            push(out, ',');\n        }\n        else {\n            outputImportant(node, out, true);\n            push(out, config.options['stylesheet.after']);\n        }\n    }\n    else {\n        // It’s a regular snippet, output plain tokens without any additional formatting\n        for (const cssVal of node.value) {\n            for (const v of cssVal.value) {\n                outputToken(v, out, config);\n            }\n        }\n        outputImportant(node, out, node.value.length > 0);\n    }\n}\nfunction propertyValue(node, out, config) {\n    const isJSON = config.options['stylesheet.json'];\n    const num = isJSON ? getSingleNumeric(node) : null;\n    if (num && (!num.unit || num.unit === 'px')) {\n        // For CSS-in-JS, if property contains single numeric value, output it\n        // as JS number\n        push(out, String(num.value));\n    }\n    else {\n        const quote = getQuote(config);\n        isJSON && push(out, quote);\n        for (let i = 0; i < node.value.length; i++) {\n            if (i !== 0) {\n                push(out, ', ');\n            }\n            outputValue(node.value[i], out, config);\n        }\n        isJSON && push(out, quote);\n    }\n}\nfunction outputImportant(node, out, separator) {\n    if (node.important) {\n        if (separator) {\n            push(out, ' ');\n        }\n        push(out, '!important');\n    }\n}\nfunction outputValue(value, out, config) {\n    for (let i = 0, prevEnd = -1; i < value.value.length; i++) {\n        const token = value.value[i];\n        // Handle edge case: a field is written close to previous token like this: `foo${bar}`.\n        // We should not add delimiter here\n        if (i !== 0 && (token.type !== 'Field' || token.start !== prevEnd)) {\n            push(out, ' ');\n        }\n        outputToken(token, out, config);\n        prevEnd = token['end'];\n    }\n}\nfunction outputToken(token, out, config) {\n    if (token.type === 'ColorValue') {\n        push(out, color(token, config.options['stylesheet.shortHex']));\n    }\n    else if (token.type === 'Literal') {\n        pushString(out, token.value);\n    }\n    else if (token.type === 'NumberValue') {\n        pushString(out, frac(token.value, 4) + token.unit);\n    }\n    else if (token.type === 'StringValue') {\n        const quote = token.quote === 'double' ? '\"' : '\\'';\n        pushString(out, quote + token.value + quote);\n    }\n    else if (token.type === 'Field') {\n        pushField(out, token.index, token.name);\n    }\n    else if (token.type === 'FunctionCall') {\n        push(out, token.name + '(');\n        for (let i = 0; i < token.arguments.length; i++) {\n            if (i) {\n                push(out, ', ');\n            }\n            outputValue(token.arguments[i], out, config);\n        }\n        push(out, ')');\n    }\n}\n/**\n * If value of given property is a single numeric value, returns this token\n */\nfunction getSingleNumeric(node) {\n    if (node.value.length === 1) {\n        const cssVal = node.value[0];\n        if (cssVal.value.length === 1 && cssVal.value[0].type === 'NumberValue') {\n            return cssVal.value[0];\n        }\n    }\n}\n/**\n * Converts kebab-case string to camelCase\n */\nfunction toCamelCase(str) {\n    return str.replace(/\\-(\\w)/g, (_, letter) => letter.toUpperCase());\n}\nfunction getQuote(config) {\n    return config.options['stylesheet.jsonDoubleQuotes'] ? '\"' : '\\'';\n}\n\nconst gradientName = 'lg';\n/**\n * Parses given Emmet abbreviation into a final abbreviation tree with all\n * required transformations applied\n */\nfunction parse$1(abbr, config) {\n    var _a;\n    const snippets = ((_a = config.cache) === null || _a === void 0 ? void 0 : _a.stylesheetSnippets) || convertSnippets(config.snippets);\n    if (config.cache) {\n        config.cache.stylesheetSnippets = snippets;\n    }\n    if (typeof abbr === 'string') {\n        abbr = parse$3(abbr, { value: isValueScope(config) });\n    }\n    const filteredSnippets = getSnippetsForScope(snippets, config);\n    for (const node of abbr) {\n        resolveNode(node, filteredSnippets, config);\n    }\n    return abbr;\n}\n/**\n * Converts given raw snippets into internal snippets representation\n */\nfunction convertSnippets(snippets) {\n    const result = [];\n    for (const key of Object.keys(snippets)) {\n        result.push(createSnippet(key, snippets[key]));\n    }\n    return nest(result);\n}\n/**\n * Resolves given node: finds matched CSS snippets using fuzzy match and resolves\n * keyword aliases from node value\n */\nfunction resolveNode(node, snippets, config) {\n    if (!resolveGradient(node, config)) {\n        const score = config.options['stylesheet.fuzzySearchMinScore'];\n        if (isValueScope(config)) {\n            // Resolve as value of given CSS property\n            const propName = config.context.name;\n            const snippet = snippets.find(s => s.type === \"Property\" /* Property */ && s.property === propName);\n            resolveValueKeywords(node, config, snippet, score);\n            node.snippet = snippet;\n        }\n        else if (node.name) {\n            const snippet = findBestMatch(node.name, snippets, score, true);\n            node.snippet = snippet;\n            if (snippet) {\n                if (snippet.type === \"Property\" /* Property */) {\n                    resolveAsProperty(node, snippet, config);\n                }\n                else {\n                    resolveAsSnippet(node, snippet);\n                }\n            }\n        }\n    }\n    if (node.name || config.context) {\n        // Resolve numeric values for CSS properties only\n        resolveNumericValue(node, config);\n    }\n    return node;\n}\n/**\n * Resolves CSS gradient shortcut from given property, if possible\n */\nfunction resolveGradient(node, config) {\n    let gradientFn = null;\n    const cssVal = node.value.length === 1 ? node.value[0] : null;\n    if (cssVal && cssVal.value.length === 1) {\n        const v = cssVal.value[0];\n        if (v.type === 'FunctionCall' && v.name === gradientName) {\n            gradientFn = v;\n        }\n    }\n    if (gradientFn || node.name === gradientName) {\n        if (!gradientFn) {\n            gradientFn = {\n                type: 'FunctionCall',\n                name: 'linear-gradient',\n                arguments: [cssValue(field(0, ''))]\n            };\n        }\n        else {\n            gradientFn = Object.assign(Object.assign({}, gradientFn), { name: 'linear-gradient' });\n        }\n        if (!config.context) {\n            node.name = 'background-image';\n        }\n        node.value = [cssValue(gradientFn)];\n        return true;\n    }\n    return false;\n}\n/**\n * Resolves given parsed abbreviation node as CSS property\n */\nfunction resolveAsProperty(node, snippet, config) {\n    const abbr = node.name;\n    // Check for unmatched part of abbreviation\n    // For example, in `dib` abbreviation the matched part is `d` and `ib` should\n    // be considered as inline value. If unmatched fragment exists, we should check\n    // if it matches actual value of snippet. If either explicit value is specified\n    // or unmatched fragment did not resolve to to a keyword, we should consider\n    // matched snippet as invalid\n    const inlineValue = getUnmatchedPart(abbr, snippet.key);\n    if (inlineValue) {\n        if (node.value.length) {\n            // Already have value: unmatched part indicates matched snippet is invalid\n            return node;\n        }\n        const kw = resolveKeyword(inlineValue, config, snippet);\n        if (!kw) {\n            return node;\n        }\n        node.value.push(cssValue(kw));\n    }\n    node.name = snippet.property;\n    if (node.value.length) {\n        // Replace keyword alias from current abbreviation node with matched keyword\n        resolveValueKeywords(node, config, snippet);\n    }\n    else if (snippet.value.length) {\n        const defaultValue = snippet.value[0];\n        // https://github.com/emmetio/emmet/issues/558\n        // We should auto-select inserted value only if there’s multiple value\n        // choice\n        node.value = snippet.value.length === 1 || defaultValue.some(hasField)\n            ? defaultValue\n            : defaultValue.map(n => wrapWithField(n, config));\n    }\n    return node;\n}\nfunction resolveValueKeywords(node, config, snippet, minScore) {\n    for (const cssVal of node.value) {\n        const value = [];\n        for (const token of cssVal.value) {\n            if (token.type === 'Literal') {\n                value.push(resolveKeyword(token.value, config, snippet, minScore) || token);\n            }\n            else if (token.type === 'FunctionCall') {\n                // For function calls, we should find matching function call\n                // and merge arguments\n                const match = resolveKeyword(token.name, config, snippet, minScore);\n                if (match && match.type === 'FunctionCall') {\n                    value.push(Object.assign(Object.assign({}, match), { arguments: token.arguments.concat(match.arguments.slice(token.arguments.length)) }));\n                }\n                else {\n                    value.push(token);\n                }\n            }\n            else {\n                value.push(token);\n            }\n        }\n        cssVal.value = value;\n    }\n}\n/**\n * Resolves given parsed abbreviation node as a snippet: a plain code chunk\n */\nfunction resolveAsSnippet(node, snippet) {\n    // When resolving snippets, we have to do the following:\n    // 1. Replace field placeholders with actual field tokens.\n    // 2. If input values given, put them instead of fields\n    let offset = 0;\n    let m;\n    const reField = /\\$\\{(\\d+)(:[^}]+)?\\}/g;\n    const inputValue = node.value[0];\n    const outputValue = [];\n    while (m = reField.exec(snippet.value)) {\n        if (offset !== m.index) {\n            outputValue.push(literal(snippet.value.slice(offset, m.index)));\n        }\n        offset = m.index + m[0].length;\n        if (inputValue && inputValue.value.length) {\n            outputValue.push(inputValue.value.shift());\n        }\n        else {\n            outputValue.push(field(Number(m[1]), m[2] ? m[2].slice(1) : ''));\n        }\n    }\n    const tail = snippet.value.slice(offset);\n    if (tail) {\n        outputValue.push(literal(tail));\n    }\n    node.name = void 0;\n    node.value = [cssValue(...outputValue)];\n    return node;\n}\n/**\n * Finds best matching item from `items` array\n * @param abbr  Abbreviation to match\n * @param items List of items for match\n * @param minScore The minimum score the best matched item should have to be a valid match.\n */\nfunction findBestMatch(abbr, items, minScore = 0, partialMatch = false) {\n    let matchedItem = null;\n    let maxScore = 0;\n    for (const item of items) {\n        const score = scoreMatch(abbr, getScoringPart(item), partialMatch);\n        if (score === 1) {\n            // direct hit, no need to look further\n            return item;\n        }\n        if (score && score >= maxScore) {\n            maxScore = score;\n            matchedItem = item;\n        }\n    }\n    return maxScore >= minScore ? matchedItem : null;\n}\nfunction getScoringPart(item) {\n    return typeof item === 'string' ? item : item.key;\n}\n/**\n * Returns a part of `abbr` that wasn’t directly matched against `str`.\n * For example, if abbreviation `poas` is matched against `position`,\n * the unmatched part will be `as` since `a` wasn’t found in string stream\n */\nfunction getUnmatchedPart(abbr, str) {\n    for (let i = 0, lastPos = 0; i < abbr.length; i++) {\n        lastPos = str.indexOf(abbr[i], lastPos);\n        if (lastPos === -1) {\n            return abbr.slice(i);\n        }\n        lastPos++;\n    }\n    return '';\n}\n/**\n * Resolves given keyword shorthand into matched snippet keyword or global keyword,\n * if possible\n */\nfunction resolveKeyword(kw, config, snippet, minScore) {\n    let ref;\n    if (snippet) {\n        if (ref = findBestMatch(kw, Object.keys(snippet.keywords), minScore)) {\n            return snippet.keywords[ref];\n        }\n        for (const dep of snippet.dependencies) {\n            if (ref = findBestMatch(kw, Object.keys(dep.keywords), minScore)) {\n                return dep.keywords[ref];\n            }\n        }\n    }\n    if (ref = findBestMatch(kw, config.options['stylesheet.keywords'], minScore)) {\n        return literal(ref);\n    }\n    return null;\n}\n/**\n * Resolves numeric values in given abbreviation node\n */\nfunction resolveNumericValue(node, config) {\n    const aliases = config.options['stylesheet.unitAliases'];\n    const unitless = config.options['stylesheet.unitless'];\n    for (const v of node.value) {\n        for (const t of v.value) {\n            if (t.type === 'NumberValue') {\n                if (t.unit) {\n                    t.unit = aliases[t.unit] || t.unit;\n                }\n                else if (t.value !== 0 && !unitless.includes(node.name)) {\n                    t.unit = t.rawValue.includes('.')\n                        ? config.options['stylesheet.floatUnit']\n                        : config.options['stylesheet.intUnit'];\n                }\n            }\n        }\n    }\n}\n/**\n * Constructs CSS value token\n */\nfunction cssValue(...args) {\n    return {\n        type: 'CSSValue',\n        value: args\n    };\n}\n/**\n * Constructs literal token\n */\nfunction literal(value) {\n    return { type: 'Literal', value };\n}\n/**\n * Constructs field token\n */\nfunction field(index, name) {\n    return { type: 'Field', index, name };\n}\n/**\n * Check if given value contains fields\n */\nfunction hasField(value) {\n    for (const v of value.value) {\n        if (v.type === 'Field' || (v.type === 'FunctionCall' && v.arguments.some(hasField))) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Wraps tokens of given abbreviation with fields\n */\nfunction wrapWithField(node, config, state = { index: 1 }) {\n    let value = [];\n    for (const v of node.value) {\n        switch (v.type) {\n            case 'ColorValue':\n                value.push(field(state.index++, color(v, config.options['stylesheet.shortHex'])));\n                break;\n            case 'Literal':\n                value.push(field(state.index++, v.value));\n                break;\n            case 'NumberValue':\n                value.push(field(state.index++, `${v.value}${v.unit}`));\n                break;\n            case 'StringValue':\n                const q = v.quote === 'single' ? '\\'' : '\"';\n                value.push(field(state.index++, q + v.value + q));\n                break;\n            case 'FunctionCall':\n                value.push(field(state.index++, v.name), literal('('));\n                for (let i = 0, il = v.arguments.length; i < il; i++) {\n                    value = value.concat(wrapWithField(v.arguments[i], config, state).value);\n                    if (i !== il - 1) {\n                        value.push(literal(', '));\n                    }\n                }\n                value.push(literal(')'));\n                break;\n            default:\n                value.push(v);\n        }\n    }\n    return Object.assign(Object.assign({}, node), { value });\n}\n/**\n * Check if abbreviation should be expanded in CSS value context\n */\nfunction isValueScope(config) {\n    if (config.context) {\n        return config.context.name === \"@@value\" /* Value */ || !config.context.name.startsWith('@@');\n    }\n    return false;\n}\n/**\n * Returns snippets for given scope\n */\nfunction getSnippetsForScope(snippets, config) {\n    if (config.context) {\n        if (config.context.name === \"@@section\" /* Section */) {\n            return snippets.filter(s => s.type === \"Raw\" /* Raw */);\n        }\n        if (config.context.name === \"@@property\" /* Property */) {\n            return snippets.filter(s => s.type === \"Property\" /* Property */);\n        }\n    }\n    return snippets;\n}\n\nvar markupSnippets = {\n\t\"a\": \"a[href]\",\n\t\"a:blank\": \"a[href='http://${0}' target='_blank' rel='noopener noreferrer']\",\n\t\"a:link\": \"a[href='http://${0}']\",\n\t\"a:mail\": \"a[href='mailto:${0}']\",\n\t\"a:tel\": \"a[href='tel:+${0}']\",\n\t\"abbr\": \"abbr[title]\",\n\t\"acr|acronym\": \"acronym[title]\",\n\t\"base\": \"base[href]/\",\n\t\"basefont\": \"basefont/\",\n\t\"br\": \"br/\",\n\t\"frame\": \"frame/\",\n\t\"hr\": \"hr/\",\n\t\"bdo\": \"bdo[dir]\",\n\t\"bdo:r\": \"bdo[dir=rtl]\",\n\t\"bdo:l\": \"bdo[dir=ltr]\",\n\t\"col\": \"col/\",\n\t\"link\": \"link[rel=stylesheet href]/\",\n\t\"link:css\": \"link[href='${1:style}.css']\",\n\t\"link:print\": \"link[href='${1:print}.css' media=print]\",\n\t\"link:favicon\": \"link[rel='shortcut icon' type=image/x-icon href='${1:favicon.ico}']\",\n\t\"link:mf|link:manifest\": \"link[rel='manifest' href='${1:manifest.json}']\",\n\t\"link:touch\": \"link[rel=apple-touch-icon href='${1:favicon.png}']\",\n\t\"link:rss\": \"link[rel=alternate type=application/rss+xml title=RSS href='${1:rss.xml}']\",\n\t\"link:atom\": \"link[rel=alternate type=application/atom+xml title=Atom href='${1:atom.xml}']\",\n\t\"link:im|link:import\": \"link[rel=import href='${1:component}.html']\",\n\t\"meta\": \"meta/\",\n\t\"meta:utf\": \"meta[http-equiv=Content-Type content='text/html;charset=UTF-8']\",\n\t\"meta:vp\": \"meta[name=viewport content='width=${1:device-width}, initial-scale=${2:1.0}']\",\n\t\"meta:compat\": \"meta[http-equiv=X-UA-Compatible content='${1:IE=7}']\",\n\t\"meta:edge\": \"meta:compat[content='${1:ie=edge}']\",\n\t\"meta:redirect\": \"meta[http-equiv=refresh content='0; url=${1:http://example.com}']\",\n\t\"meta:kw\": \"meta[name=keywords content]\",\n\t\"meta:desc\": \"meta[name=description content]\",\n\t\"style\": \"style\",\n\t\"script\": \"script\",\n\t\"script:src\": \"script[src]\",\n\t\"img\": \"img[src alt]/\",\n\t\"img:s|img:srcset\": \"img[srcset src alt]\",\n\t\"img:z|img:sizes\": \"img[sizes srcset src alt]\",\n\t\"picture\": \"picture\",\n\t\"src|source\": \"source/\",\n\t\"src:sc|source:src\": \"source[src type]\",\n\t\"src:s|source:srcset\": \"source[srcset]\",\n\t\"src:t|source:type\": \"source[srcset type='${1:image/}']\",\n\t\"src:z|source:sizes\": \"source[sizes srcset]\",\n\t\"src:m|source:media\": \"source[media='(${1:min-width: })' srcset]\",\n\t\"src:mt|source:media:type\": \"source:media[type='${2:image/}']\",\n\t\"src:mz|source:media:sizes\": \"source:media[sizes srcset]\",\n\t\"src:zt|source:sizes:type\": \"source[sizes srcset type='${1:image/}']\",\n\t\"iframe\": \"iframe[src frameborder=0]\",\n\t\"embed\": \"embed[src type]/\",\n\t\"object\": \"object[data type]\",\n\t\"param\": \"param[name value]/\",\n\t\"map\": \"map[name]\",\n\t\"area\": \"area[shape coords href alt]/\",\n\t\"area:d\": \"area[shape=default]\",\n\t\"area:c\": \"area[shape=circle]\",\n\t\"area:r\": \"area[shape=rect]\",\n\t\"area:p\": \"area[shape=poly]\",\n\t\"form\": \"form[action]\",\n\t\"form:get\": \"form[method=get]\",\n\t\"form:post\": \"form[method=post]\",\n\t\"label\": \"label[for]\",\n\t\"input\": \"input[type=${1:text}]/\",\n\t\"inp\": \"input[name=${1} id=${1}]\",\n\t\"input:h|input:hidden\": \"input[type=hidden name]\",\n\t\"input:t|input:text\": \"inp[type=text]\",\n\t\"input:search\": \"inp[type=search]\",\n\t\"input:email\": \"inp[type=email]\",\n\t\"input:url\": \"inp[type=url]\",\n\t\"input:p|input:password\": \"inp[type=password]\",\n\t\"input:datetime\": \"inp[type=datetime]\",\n\t\"input:date\": \"inp[type=date]\",\n\t\"input:datetime-local\": \"inp[type=datetime-local]\",\n\t\"input:month\": \"inp[type=month]\",\n\t\"input:week\": \"inp[type=week]\",\n\t\"input:time\": \"inp[type=time]\",\n\t\"input:tel\": \"inp[type=tel]\",\n\t\"input:number\": \"inp[type=number]\",\n\t\"input:color\": \"inp[type=color]\",\n\t\"input:c|input:checkbox\": \"inp[type=checkbox]\",\n\t\"input:r|input:radio\": \"inp[type=radio]\",\n\t\"input:range\": \"inp[type=range]\",\n\t\"input:f|input:file\": \"inp[type=file]\",\n\t\"input:s|input:submit\": \"input[type=submit value]\",\n\t\"input:i|input:image\": \"input[type=image src alt]\",\n\t\"input:b|input:btn|input:button\": \"input[type=button value]\",\n\t\"input:reset\": \"input:button[type=reset]\",\n\t\"isindex\": \"isindex/\",\n\t\"select\": \"select[name=${1} id=${1}]\",\n\t\"select:d|select:disabled\": \"select[disabled.]\",\n\t\"opt|option\": \"option[value]\",\n\t\"textarea\": \"textarea[name=${1} id=${1} cols=${2:30} rows=${3:10}]\",\n\t\"marquee\": \"marquee[behavior direction]\",\n\t\"menu:c|menu:context\": \"menu[type=context]\",\n\t\"menu:t|menu:toolbar\": \"menu[type=toolbar]\",\n\t\"video\": \"video[src]\",\n\t\"audio\": \"audio[src]\",\n\t\"html:xml\": \"html[xmlns=http://www.w3.org/1999/xhtml]\",\n\t\"keygen\": \"keygen/\",\n\t\"command\": \"command/\",\n\t\"btn:s|button:s|button:submit\" : \"button[type=submit]\",\n\t\"btn:r|button:r|button:reset\" : \"button[type=reset]\",\n\t\"btn:d|button:d|button:disabled\" : \"button[disabled.]\",\n\t\"fst:d|fset:d|fieldset:d|fieldset:disabled\" : \"fieldset[disabled.]\",\n\n\t\"bq\": \"blockquote\",\n\t\"fig\": \"figure\",\n\t\"figc\": \"figcaption\",\n\t\"pic\": \"picture\",\n\t\"ifr\": \"iframe\",\n\t\"emb\": \"embed\",\n\t\"obj\": \"object\",\n\t\"cap\": \"caption\",\n\t\"colg\": \"colgroup\",\n\t\"fst\": \"fieldset\",\n\t\"btn\": \"button\",\n\t\"optg\": \"optgroup\",\n\t\"tarea\": \"textarea\",\n\t\"leg\": \"legend\",\n\t\"sect\": \"section\",\n\t\"art\": \"article\",\n\t\"hdr\": \"header\",\n\t\"ftr\": \"footer\",\n\t\"adr\": \"address\",\n\t\"dlg\": \"dialog\",\n\t\"str\": \"strong\",\n\t\"prog\": \"progress\",\n\t\"mn\": \"main\",\n\t\"tem\": \"template\",\n\t\"fset\": \"fieldset\",\n\t\"datag\": \"datagrid\",\n\t\"datal\": \"datalist\",\n\t\"kg\": \"keygen\",\n\t\"out\": \"output\",\n\t\"det\": \"details\",\n\t\"sum\": \"summary\",\n\t\"cmd\": \"command\",\n\n\t\"ri:d|ri:dpr\": \"img:s\",\n\t\"ri:v|ri:viewport\": \"img:z\",\n\t\"ri:a|ri:art\": \"pic>src:m+img\",\n\t\"ri:t|ri:type\": \"pic>src:t+img\",\n\n\t\"!!!\": \"{<!DOCTYPE html>}\",\n\t\"doc\": \"html[lang=${lang}]>(head>meta[charset=${charset}]+meta[http-equiv='X-UA-Compatible'][content='IE=edge']+meta:vp+title{${1:Document}})+body\",\n\t\"!|html:5\": \"!!!+doc\",\n\n\t\"c\": \"{<!-- ${0} -->}\",\n\t\"cc:ie\": \"{<!--[if IE]>${0}<![endif]-->}\",\n\t\"cc:noie\": \"{<!--[if !IE]><!-->${0}<!--<![endif]-->}\"\n};\n\nvar stylesheetSnippets = {\n\t\"@f\": \"@font-face {\\n\\tfont-family: ${1};\\n\\tsrc: url(${2});\\n}\",\n\t\"@ff\": \"@font-face {\\n\\tfont-family: '${1:FontName}';\\n\\tsrc: url('${2:FileName}.eot');\\n\\tsrc: url('${2:FileName}.eot?#iefix') format('embedded-opentype'),\\n\\t\\t url('${2:FileName}.woff') format('woff'),\\n\\t\\t url('${2:FileName}.ttf') format('truetype'),\\n\\t\\t url('${2:FileName}.svg#${1:FontName}') format('svg');\\n\\tfont-style: ${3:normal};\\n\\tfont-weight: ${4:normal};\\n}\",\n\t\"@i|@import\": \"@import url(${0});\",\n\t\"@kf\": \"@keyframes ${1:identifier} {\\n\\t${2}\\n}\",\n\t\"@m|@media\": \"@media ${1:screen} {\\n\\t${0}\\n}\",\n\t\"ac\": \"align-content:start|end|flex-start|flex-end|center|space-between|space-around|stretch|space-evenly\",\n\t\"ai\": \"align-items:start|end|flex-start|flex-end|center|baseline|stretch\",\n\t\"anim\": \"animation:${1:name} ${2:duration} ${3:timing-function} ${4:delay} ${5:iteration-count} ${6:direction} ${7:fill-mode}\",\n\t\"animdel\": \"animation-delay:time\",\n\t\"animdir\": \"animation-direction:normal|reverse|alternate|alternate-reverse\",\n\t\"animdur\": \"animation-duration:${1:0}s\",\n\t\"animfm\": \"animation-fill-mode:both|forwards|backwards\",\n\t\"animic\": \"animation-iteration-count:1|infinite\",\n\t\"animn\": \"animation-name\",\n\t\"animps\": \"animation-play-state:running|paused\",\n\t\"animtf\": \"animation-timing-function:linear|ease|ease-in|ease-out|ease-in-out|cubic-bezier(${1:0.1}, ${2:0.7}, ${3:1.0}, ${3:0.1})\",\n\t\"ap\": \"appearance:none\",\n\t\"as\": \"align-self:start|end|auto|flex-start|flex-end|center|baseline|stretch\",\n\t\"b\": \"bottom\",\n\t\"bd\": \"border:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdb\": \"border-bottom:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdbc\": \"border-bottom-color:${1:#000}\",\n\t\"bdbi\": \"border-bottom-image:url(${0})\",\n\t\"bdbk\": \"border-break:close\",\n\t\"bdbli\": \"border-bottom-left-image:url(${0})|continue\",\n\t\"bdblrs\": \"border-bottom-left-radius\",\n\t\"bdbri\": \"border-bottom-right-image:url(${0})|continue\",\n\t\"bdbrrs\": \"border-bottom-right-radius\",\n\t\"bdbs\": \"border-bottom-style\",\n\t\"bdbw\": \"border-bottom-width\",\n\t\"bdc\": \"border-color:${1:#000}\",\n\t\"bdci\": \"border-corner-image:url(${0})|continue\",\n\t\"bdcl\": \"border-collapse:collapse|separate\",\n\t\"bdf\": \"border-fit:repeat|clip|scale|stretch|overwrite|overflow|space\",\n\t\"bdi\": \"border-image:url(${0})\",\n\t\"bdl\": \"border-left:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdlc\": \"border-left-color:${1:#000}\",\n\t\"bdlen\": \"border-length\",\n\t\"bdli\": \"border-left-image:url(${0})\",\n\t\"bdls\": \"border-left-style\",\n\t\"bdlw\": \"border-left-width\",\n\t\"bdr\": \"border-right:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdrc\": \"border-right-color:${1:#000}\",\n\t\"bdri\": \"border-right-image:url(${0})\",\n\t\"bdrs\": \"border-radius\",\n\t\"bdrst\": \"border-right-style\",\n\t\"bdrw\": \"border-right-width\",\n\t\"bds\": \"border-style:none|hidden|dotted|dashed|solid|double|dot-dash|dot-dot-dash|wave|groove|ridge|inset|outset\",\n\t\"bdsp\": \"border-spacing\",\n\t\"bdt\": \"border-top:${1:1px} ${2:solid} ${3:#000}\",\n\t\"bdtc\": \"border-top-color:${1:#000}\",\n\t\"bdti\": \"border-top-image:url(${0})\",\n\t\"bdtli\": \"border-top-left-image:url(${0})|continue\",\n\t\"bdtlrs\": \"border-top-left-radius\",\n\t\"bdtri\": \"border-top-right-image:url(${0})|continue\",\n\t\"bdtrrs\": \"border-top-right-radius\",\n\t\"bdts\": \"border-top-style\",\n\t\"bdtw\": \"border-top-width\",\n\t\"bdw\": \"border-width\",\n\t\"bfv\": \"backface-visibility:hidden|visible\",\n\t\"bg\": \"background:${1:#000}\",\n\t\"bga\": \"background-attachment:fixed|scroll\",\n\t\"bgbk\": \"background-break:bounding-box|each-box|continuous\",\n\t\"bgc\": \"background-color:#${1:fff}\",\n\t\"bgcp\": \"background-clip:padding-box|border-box|content-box|no-clip\",\n\t\"bgi\": \"background-image:url(${0})\",\n\t\"bgo\": \"background-origin:padding-box|border-box|content-box\",\n\t\"bgp\": \"background-position:${1:0} ${2:0}\",\n\t\"bgpx\": \"background-position-x\",\n\t\"bgpy\": \"background-position-y\",\n\t\"bgr\": \"background-repeat:no-repeat|repeat-x|repeat-y|space|round\",\n\t\"bgsz\": \"background-size:contain|cover\",\n\t\"bxsh\": \"box-shadow:${1:inset }${2:hoff} ${3:voff} ${4:blur} ${5:#000}|none\",\n\t\"bxsz\": \"box-sizing:border-box|content-box|border-box\",\n\t\"c\": \"color:${1:#000}\",\n\t\"cr\": \"color:rgb(${1:0}, ${2:0}, ${3:0})\",\n\t\"cra\": \"color:rgba(${1:0}, ${2:0}, ${3:0}, ${4:.5})\",\n\t\"cl\": \"clear:both|left|right|none\",\n\t\"cm\": \"/* ${0} */\",\n\t\"cnt\": \"content:'${0}'|normal|open-quote|no-open-quote|close-quote|no-close-quote|attr(${0})|counter(${0})|counters(${0})\",\n\t\"coi\": \"counter-increment\",\n\t\"colm\": \"columns\",\n\t\"colmc\": \"column-count\",\n\t\"colmf\": \"column-fill\",\n\t\"colmg\": \"column-gap\",\n\t\"colmr\": \"column-rule\",\n\t\"colmrc\": \"column-rule-color\",\n\t\"colmrs\": \"column-rule-style\",\n\t\"colmrw\": \"column-rule-width\",\n\t\"colms\": \"column-span\",\n\t\"colmw\": \"column-width\",\n\t\"cor\": \"counter-reset\",\n\t\"cp\": \"clip:auto|rect(${1:top} ${2:right} ${3:bottom} ${4:left})\",\n\t\"cps\": \"caption-side:top|bottom\",\n\t\"cur\": \"cursor:pointer|auto|default|crosshair|hand|help|move|pointer|text\",\n\t\"d\": \"display:block|none|flex|inline-flex|inline|inline-block|grid|inline-grid|subgrid|list-item|run-in|compact|table|inline-table|table-caption|table-column|table-column-group|table-header-group|table-footer-group|table-row|table-row-group|table-cell|ruby|ruby-base|ruby-base-group|ruby-text|ruby-text-group\",\n\t\"ec\": \"empty-cells:show|hide\",\n\t\"f\": \"font:${1:1em} ${2:sans-serif}\",\n\t\"fd\": \"font-display:auto|block|swap|fallback|optional\",\n\t\"fef\": \"font-effect:none|engrave|emboss|outline\",\n\t\"fem\": \"font-emphasize\",\n\t\"femp\": \"font-emphasize-position:before|after\",\n\t\"fems\": \"font-emphasize-style:none|accent|dot|circle|disc\",\n\t\"ff\": \"font-family:serif|sans-serif|cursive|fantasy|monospace\",\n\t\"fft\": \"font-family:\\\"Times New Roman\\\", Times, Baskerville, Georgia, serif\",\n\t\"ffa\": \"font-family:Arial, \\\"Helvetica Neue\\\", Helvetica, sans-serif\",\n\t\"ffv\": \"font-family:Verdana, Geneva, sans-serif\",\n\t\"fl\": \"float:left|right|none\",\n\t\"fs\": \"font-style:italic|normal|oblique\",\n\t\"fsm\": \"font-smoothing:antialiased|subpixel-antialiased|none\",\n\t\"fst\": \"font-stretch:normal|ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded\",\n\t\"fv\": \"font-variant:normal|small-caps\",\n\t\"fvs\": \"font-variation-settings:normal|inherit|initial|unset\",\n\t\"fw\": \"font-weight:normal|bold|bolder|lighter\",\n\t\"fx\": \"flex\",\n\t\"fxb\": \"flex-basis:fill|max-content|min-content|fit-content|content\",\n\t\"fxd\": \"flex-direction:row|row-reverse|column|column-reverse\",\n\t\"fxf\": \"flex-flow\",\n\t\"fxg\": \"flex-grow\",\n\t\"fxsh\": \"flex-shrink\",\n\t\"fxw\": \"flex-wrap:nowrap|wrap|wrap-reverse\",\n\t\"fsz\": \"font-size\",\n\t\"fsza\": \"font-size-adjust\",\n\t\"gtc\": \"grid-template-columns:repeat(${0})|minmax()\",\n\t\"gtr\": \"grid-template-rows:repeat(${0})|minmax()\",\n\t\"gta\": \"grid-template-areas\",\n\t\"gt\": \"grid-template\",\n\t\"gg\": \"grid-gap\",\n\t\"gcg\": \"grid-column-gap\",\n\t\"grg\": \"grid-row-gap\",\n\t\"gac\": \"grid-auto-columns:auto|minmax()\",\n\t\"gar\": \"grid-auto-rows:auto|minmax()\",\n\t\"gaf\": \"grid-auto-flow:row|column|dense|inherit|initial|unset\",\n\t\"gd\": \"grid\",\n\t\"gc\": \"grid-column\",\n\t\"gcs\": \"grid-column-start\",\n\t\"gce\": \"grid-column-end\",\n\t\"gr\": \"grid-row\",\n\t\"grs\": \"grid-row-start\",\n\t\"gre\": \"grid-row-end\",\n\t\"ga\": \"grid-area\",\n\t\"h\": \"height\",\n\t\"jc\": \"justify-content:start|end|stretch|flex-start|flex-end|center|space-between|space-around|space-evenly\",\n\t\"ji\": \"justify-items:start|end|center|stretch\",\n\t\"js\": \"justify-self:start|end|center|stretch\",\n\t\"l\": \"left\",\n\t\"lg\": \"background-image:linear-gradient(${1})\",\n\t\"lh\": \"line-height\",\n\t\"lis\": \"list-style\",\n\t\"lisi\": \"list-style-image\",\n\t\"lisp\": \"list-style-position:inside|outside\",\n\t\"list\": \"list-style-type:disc|circle|square|decimal|decimal-leading-zero|lower-roman|upper-roman\",\n\t\"lts\": \"letter-spacing:normal\",\n\t\"m\": \"margin\",\n\t\"mah\": \"max-height\",\n\t\"mar\": \"max-resolution\",\n\t\"maw\": \"max-width\",\n\t\"mb\": \"margin-bottom\",\n\t\"mih\": \"min-height\",\n\t\"mir\": \"min-resolution\",\n\t\"miw\": \"min-width\",\n\t\"ml\": \"margin-left\",\n\t\"mr\": \"margin-right\",\n\t\"mt\": \"margin-top\",\n\t\"ol\": \"outline\",\n\t\"olc\": \"outline-color:${1:#000}|invert\",\n\t\"olo\": \"outline-offset\",\n\t\"ols\": \"outline-style:none|dotted|dashed|solid|double|groove|ridge|inset|outset\",\n\t\"olw\": \"outline-width|thin|medium|thick\",\n\t\"op|opa\": \"opacity\",\n\t\"ord\": \"order\",\n\t\"ori\": \"orientation:landscape|portrait\",\n\t\"orp\": \"orphans\",\n\t\"ov\": \"overflow:hidden|visible|hidden|scroll|auto\",\n\t\"ovs\": \"overflow-style:scrollbar|auto|scrollbar|panner|move|marquee\",\n\t\"ovx\": \"overflow-x:hidden|visible|hidden|scroll|auto\",\n\t\"ovy\": \"overflow-y:hidden|visible|hidden|scroll|auto\",\n\t\"p\": \"padding\",\n\t\"pb\": \"padding-bottom\",\n\t\"pgba\": \"page-break-after:auto|always|left|right\",\n\t\"pgbb\": \"page-break-before:auto|always|left|right\",\n\t\"pgbi\": \"page-break-inside:auto|avoid\",\n\t\"pl\": \"padding-left\",\n\t\"pos\": \"position:relative|absolute|relative|fixed|static\",\n\t\"pr\": \"padding-right\",\n\t\"pt\": \"padding-top\",\n\t\"q\": \"quotes\",\n\t\"qen\": \"quotes:'\\\\201C' '\\\\201D' '\\\\2018' '\\\\2019'\",\n\t\"qru\": \"quotes:'\\\\00AB' '\\\\00BB' '\\\\201E' '\\\\201C'\",\n\t\"r\": \"right\",\n\t\"rsz\": \"resize:none|both|horizontal|vertical\",\n\t\"t\": \"top\",\n\t\"ta\": \"text-align:left|center|right|justify\",\n\t\"tal\": \"text-align-last:left|center|right\",\n\t\"tbl\": \"table-layout:fixed\",\n\t\"td\": \"text-decoration:none|underline|overline|line-through\",\n\t\"te\": \"text-emphasis:none|accent|dot|circle|disc|before|after\",\n\t\"th\": \"text-height:auto|font-size|text-size|max-size\",\n\t\"ti\": \"text-indent\",\n\t\"tj\": \"text-justify:auto|inter-word|inter-ideograph|inter-cluster|distribute|kashida|tibetan\",\n\t\"to\": \"text-outline:${1:0} ${2:0} ${3:#000}\",\n\t\"tov\": \"text-overflow:ellipsis|clip\",\n\t\"tr\": \"text-replace\",\n\t\"trf\": \"transform:${1}|skewX(${1:angle})|skewY(${1:angle})|scale(${1:x}, ${2:y})|scaleX(${1:x})|scaleY(${1:y})|scaleZ(${1:z})|scale3d(${1:x}, ${2:y}, ${3:z})|rotate(${1:angle})|rotateX(${1:angle})|rotateY(${1:angle})|rotateZ(${1:angle})|translate(${1:x}, ${2:y})|translateX(${1:x})|translateY(${1:y})|translateZ(${1:z})|translate3d(${1:tx}, ${2:ty}, ${3:tz})\",\n\t\"trfo\": \"transform-origin\",\n\t\"trfs\": \"transform-style:preserve-3d\",\n\t\"trs\": \"transition:${1:prop} ${2:time}\",\n\t\"trsde\": \"transition-delay:${1:time}\",\n\t\"trsdu\": \"transition-duration:${1:time}\",\n\t\"trsp\": \"transition-property:${1:prop}\",\n\t\"trstf\": \"transition-timing-function:${1:fn}\",\n\t\"tsh\": \"text-shadow:${1:hoff} ${2:voff} ${3:blur} ${4:#000}\",\n\t\"tt\": \"text-transform:uppercase|lowercase|capitalize|none\",\n\t\"tw\": \"text-wrap:none|normal|unrestricted|suppress\",\n\t\"us\": \"user-select:none\",\n\t\"v\": \"visibility:hidden|visible|collapse\",\n\t\"va\": \"vertical-align:top|super|text-top|middle|baseline|bottom|text-bottom|sub\",\n\t\"w\": \"width\",\n\t\"whs\": \"white-space:nowrap|pre|pre-wrap|pre-line|normal\",\n\t\"whsc\": \"white-space-collapse:normal|keep-all|loose|break-strict|break-all\",\n\t\"wid\": \"widows\",\n\t\"wm\": \"writing-mode:lr-tb|lr-tb|lr-bt|rl-tb|rl-bt|tb-rl|tb-lr|bt-lr|bt-rl\",\n\t\"wob\": \"word-break:normal|keep-all|break-all\",\n\t\"wos\": \"word-spacing\",\n\t\"wow\": \"word-wrap:none|unrestricted|suppress|break-word|normal\",\n\t\"z\": \"z-index\",\n\t\"zom\": \"zoom:1\"\n};\n\nvar xslSnippets = {\n    \"tm|tmatch\": \"xsl:template[match mode]\",\n    \"tn|tname\": \"xsl:template[name]\",\n    \"call\": \"xsl:call-template[name]\",\n    \"ap\": \"xsl:apply-templates[select mode]\",\n    \"api\": \"xsl:apply-imports\",\n    \"imp\": \"xsl:import[href]\",\n    \"inc\": \"xsl:include[href]\",\n    \"ch\": \"xsl:choose\",\n    \"wh|xsl:when\": \"xsl:when[test]\",\n    \"ot\": \"xsl:otherwise\",\n    \"if\": \"xsl:if[test]\",\n    \"par\": \"xsl:param[name]\",\n    \"pare\": \"xsl:param[name select]\",\n    \"var\": \"xsl:variable[name]\",\n    \"vare\": \"xsl:variable[name select]\",\n    \"wp\": \"xsl:with-param[name select]\",\n    \"key\": \"xsl:key[name match use]\",\n    \"elem\": \"xsl:element[name]\",\n    \"attr\": \"xsl:attribute[name]\",\n    \"attrs\": \"xsl:attribute-set[name]\",\n    \"cp\": \"xsl:copy[select]\",\n    \"co\": \"xsl:copy-of[select]\",\n    \"val\": \"xsl:value-of[select]\",\n    \"for|each\": \"xsl:for-each[select]\",\n    \"tex\": \"xsl:text\",\n    \"com\": \"xsl:comment\",\n    \"msg\": \"xsl:message[terminate=no]\",\n    \"fall\": \"xsl:fallback\",\n    \"num\": \"xsl:number[value]\",\n    \"nam\": \"namespace-alias[stylesheet-prefix result-prefix]\",\n    \"pres\": \"xsl:preserve-space[elements]\",\n    \"strip\": \"xsl:strip-space[elements]\",\n    \"proc\": \"xsl:processing-instruction[name]\",\n    \"sort\": \"xsl:sort[select order]\",\n    \"choose\": \"xsl:choose>xsl:when+xsl:otherwise\",\n    \"xsl\": \"!!!+xsl:stylesheet[version=1.0 xmlns:xsl=http://www.w3.org/1999/XSL/Transform]>{\\n|}\",\n    \"!!!\": \"{<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>}\"\n};\n\nvar pugSnippets = {\n\t\"!!!\": \"{doctype html}\"\n};\n\nvar variables = {\n\t\"lang\": \"en\",\n\t\"locale\": \"en-US\",\n\t\"charset\": \"UTF-8\",\n\t\"indentation\": \"\\t\",\n\t\"newline\": \"\\n\"\n};\n\n/**\n * Default syntaxes for abbreviation types\n */\nconst defaultSyntaxes = {\n    markup: 'html',\n    stylesheet: 'css'\n};\nconst defaultOptions = {\n    'inlineElements': [\n        'a', 'abbr', 'acronym', 'applet', 'b', 'basefont', 'bdo',\n        'big', 'br', 'button', 'cite', 'code', 'del', 'dfn', 'em', 'font', 'i',\n        'iframe', 'img', 'input', 'ins', 'kbd', 'label', 'map', 'object', 'q',\n        's', 'samp', 'select', 'small', 'span', 'strike', 'strong', 'sub', 'sup',\n        'textarea', 'tt', 'u', 'var'\n    ],\n    'output.indent': '\\t',\n    'output.baseIndent': '',\n    'output.newline': '\\n',\n    'output.tagCase': '',\n    'output.attributeCase': '',\n    'output.attributeQuotes': 'double',\n    'output.format': true,\n    'output.formatLeafNode': false,\n    'output.formatSkip': ['html'],\n    'output.formatForce': ['body'],\n    'output.inlineBreak': 3,\n    'output.compactBoolean': false,\n    'output.booleanAttributes': [\n        'contenteditable', 'seamless', 'async', 'autofocus',\n        'autoplay', 'checked', 'controls', 'defer', 'disabled', 'formnovalidate',\n        'hidden', 'ismap', 'loop', 'multiple', 'muted', 'novalidate', 'readonly',\n        'required', 'reversed', 'selected', 'typemustmatch'\n    ],\n    'output.reverseAttributes': false,\n    'output.selfClosingStyle': 'html',\n    'output.field': (index, placeholder) => placeholder,\n    'output.text': text => text,\n    'markup.href': true,\n    'comment.enabled': false,\n    'comment.trigger': ['id', 'class'],\n    'comment.before': '',\n    'comment.after': '\\n<!-- /[#ID][.CLASS] -->',\n    'bem.enabled': false,\n    'bem.element': '__',\n    'bem.modifier': '_',\n    'jsx.enabled': false,\n    'stylesheet.keywords': ['auto', 'inherit', 'unset', 'none'],\n    'stylesheet.unitless': ['z-index', 'line-height', 'opacity', 'font-weight', 'zoom', 'flex', 'flex-grow', 'flex-shrink'],\n    'stylesheet.shortHex': true,\n    'stylesheet.between': ': ',\n    'stylesheet.after': ';',\n    'stylesheet.intUnit': 'px',\n    'stylesheet.floatUnit': 'em',\n    'stylesheet.unitAliases': { e: 'em', p: '%', x: 'ex', r: 'rem' },\n    'stylesheet.json': false,\n    'stylesheet.jsonDoubleQuotes': false,\n    'stylesheet.fuzzySearchMinScore': 0\n};\nconst defaultConfig = {\n    type: 'markup',\n    syntax: 'html',\n    variables,\n    snippets: {},\n    options: defaultOptions\n};\n/**\n * Default per-syntax config\n */\nconst syntaxConfig = {\n    markup: {\n        snippets: parseSnippets(markupSnippets),\n    },\n    xhtml: {\n        options: {\n            'output.selfClosingStyle': 'xhtml'\n        }\n    },\n    xml: {\n        options: {\n            'output.selfClosingStyle': 'xml'\n        }\n    },\n    xsl: {\n        snippets: parseSnippets(xslSnippets),\n        options: {\n            'output.selfClosingStyle': 'xml'\n        }\n    },\n    jsx: {\n        options: {\n            'jsx.enabled': true\n        }\n    },\n    pug: {\n        snippets: parseSnippets(pugSnippets)\n    },\n    stylesheet: {\n        snippets: parseSnippets(stylesheetSnippets)\n    },\n    sass: {\n        options: {\n            'stylesheet.after': ''\n        }\n    },\n    stylus: {\n        options: {\n            'stylesheet.between': ' ',\n            'stylesheet.after': '',\n        }\n    }\n};\n/**\n * Parses raw snippets definitions with possibly multiple keys into a plan\n * snippet map\n */\nfunction parseSnippets(snippets) {\n    const result = {};\n    Object.keys(snippets).forEach(k => {\n        for (const name of k.split('|')) {\n            result[name] = snippets[k];\n        }\n    });\n    return result;\n}\nfunction resolveConfig(config = {}, globals = {}) {\n    const type = config.type || 'markup';\n    const syntax = config.syntax || defaultSyntaxes[type];\n    return Object.assign(Object.assign(Object.assign({}, defaultConfig), config), { type,\n        syntax, variables: mergedData(type, syntax, 'variables', config, globals), snippets: mergedData(type, syntax, 'snippets', config, globals), options: mergedData(type, syntax, 'options', config, globals) });\n}\nfunction mergedData(type, syntax, key, config, globals = {}) {\n    const typeDefaults = syntaxConfig[type];\n    const typeOverride = globals[type];\n    const syntaxDefaults = syntaxConfig[syntax];\n    const syntaxOverride = globals[syntax];\n    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, defaultConfig[key]), (typeDefaults && typeDefaults[key])), (syntaxDefaults && syntaxDefaults[key])), (typeOverride && typeOverride[key])), (syntaxOverride && syntaxOverride[key])), config[key]);\n}\n\n/**\n * Creates structure for scanning given string in backward direction\n */\nfunction backwardScanner(text, start = 0) {\n    return { text, start, pos: text.length };\n}\n/**\n * Check if given scanner position is at start of scanned text\n */\nfunction sol(scanner) {\n    return scanner.pos === scanner.start;\n}\n/**\n * “Peeks” character code an current scanner location without advancing it\n */\nfunction peek$1(scanner, offset = 0) {\n    return scanner.text.charCodeAt(scanner.pos - 1 + offset);\n}\n/**\n * Returns current character code and moves character location one symbol back\n */\nfunction previous(scanner) {\n    if (!sol(scanner)) {\n        return scanner.text.charCodeAt(--scanner.pos);\n    }\n}\n/**\n * Consumes current character code if it matches given `match` code or function\n */\nfunction consume(scanner, match) {\n    if (sol(scanner)) {\n        return false;\n    }\n    const ok = typeof match === 'function'\n        ? match(peek$1(scanner))\n        : match === peek$1(scanner);\n    if (ok) {\n        scanner.pos--;\n    }\n    return !!ok;\n}\nfunction consumeWhile(scanner, match) {\n    const start = scanner.pos;\n    while (consume(scanner, match)) {\n        // empty\n    }\n    return scanner.pos < start;\n}\n\n/**\n * Check if given character code is a quote\n */\nfunction isQuote(c) {\n    return c === 39 /* SingleQuote */ || c === 34 /* DoubleQuote */;\n}\n/**\n * Consumes quoted value, if possible\n * @return Returns `true` is value was consumed\n */\nfunction consumeQuoted(scanner) {\n    const start = scanner.pos;\n    const quote = previous(scanner);\n    if (isQuote(quote)) {\n        while (!sol(scanner)) {\n            if (previous(scanner) === quote && peek$1(scanner) !== 92 /* Escape */) {\n                return true;\n            }\n        }\n    }\n    scanner.pos = start;\n    return false;\n}\n\nconst bracePairs = {\n    [91 /* SquareL */]: 93 /* SquareR */,\n    [40 /* RoundL */]: 41 /* RoundR */,\n    [123 /* CurlyL */]: 125 /* CurlyR */,\n};\n\n/**\n * Check if given reader’s current position points at the end of HTML tag\n */\nfunction isHtml(scanner) {\n    const start = scanner.pos;\n    if (!consume(scanner, 62 /* AngleRight */)) {\n        return false;\n    }\n    let ok = false;\n    consume(scanner, 47 /* Slash */); // possibly self-closed element\n    while (!sol(scanner)) {\n        consumeWhile(scanner, isWhiteSpace);\n        if (consumeIdent(scanner)) {\n            // ate identifier: could be a tag name, boolean attribute or unquoted\n            // attribute value\n            if (consume(scanner, 47 /* Slash */)) {\n                // either closing tag or invalid tag\n                ok = consume(scanner, 60 /* AngleLeft */);\n                break;\n            }\n            else if (consume(scanner, 60 /* AngleLeft */)) {\n                // opening tag\n                ok = true;\n                break;\n            }\n            else if (consume(scanner, isWhiteSpace)) {\n                // boolean attribute\n                continue;\n            }\n            else if (consume(scanner, 61 /* Equals */)) {\n                // simple unquoted value or invalid attribute\n                if (consumeIdent(scanner)) {\n                    continue;\n                }\n                break;\n            }\n            else if (consumeAttributeWithUnquotedValue(scanner)) {\n                // identifier was a part of unquoted value\n                ok = true;\n                break;\n            }\n            // invalid tag\n            break;\n        }\n        if (consumeAttribute(scanner)) {\n            continue;\n        }\n        break;\n    }\n    scanner.pos = start;\n    return ok;\n}\n/**\n * Consumes HTML attribute from given string.\n * @return `true` if attribute was consumed.\n */\nfunction consumeAttribute(scanner) {\n    return consumeAttributeWithQuotedValue(scanner) || consumeAttributeWithUnquotedValue(scanner);\n}\nfunction consumeAttributeWithQuotedValue(scanner) {\n    const start = scanner.pos;\n    if (consumeQuoted(scanner) && consume(scanner, 61 /* Equals */) && consumeIdent(scanner)) {\n        return true;\n    }\n    scanner.pos = start;\n    return false;\n}\nfunction consumeAttributeWithUnquotedValue(scanner) {\n    const start = scanner.pos;\n    const stack = [];\n    while (!sol(scanner)) {\n        const ch = peek$1(scanner);\n        if (isCloseBracket(ch)) {\n            stack.push(ch);\n        }\n        else if (isOpenBracket(ch)) {\n            if (stack.pop() !== bracePairs[ch]) {\n                // Unexpected open bracket\n                break;\n            }\n        }\n        else if (!isUnquotedValue(ch)) {\n            break;\n        }\n        scanner.pos--;\n    }\n    if (start !== scanner.pos && consume(scanner, 61 /* Equals */) && consumeIdent(scanner)) {\n        return true;\n    }\n    scanner.pos = start;\n    return false;\n}\n/**\n * Consumes HTML identifier from stream\n */\nfunction consumeIdent(scanner) {\n    return consumeWhile(scanner, isIdent);\n}\n/**\n * Check if given character code belongs to HTML identifier\n */\nfunction isIdent(ch) {\n    return ch === 58 /* Colon */ || ch === 45 /* Dash */ || isAlpha(ch) || isNumber(ch);\n}\n/**\n * Check if given character code is alpha code (letter though A to Z)\n */\nfunction isAlpha(ch) {\n    ch &= ~32; // quick hack to convert any char code to uppercase char code\n    return ch >= 65 && ch <= 90; // A-Z\n}\n/**\n * Check if given code is a number\n */\nfunction isNumber(ch) {\n    return ch > 47 && ch < 58;\n}\n/**\n * Check if given code is a whitespace\n */\nfunction isWhiteSpace(ch) {\n    return ch === 32 /* Space */ || ch === 9 /* Tab */;\n}\n/**\n * Check if given code may belong to unquoted attribute value\n */\nfunction isUnquotedValue(ch) {\n    return !isNaN(ch) && ch !== 61 /* Equals */ && !isWhiteSpace(ch) && !isQuote(ch);\n}\nfunction isOpenBracket(ch) {\n    return ch === 123 /* CurlyL */ || ch === 40 /* RoundL */ || ch === 91 /* SquareL */;\n}\nfunction isCloseBracket(ch) {\n    return ch === 125 /* CurlyR */ || ch === 41 /* RoundR */ || ch === 93 /* SquareR */;\n}\n\nconst code = (ch) => ch.charCodeAt(0);\nconst specialChars = '#.*:$-_!@%^+>/'.split('').map(code);\nconst defaultOptions$1 = {\n    type: 'markup',\n    lookAhead: true,\n    prefix: ''\n};\n/**\n * Extracts Emmet abbreviation from given string.\n * The goal of this module is to extract abbreviation from current editor’s line,\n * e.g. like this: `<span>.foo[title=bar|]</span>` -> `.foo[title=bar]`, where\n * `|` is a current caret position.\n * @param line A text line where abbreviation should be expanded\n * @param pos Caret position in line. If not given, uses end of line\n * @param options Extracting options\n */\nfunction extractAbbreviation(line, pos = line.length, options = {}) {\n    // make sure `pos` is within line range\n    const opt = Object.assign(Object.assign({}, defaultOptions$1), options);\n    pos = Math.min(line.length, Math.max(0, pos == null ? line.length : pos));\n    if (opt.lookAhead) {\n        pos = offsetPastAutoClosed(line, pos, opt);\n    }\n    let ch;\n    const start = getStartOffset(line, pos, opt.prefix || '');\n    if (start === -1) {\n        return void 0;\n    }\n    const scanner = backwardScanner(line, start);\n    scanner.pos = pos;\n    const stack = [];\n    while (!sol(scanner)) {\n        ch = peek$1(scanner);\n        if (stack.includes(125 /* CurlyR */)) {\n            if (ch === 125 /* CurlyR */) {\n                stack.push(ch);\n                scanner.pos--;\n                continue;\n            }\n            if (ch !== 123 /* CurlyL */) {\n                scanner.pos--;\n                continue;\n            }\n        }\n        if (isCloseBrace(ch, opt.type)) {\n            stack.push(ch);\n        }\n        else if (isOpenBrace(ch, opt.type)) {\n            if (stack.pop() !== bracePairs[ch]) {\n                // unexpected brace\n                break;\n            }\n        }\n        else if (stack.includes(93 /* SquareR */) || stack.includes(125 /* CurlyR */)) {\n            // respect all characters inside attribute sets or text nodes\n            scanner.pos--;\n            continue;\n        }\n        else if (isHtml(scanner) || !isAbbreviation(ch)) {\n            break;\n        }\n        scanner.pos--;\n    }\n    if (!stack.length && scanner.pos !== pos) {\n        // Found something, remove some invalid symbols from the\n        // beginning and return abbreviation\n        const abbreviation = line.slice(scanner.pos, pos).replace(/^[*+>^]+/, '');\n        return {\n            abbreviation,\n            location: pos - abbreviation.length,\n            start: options.prefix\n                ? start - options.prefix.length\n                : pos - abbreviation.length,\n            end: pos\n        };\n    }\n}\n/**\n * Returns new `line` index which is right after characters beyound `pos` that\n * editor will likely automatically close, e.g. }, ], and quotes\n */\nfunction offsetPastAutoClosed(line, pos, options) {\n    // closing quote is allowed only as a next character\n    if (isQuote(line.charCodeAt(pos))) {\n        pos++;\n    }\n    // offset pointer until non-autoclosed character is found\n    while (isCloseBrace(line.charCodeAt(pos), options.type)) {\n        pos++;\n    }\n    return pos;\n}\n/**\n * Returns start offset (left limit) in `line` where we should stop looking for\n * abbreviation: it’s nearest to `pos` location of `prefix` token\n */\nfunction getStartOffset(line, pos, prefix) {\n    if (!prefix) {\n        return 0;\n    }\n    const scanner = backwardScanner(line);\n    const compiledPrefix = prefix.split('').map(code);\n    scanner.pos = pos;\n    let result;\n    while (!sol(scanner)) {\n        if (consumePair(scanner, 93 /* SquareR */, 91 /* SquareL */) || consumePair(scanner, 125 /* CurlyR */, 123 /* CurlyL */)) {\n            continue;\n        }\n        result = scanner.pos;\n        if (consumeArray(scanner, compiledPrefix)) {\n            return result;\n        }\n        scanner.pos--;\n    }\n    return -1;\n}\n/**\n * Consumes full character pair, if possible\n */\nfunction consumePair(scanner, close, open) {\n    const start = scanner.pos;\n    if (consume(scanner, close)) {\n        while (!sol(scanner)) {\n            if (consume(scanner, open)) {\n                return true;\n            }\n            scanner.pos--;\n        }\n    }\n    scanner.pos = start;\n    return false;\n}\n/**\n * Consumes all character codes from given array, right-to-left, if possible\n */\nfunction consumeArray(scanner, arr) {\n    const start = scanner.pos;\n    let consumed = false;\n    for (let i = arr.length - 1; i >= 0 && !sol(scanner); i--) {\n        if (!consume(scanner, arr[i])) {\n            break;\n        }\n        consumed = i === 0;\n    }\n    if (!consumed) {\n        scanner.pos = start;\n    }\n    return consumed;\n}\nfunction isAbbreviation(ch) {\n    return (ch > 64 && ch < 91) // uppercase letter\n        || (ch > 96 && ch < 123) // lowercase letter\n        || (ch > 47 && ch < 58) // number\n        || specialChars.includes(ch); // special character\n}\nfunction isOpenBrace(ch, syntax) {\n    return ch === 40 /* RoundL */ || (syntax === 'markup' && (ch === 91 /* SquareL */ || ch === 123 /* CurlyL */));\n}\nfunction isCloseBrace(ch, syntax) {\n    return ch === 41 /* RoundR */ || (syntax === 'markup' && (ch === 93 /* SquareR */ || ch === 125 /* CurlyR */));\n}\n\nfunction expandAbbreviation(abbr, config) {\n    const resolvedConfig = resolveConfig(config);\n    return resolvedConfig.type === 'stylesheet'\n        ? stylesheet(abbr, resolvedConfig)\n        : markup(abbr, resolvedConfig);\n}\n/**\n * Expands given *markup* abbreviation (e.g. regular Emmet abbreviation that\n * produces structured output like HTML) and outputs it according to options\n * provided in config\n */\nfunction markup(abbr, config) {\n    return stringify(parse(abbr, config), config);\n}\n/**\n * Expands given *stylesheet* abbreviation (a special Emmet abbreviation designed for\n * stylesheet languages like CSS, SASS etc.) and outputs it according to options\n * provided in config\n */\nfunction stylesheet(abbr, config) {\n    return css(parse$1(abbr, config), config);\n}\n\nexport default expandAbbreviation;\nexport { extractAbbreviation as extract, markup, parse as parseMarkup, parse$1 as parseStylesheet, convertSnippets as parseStylesheetSnippets, resolveConfig, stringify as stringifyMarkup, css as stringifyStylesheet, stylesheet };\n//# sourceMappingURL=emmet.es.js.map\n","import type { EditorState } from '@codemirror/state';\nimport type { SyntaxNode } from '@lezer/common';\nimport type { RangeObject } from './types';\n\n/** Characters to indicate tab stop start and end in generated snippet */\nexport const tabStopStart = String.fromCodePoint(0xFFF0);\nexport const tabStopEnd = String.fromCodePoint(0xFFF1);\nexport const stateKey = '$$emmet';\n\nexport interface AbbrError {\n    message: string,\n    pos: number\n}\n\nexport type DisposeFn = () => void;\n\nexport interface EmmetState {\n    id: string;\n    tracker?: DisposeFn | null;\n    tagMatch?: DisposeFn | null;\n}\n\n/**\n * Returns copy of region which starts and ends at non-space character\n */\nexport function narrowToNonSpace(state: EditorState, range: RangeObject): RangeObject {\n\n    const text = substr(state, range);\n    let startOffset = 0;\n    let endOffset = text.length;\n\n    while (startOffset < endOffset && isSpace(text[startOffset])) {\n        startOffset++;\n    }\n\n    while (endOffset > startOffset && isSpace(text[endOffset - 1])) {\n        endOffset--;\n    }\n\n    return {\n        from: range.from + startOffset,\n        to: range.from + endOffset\n    };\n}\n\n/**\n * Returns current caret position for single selection\n */\nexport function getCaret(state: EditorState): number {\n    return state.selection.main.from;\n}\n\n/**\n * Returns contents of given range or node\n */\nexport function substr(state: EditorState, range: RangeObject): string {\n    return state.doc.sliceString(range.from, range.to);\n}\n\n/**\n * Check if given range or syntax name contains given position\n */\nexport function contains(range: RangeObject, pos: number): boolean {\n    return pos >= range.from && pos <= range.to;\n}\n\n/**\n * Returns range of full CSS declaration\n */\nexport function fullCSSDeclarationRange(node: SyntaxNode): RangeObject {\n    return {\n        from: node.from,\n        to: node.nextSibling?.name === ';' ? node.nextSibling.to : node.to\n    };\n}\n\nexport function isQuote(ch: string | undefined) {\n    return ch === '\"' || ch === \"'\";\n}\n\n/**\n * Returns own (unquoted) attribute value range\n */\nexport function getAttributeValueRange(state: EditorState, node: RangeObject): RangeObject {\n    let { from, to } = node;\n    const value = substr(state, node);\n    if (isQuote(value[0])) {\n        from++;\n    }\n\n    if (isQuote(value[value.length - 1])) {\n        to--;\n    }\n\n    return { from, to };\n}\n\n/**\n * Returns given HTML element’s attributes as map\n */\nexport function getTagAttributes(state: EditorState, node: SyntaxNode): Record<string, string | null> {\n    const result: Record<string, string | null> = {};\n    for (const attr of node.getChildren('Attribute')) {\n        const attrNameNode = attr.getChild('AttributeName');\n        if (attrNameNode) {\n            const attrName = substr(state, attrNameNode);\n            const attrValueNode = attr.getChild('AttributeValue');\n            result[attrName] = attrValueNode ? substr(state, getAttributeValueRange(state, attrValueNode)) : null;\n        }\n    }\n\n    return result;\n}\nexport function isSpace(ch: string): boolean {\n    return /^[\\s\\n\\r]+$/.test(ch);\n}\n\nexport function htmlEscape(str: string): string {\n    const replaceMap: Record<string, string> = {\n        '<': '&lt;',\n        '>': '&gt;',\n        '&': '&amp;',\n    };\n    return str.replace(/[<>&]/g, ch => replaceMap[ch]);\n}\n\n/**\n * Check if `a` and `b` contains the same range\n */\nexport function rangesEqual(a: RangeObject, b: RangeObject): boolean {\n    return a.from === b.from && a.to === b.to;\n}\n\n/**\n * Check if range `a` fully contains range `b`\n */\nexport function rangeContains(a: RangeObject, b: RangeObject): boolean {\n    return a.from <= b.from && a.to >= b.to;\n}\n\n/**\n * Check if given range is empty\n */\nexport function rangeEmpty(r: RangeObject): boolean {\n    return r.from === r.to;\n}\n\n/**\n * Returns last element in given array\n */\nexport function last<T>(arr: T[]): T | undefined {\n    return arr.length > 0 ? arr[arr.length - 1] : undefined;\n}\n\n/**\n * Finds and collects selections ranges from given snippet\n */\nexport function getSelectionsFromSnippet(snippet: string, base = 0): { ranges: RangeObject[], snippet: string } {\n    // Find and collect selection ranges from snippet\n    const ranges: RangeObject[] = [];\n    let result = '';\n    let sel: RangeObject | null = null;\n    let offset = 0;\n    let i = 0;\n    let ch: string;\n\n    while (i < snippet.length) {\n        ch = snippet.charAt(i++);\n        if (ch === tabStopStart || ch === tabStopEnd) {\n            result += snippet.slice(offset, i - 1);\n            offset = i;\n\n            if (ch === tabStopStart) {\n                sel = {\n                    from: base + result.length,\n                    to: base + result.length\n                };\n                ranges.push(sel);\n            } else if (sel) {\n                sel = null;\n            }\n        }\n    }\n\n    if (!ranges.length) {\n        ranges.push({\n            from: snippet.length + base,\n            to: snippet.length + base\n        });\n    }\n\n    return {\n        ranges,\n        snippet: result + snippet.slice(offset)\n    };\n}\n","import { syntaxTree } from '@codemirror/language';\nimport { cssLanguage } from '@codemirror/lang-css';\nimport { htmlLanguage } from '@codemirror/lang-html';\nimport type { EditorState } from '@codemirror/state';\nimport type { SyntaxNode } from '@lezer/common';\nimport type { CSSContext, CSSMatch, HTMLAncestor, HTMLContext, HTMLType, RangeObject } from './types';\nimport { contains, getAttributeValueRange, substr } from './utils';\n\n// TODO use RangeObject instead of TextRange\n\ninterface InlineProp {\n    name: RangeObject;\n    value?: RangeObject;\n}\n\nconst nodeToHTMLType: Record<string, HTMLType> = {\n    OpenTag: 'open',\n    CloseTag: 'close',\n    SelfClosingTag: 'selfClose'\n};\n\nexport function getContext(state: EditorState, pos: number): HTMLContext | CSSContext | undefined {\n    if (cssLanguage.isActiveAt(state, pos)) {\n        return getCSSContext(state, pos);\n    }\n\n    if (htmlLanguage.isActiveAt(state, pos)) {\n        return getHTMLContext(state, pos);\n    }\n\n    // const topLang = state.facet(language);\n    // if (topLang === htmlLanguage) {\n    //     // HTML syntax may embed CSS\n    //     return cssLanguage.isActiveAt(state, pos)\n    //         ? getCSSContext(state, pos)\n    //         : getHTMLContext(state, pos);\n    // }\n\n    // if (topLang === cssLanguage) {\n    //     return getCSSContext(state, pos);\n    // }\n\n    return;\n}\n\n/**\n * Returns CSS context for given location in source code\n */\nexport function getCSSContext(state: EditorState, pos: number, embedded?: RangeObject) {\n    const result: CSSContext = {\n        type: 'css',\n        ancestors: [],\n        current: null,\n        inline: false,\n        embedded\n    };\n\n    const tree = syntaxTree(state).resolveInner(pos, -1);\n    const stack: CSSMatch[] = [];\n\n    for (let node: SyntaxNode | null = tree; node; node = node.parent) {\n        if (node.name === 'RuleSet') {\n            const sel = getSelectorRange(node);\n            stack.push({\n                name: substr(state, sel),\n                type: 'selector',\n                range: node\n            });\n        } else if (node.name === 'Declaration') {\n            const { name, value } = getPropertyRanges(node);\n            if (value && contains(value, pos)) {\n                // Direct hit on CSS value\n                stack.push({\n                    name: substr(state, value),\n                    type: 'propertyValue',\n                    range: value\n                });\n            }\n\n            if (name) {\n                stack.push({\n                    name: substr(state, name),\n                    type: 'propertyName',\n                    range: name\n                });\n            }\n        }\n    }\n\n    const tip = stack.shift();\n\n    // Check if stack tip contains current position: make it current\n    // context item if so\n    if (tip) {\n        const range: RangeObject = tip.type === 'selector'\n            ? { from: tip.range.from, to: tip.range.from + tip.name.length }\n            : tip.range;\n        if (contains(range, pos)) {\n            result.current = tip;\n            tip.range = range;\n        } else {\n            stack.unshift(tip);\n        }\n    }\n\n    result.ancestors = stack.reverse()\n    return result;\n}\n\nexport function getHTMLContext(state: EditorState, pos: number): HTMLContext {\n    const result: HTMLContext = {\n        type: 'html',\n        ancestors: [],\n        current: null,\n    };\n\n    const tree = syntaxTree(state).resolveInner(pos);\n\n    for (let node: SyntaxNode | null = tree; node; node = node ? node.parent : null) {\n        if (node.name in nodeToHTMLType) {\n            const m = getContextMatchFromTag(state, node);\n            if (m) {\n                result.current = {\n                    ...m,\n                    type: nodeToHTMLType[node.name]\n                };\n\n                // Skip `Element` parent from ancestors stack\n                node = node.parent;\n            }\n        } else if (node.name === 'Element') {\n            const child = node.getChild('OpenTag');\n            if (child) {\n                const m = getContextMatchFromTag(state, child);\n                if (m) {\n                    result.ancestors.push(m);\n                }\n            }\n        }\n    }\n\n    result.ancestors.reverse();\n    detectCSSContextFromHTML(state, pos, result);\n    return result;\n}\n\nfunction detectCSSContextFromHTML(state: EditorState, pos: number, ctx: HTMLContext) {\n    if (ctx.current?.type === 'open') {\n        // Maybe inline CSS? E.g. style=\"...\" attribute\n        let node: SyntaxNode | null = syntaxTree(state).resolve(ctx.current.range.from, 1);\n        while (node && node.name !== 'OpenTag') {\n            node = node.parent;\n        }\n\n        if (node) {\n            for (const attr of node.getChildren('Attribute')) {\n                if (attr.from > pos) {\n                    break;\n                }\n\n                if (contains(attr, pos) && getAttributeName(state, attr) === 'style') {\n                    const attrValue = attr.getChild('AttributeValue');\n                    if (attrValue) {\n                        const cleanValueRange = getAttributeValueRange(state, attrValue);\n                        if (contains(cleanValueRange, pos)) {\n                            ctx.css = getInlineCSSContext(substr(state, cleanValueRange), pos - cleanValueRange.from, cleanValueRange.from);\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nfunction getContextMatchFromTag(state: EditorState, node: SyntaxNode): HTMLAncestor | void {\n    const tagName = node.getChild('TagName');\n    if (tagName) {\n        return {\n            name: substr(state, tagName).toLowerCase(),\n            range: node\n        };\n    }\n}\n\n/**\n * Returns range of CSS selector from given rule block\n */\nexport function getSelectorRange(node: SyntaxNode): RangeObject {\n    let from = node.from;\n    let to = from;\n    for (let child = node.firstChild; child && child.name !== 'Block'; child = child.nextSibling) {\n        to = child.to;\n    }\n\n    return { from, to };\n}\n\n/**\n * Returns CSS property name and value ranges.\n * @param node The `name: Declaration` node\n */\nexport function getPropertyRanges(node: SyntaxNode): { name: RangeObject | undefined, value: RangeObject | undefined } {\n    let name: RangeObject | undefined;\n    let value: RangeObject | undefined;\n    let ptr = node.firstChild;\n    if (ptr?.name === 'PropertyName') {\n        name = ptr;\n        ptr = ptr.nextSibling;\n        if (ptr?.name === ':') {\n            ptr = ptr.nextSibling;\n        }\n\n        if (ptr) {\n            value = {\n                from: ptr.from,\n                to: node.lastChild!.to\n            };\n        }\n    }\n\n    return { name, value };\n}\n\nfunction getAttributeName(state: EditorState, node: SyntaxNode): string {\n    const name = node.getChild('AttributeName');\n    return name ? substr(state, name).toLowerCase() : '';\n}\n\n/**\n * Returns context for inline CSS\n */\nexport function getInlineCSSContext(code: string, pos: number, base = 0): CSSContext {\n    // Currently, CodeMirror doesn’t provide syntax highlighting so we’ll perform\n    // quick and naive persing of CSS properties\n    const result: CSSContext = {\n        type: 'css',\n        ancestors: [],\n        current: null,\n        inline: true,\n        embedded: {\n            from: pos + base,\n            to: pos + base + code.length\n        }\n    };\n\n    const props = parseInlineProps(code, pos);\n\n    for (const prop of props) {\n        if (prop.value && contains(prop.value, pos)) {\n            result.current = {\n                name: code.substring(prop.value.from, prop.value.to).trim(),\n                type: 'propertyValue',\n                range: {\n                    from: base + prop.value.from,\n                    to: base + prop.value.to\n                }\n            };\n            result.ancestors.push({\n                name: code.substring(prop.name.from, prop.name.to).trim(),\n                type: 'propertyName',\n                range: {\n                    from: base + prop.name.from,\n                    to: base + prop.value.to\n                }\n            });\n            break;\n        } else if (contains(prop.name, pos)) {\n            const end = prop.value ? prop.value.to : prop.name.to;\n            result.current = {\n                name: code.substring(prop.name.from, prop.name.to).trim(),\n                type: 'propertyName',\n                range: {\n                    from: base + prop.name.from,\n                    to: base + end\n                }\n            };\n            break;\n        }\n    }\n\n    return result;\n}\n\nexport function parseInlineProps(code: string, limit = code.length): InlineProp[] {\n    const space = ' \\t\\n\\r';\n    const propList: InlineProp[] = [];\n    let prop: InlineProp | undefined;\n\n    for (let i = 0; i < code.length; i++) {\n        const ch = code[i];\n        if (prop) {\n            if (prop.value) {\n                if (prop.value.from !== -1) {\n                    prop.value.to = i;\n                }\n            } else {\n                prop.name.to = i;\n            }\n        }\n\n        if (ch === ';') {\n            prop = undefined;\n            if (i > limit) {\n                break;\n            }\n        } else if (ch === ':') {\n            if (prop && !prop.value) {\n                prop.value = { from: -1, to: -1 };\n            }\n        } else {\n            if (prop) {\n                if (prop.value?.from === -1 && !space.includes(ch)) {\n                    prop.value.from = prop.value.to = i;\n                }\n            } else if (!space.includes(ch)) {\n                prop = {\n                    name: { from: i, to: i }\n                };\n                propList.push(prop);\n            }\n        }\n    }\n\n    // Finalize state for trailing character\n    if (prop) {\n        if (prop.value) {\n            prop.value.to++;\n        } else {\n            prop.name.to++;\n        }\n    }\n\n    return propList;\n}\n","import type { SyntaxType, AbbreviationContext } from 'emmet';\nimport type { EditorState } from '@codemirror/state';\nimport { language, syntaxTree } from '@codemirror/language';\nimport { cssLanguage } from '@codemirror/lang-css';\nimport { htmlLanguage } from '@codemirror/lang-html';\nimport type { SyntaxNode } from '@lezer/common';\nimport { getContext } from './context';\nimport type { HTMLContext, CSSContext } from './types';\nimport { last, getTagAttributes } from './utils';\n\nconst xmlSyntaxes = ['xml', 'xsl', 'jsx'];\nconst htmlSyntaxes = ['html', 'htmlmixed', 'vue'];\nconst cssSyntaxes = ['css', 'scss', 'less'];\nconst jsxSyntaxes = ['jsx', 'tsx'];\nconst markupSyntaxes = ['haml', 'jade', 'pug', 'slim'].concat(htmlSyntaxes, xmlSyntaxes, jsxSyntaxes);\nconst stylesheetSyntaxes = ['sass', 'sss', 'stylus', 'postcss'].concat(cssSyntaxes);\n\nexport interface SyntaxInfo {\n    type: SyntaxType;\n    syntax?: string;\n    inline?: boolean;\n    context?: HTMLContext | CSSContext;\n}\n\nexport interface StylesheetRegion {\n    range: [number, number];\n    syntax: string;\n    inline?: boolean;\n}\n\nexport interface SyntaxCache {\n    stylesheetRegions?: StylesheetRegion[];\n}\n\nconst enum TokenType {\n    Selector = \"selector\",\n    PropertyName = \"propertyName\",\n    PropertyValue = \"propertyValue\",\n    BlockEnd = \"blockEnd\"\n}\n\nconst enum CSSAbbreviationScope {\n    /** Include all possible snippets in match */\n    Global = \"@@global\",\n    /** Include raw snippets only (e.g. no properties) in abbreviation match */\n    Section = \"@@section\",\n    /** Include properties only in abbreviation match */\n    Property = \"@@property\",\n    /** Resolve abbreviation in context of CSS property value */\n    Value = \"@@value\"\n}\n\n/**\n * Returns Emmet syntax info for given location in view.\n * Syntax info is an abbreviation type (either 'markup' or 'stylesheet') and syntax\n * name, which is used to apply syntax-specific options for output.\n *\n * By default, if given location doesn’t match any known context, this method\n * returns `null`, but if `fallback` argument is provided, it returns data for\n * given fallback syntax\n */\nexport function syntaxInfo(state: EditorState, ctx?: number | HTMLContext | CSSContext): SyntaxInfo {\n    let syntax = docSyntax(state);\n    let inline: boolean | undefined;\n    let context = typeof ctx === 'number' ? getContext(state, ctx) : ctx;\n\n    if (context?.type === 'html' && context.css) {\n        inline = true;\n        syntax = 'css';\n        context = context.css;\n    } else if (context?.type === 'css') {\n        syntax = 'css';\n    }\n\n    return {\n        type: getSyntaxType(syntax),\n        syntax,\n        inline,\n        context\n    };\n}\n\n/**\n * Returns main editor syntax\n */\nexport function docSyntax(state: EditorState): string {\n    const topLang = state.facet(language);\n    if (topLang === cssLanguage) {\n        return 'css';\n    }\n\n    if (topLang === htmlLanguage) {\n        return 'html';\n    }\n    return '';\n}\n\n/**\n * Returns Emmet abbreviation type for given syntax\n */\nexport function getSyntaxType(syntax?: string): SyntaxType {\n    return syntax && stylesheetSyntaxes.includes(syntax) ? 'stylesheet' : 'markup';\n}\n\n/**\n * Check if given syntax is XML dialect\n */\nexport function isXML(syntax?: string): boolean {\n    return syntax ? xmlSyntaxes.includes(syntax) : false;\n}\n\n/**\n * Check if given syntax is HTML dialect (including XML)\n */\nexport function isHTML(syntax?: string): boolean {\n    return syntax\n        ? htmlSyntaxes.includes(syntax) || isXML(syntax)\n        : false;\n}\n\n/**\n * Check if given syntax name is supported by Emmet\n */\nexport function isSupported(syntax: string): boolean {\n    return syntax\n        ? markupSyntaxes.includes(syntax) || stylesheetSyntaxes.includes(syntax)\n        : false;\n}\n\n/**\n * Check if given syntax is a CSS dialect. Note that it’s not the same as stylesheet\n * syntax: for example, SASS is a stylesheet but not CSS dialect (but SCSS is)\n */\nexport function isCSS(syntax?: string): boolean {\n    return syntax ? cssSyntaxes.includes(syntax) : false;\n}\n\n/**\n * Check if given syntax is JSX dialect\n */\nexport function isJSX(syntax?: string): boolean {\n    return syntax ? jsxSyntaxes.includes(syntax) : false;\n}\n\n/**\n * Returns context for Emmet abbreviation from given HTML context\n */\nexport function getMarkupAbbreviationContext(state: EditorState, ctx: HTMLContext): AbbreviationContext | undefined {\n    const parent = last(ctx.ancestors);\n    if (parent) {\n        let node: SyntaxNode | null = syntaxTree(state).resolve(parent.range.from, 1);\n        while (node && node.name !== 'OpenTag') {\n            node = node.parent;\n        }\n\n        return {\n            name: parent.name,\n            attributes: node ? getTagAttributes(state, node) : {}\n        };\n    }\n\n    return;\n}\n\n/**\n * Returns context for Emmet abbreviation from given CSS context\n */\nexport function getStylesheetAbbreviationContext(ctx: CSSContext): AbbreviationContext {\n    if (ctx.inline) {\n        return { name: CSSAbbreviationScope.Property }\n    }\n\n    const parent = last(ctx.ancestors);\n    let scope: string = CSSAbbreviationScope.Global;\n    if (ctx.current) {\n        if (ctx.current.type === TokenType.PropertyValue && parent) {\n            scope = parent.name;\n        } else if ((ctx.current.type === TokenType.Selector || ctx.current.type === TokenType.PropertyName) && !parent) {\n            scope = CSSAbbreviationScope.Section;\n        }\n    } else if (!parent) {\n        scope = CSSAbbreviationScope.Section;\n    }\n\n    return {\n        name: scope\n    };\n}\n","import type { EditorState } from '@codemirror/state';\nimport { syntaxTree } from '@codemirror/language';\nimport type { SyntaxNode } from '@lezer/common';\nimport expandAbbreviation, { extract as extractAbbreviation, resolveConfig } from 'emmet';\nimport type { UserConfig, AbbreviationContext, ExtractedAbbreviation, Options, ExtractOptions, MarkupAbbreviation, StylesheetAbbreviation, SyntaxType } from 'emmet';\nimport { syntaxInfo, getMarkupAbbreviationContext, getStylesheetAbbreviationContext } from './syntax';\nimport { getTagAttributes, substr } from './utils';\nimport getEmmetConfig from './config';\nimport getOutputOptions, { field } from './output';\nimport type { ContextTag } from './types';\n\nexport interface ExtractedAbbreviationWithContext extends ExtractedAbbreviation {\n    context?: AbbreviationContext;\n    inline?: boolean;\n}\n\n/**\n * Cache for storing internal Emmet data.\n * TODO reset whenever user settings are changed\n */\nlet cache = {};\n\nexport const JSX_PREFIX = '<';\n\n/**\n * Expands given abbreviation into code snippet\n */\nexport function expand(state: EditorState, abbr: string | MarkupAbbreviation | StylesheetAbbreviation, config?: UserConfig) {\n    let opt: UserConfig = { cache };\n    const outputOpt: Partial<Options> = {\n        'output.field': field,\n    };\n\n    if (config) {\n        Object.assign(opt, config);\n        if (config.options) {\n            Object.assign(outputOpt, config.options);\n        }\n    }\n\n    opt.options = outputOpt;\n\n    const pluginConfig = getEmmetConfig(state);\n    if (pluginConfig.config) {\n        opt = resolveConfig(opt, pluginConfig.config);\n    }\n\n    return expandAbbreviation(abbr as string, opt);\n}\n\n/**\n * Extracts abbreviation from given source code by detecting actual syntax context.\n * For example, if host syntax is HTML, it tries to detect if location is inside\n * embedded CSS.\n *\n * It also detects if abbreviation is allowed at given location: HTML tags,\n * CSS selectors may not contain abbreviations.\n * @param code Code from which abbreviation should be extracted\n * @param pos Location at which abbreviation should be expanded\n * @param type Syntax of abbreviation to expand\n */\nexport function extract(code: string, pos: number, type: SyntaxType = 'markup', options?: Partial<ExtractOptions>): ExtractedAbbreviation | undefined {\n    return extractAbbreviation(code, pos, {\n        lookAhead: type !== 'stylesheet',\n        type,\n        ...options\n    });\n}\n\n/**\n * Returns matched HTML/XML tag for given point in view\n */\nexport function getTagContext(state: EditorState, pos: number): ContextTag | undefined {\n    let element: SyntaxNode | null = syntaxTree(state).resolve(pos, 1);\n    while (element && element.name !== 'Element') {\n        element = element.parent;\n    }\n\n    if (element) {\n        const selfClose = element.getChild('SelfClosingTag');\n        if (selfClose) {\n            return {\n                name: getTagName(state, selfClose),\n                attributes: getTagAttributes(state, selfClose),\n                open: selfClose\n            }\n        }\n\n        const openTag = element.getChild('OpenTag');\n        if (openTag) {\n            const closeTag = element.getChild('CloseTag');\n            const ctx: ContextTag = {\n                name: getTagName(state, openTag),\n                attributes: getTagAttributes(state, openTag),\n                open: openTag,\n            };\n\n            if (closeTag) {\n                ctx.close = closeTag;\n            }\n\n            return ctx;\n        }\n    }\n\n    return;\n}\n\nexport function getTagName(state: EditorState, node: SyntaxNode): string {\n    const tagName = node.getChild('TagName');\n    return tagName ? substr(state, tagName) : '';\n}\n\n/**\n * Returns Emmet options for given character location in editor\n */\nexport function getOptions(state: EditorState, pos: number): UserConfig {\n    const info = syntaxInfo(state, pos);\n    const { context } = info;\n\n    const config: UserConfig = {\n        type: info.type,\n        syntax: info.syntax || 'html',\n        options: getOutputOptions(state, info.inline)\n    };\n\n    if (context) {\n        // Set context from syntax info\n        if (context.type === 'html' && context.ancestors.length) {\n            config.context = getMarkupAbbreviationContext(state, context);\n        } else if (context.type === 'css') {\n            config.context = getStylesheetAbbreviationContext(context);\n        }\n    }\n\n    return config;\n}\n\nexport function resetCache() {\n    cache = {};\n}\n","import type { GlobalConfig } from 'emmet';\nimport { EditorState, Extension, Facet } from '@codemirror/state';\nimport { resetCache } from './emmet';\n\nexport interface EmmetEditorOptions {\n    emmet: EmmetConfig;\n}\n\nexport type EnableForSyntax = boolean | string[];\nexport type PreviewExtensions = () => Extension;\n\nexport interface EmmetPreviewConfig {\n    /** Extensions factory for displaying HTML-like abbreviation preview  */\n    html?: PreviewExtensions;\n    /** Extensions factory for displaying CSS-like abbreviation preview  */\n    css?: PreviewExtensions;\n}\n\nexport interface EmmetConfig {\n    /** Enables abbreviation marking in editor. Works in known syntaxes only */\n    mark: EnableForSyntax;\n\n    /**\n     * Config for proview popup\n     */\n    preview: EmmetPreviewConfig;\n\n    /**\n     * Enables preview of marked abbreviation. Pass `true` to enable preview for\n     * all syntaxes or array of modes or Emmet syntax types (`markup` or `stylesheet`)\n     * where preview should be displayed\n     */\n    previewEnabled: EnableForSyntax;\n\n    /** Mark HTML tag pairs in editor */\n    markTagPairs: boolean;\n\n    /**\n     * Displays open tag preview when caret is inside its matching closing tag.\n     * Preview is displayed only if open tag has attributes.\n     * Works only if `markTagPairs` is enabled\n     */\n    previewOpenTag: boolean;\n\n    /** Allow automatic tag pair rename, works only if `markTagPairs` is enabled */\n    autoRenameTags: boolean;\n\n    /** Quotes to use in generated HTML attribute values */\n    attributeQuotes: 'single' | 'double';\n\n    /** Style for self-closing elements (like `<br>`) and boolean attributes */\n    markupStyle: 'html' | 'xhtml' | 'xml',\n\n    /**\n     * Enable automatic tag commenting. When enabled, elements generated from Emmet\n     * abbreviation with `id` and/or `class` attributes will receive a comment\n     * with these attribute values\n     */\n    comments: boolean;\n\n    /**\n     * Commenting template. Default value is `\\n<!-- /[#ID][.CLASS] -->`\n     * Outputs everything between `[` and `]` only if specified attribute name\n     * (written in UPPERCASE) exists in element. Attribute name is replaced with\n     * actual value. Use `\\n` to add a newline.\n     */\n    commentsTemplate?: string;\n\n    /**\n     * Enable BEM support. When enabled, Emmet will treat class names starting\n     * with `-` as _element_ and with `_` as _modifier_ in BEM notation.\n     * These class names will inherit `block` name from current or ancestor element.\n     * For example, the abbreviation `ul.nav.nav_secondary>li.nav__item` can be\n     * shortened to `ul.nav._secondary>li.-item` with this option enabled.\n     */\n    bem: boolean;\n\n    /**\n     * For stylesheet abbreviations, generate short HEX color values, if possible.\n     * For example, `c#0` will be expanded to `color: #000;` instead of `color: #000000`.\n     */\n    shortHex?: boolean;\n\n    /** Advanced Emmet config */\n    config?: GlobalConfig;\n\n    /**\n     * A `boost` option for CodeMirror completions\n     */\n    completionBoost?: number;\n\n    /**\n     * Function for attaching abbreviation preview\n     */\n    // attachPreview?: (editor: CodeMirror.Editor, preview: HTMLElement, pos: CodeMirror.Position) => void;\n}\n\nexport const defaultConfig: EmmetConfig = {\n    mark: true,\n    preview: { },\n    previewEnabled: true,\n    autoRenameTags: true,\n    markTagPairs: true,\n    previewOpenTag: false,\n    attributeQuotes: 'double',\n    markupStyle: 'html',\n    comments: false,\n    commentsTemplate: '<!-- /[#ID][.CLASS] -->',\n    bem: false,\n    completionBoost: 99\n};\n\nexport const config = Facet.define<Partial<EmmetConfig>, EmmetConfig>({\n    combine(value) {\n        resetCache();\n        const baseConfig: EmmetConfig = { ...defaultConfig };\n        const { preview } = baseConfig;\n        for (const item of value) {\n            Object.assign(baseConfig, item);\n            if (item.preview) {\n                baseConfig.preview = {\n                    ...preview,\n                    ...item.preview\n                };\n            }\n        }\n\n        return baseConfig;\n    }\n});\n\nexport default function getEmmetConfig(state: EditorState, opt?: Partial<EmmetConfig>): EmmetConfig {\n    let conf = state.facet(config);\n    if (opt) {\n        conf = { ...conf, ...opt };\n    }\n\n    return conf;\n}\n","import type { Options } from 'emmet';\nimport type { EditorState, Line } from '@codemirror/state';\nimport getEmmetConfig from './config';\nimport { isHTML, docSyntax } from './syntax';\n\nexport default function getOutputOptions(state: EditorState, inline?: boolean): Partial<Options> {\n    const syntax = docSyntax(state) || 'html';\n    const config = getEmmetConfig(state);\n\n    const opt: Partial<Options> = {\n        // 'output.baseIndent': lineIndent(state.doc.lineAt(pos)),\n        // 'output.indent': getIndentation(state),\n        'output.field': field,\n        'output.indent': '\\t',\n        'output.format': !inline,\n        'output.attributeQuotes': config.attributeQuotes,\n        'stylesheet.shortHex': config.shortHex\n    };\n\n    if (syntax === 'html') {\n        opt['output.selfClosingStyle'] = config.markupStyle;\n        opt['output.compactBoolean'] = config.markupStyle === 'html';\n    }\n\n    if (isHTML(syntax)) {\n        if (config.comments) {\n            opt['comment.enabled'] = true;\n            if (config.commentsTemplate) {\n                opt['comment.after'] = config.commentsTemplate;\n            }\n        }\n\n        opt['bem.enabled'] = config.bem;\n    }\n\n    return opt;\n}\n\n/**\n * Produces tabstop for CodeMirror editor\n */\nexport function field(index: number, placeholder?: string) {\n    return placeholder ? `\\${${index}:${placeholder}}` : `\\${${index}}`;\n}\n\n/**\n * Returns indentation of given line\n */\nexport function lineIndent(line: Line): string {\n    const indent = line.text.match(/^\\s+/);\n    return indent ? indent[0] : '';\n}\n\n/**\n * Returns token used for single indentation in given editor\n */\nexport function getIndentation(state: EditorState): string {\n    const { tabSize } = state;\n    return tabSize ? ' '.repeat(tabSize) : '\\t';\n}\n","import { EditorView } from 'codemirror';\nimport { EditorState } from '@codemirror/state';\nimport { syntaxHighlighting, defaultHighlightStyle } from '@codemirror/language';\nimport { html } from '@codemirror/lang-html';\nimport { css } from '@codemirror/lang-css';\nimport type { EmmetPreviewConfig, PreviewExtensions } from '../lib/config';\n\nexport interface HTMLElementPreview extends HTMLElement {\n    update?: (value: string) => void;\n}\n\nexport function createPreview(value: string, syntax: string, options?: EmmetPreviewConfig): HTMLElementPreview {\n    const elem = document.createElement('div') as HTMLElementPreview;\n    elem.className = 'emmet-preview';\n    if (syntax === 'error') {\n        elem.classList.add('emmet-preview_error');\n    }\n\n    let ext: PreviewExtensions = syntax === 'css' ? css : html;\n    if (options && syntax in options) {\n        ext = options[syntax as keyof EmmetPreviewConfig]!;\n    }\n\n    const view = new EditorView({\n        doc: value,\n        extensions: [\n            EditorState.readOnly.of(true),\n            syntaxHighlighting(defaultHighlightStyle, { fallback: true }),\n            syntax === 'css' ? css() : html(),\n            ext()\n        ],\n        parent: elem\n    });\n\n    elem.update = (nextValue) => {\n        const tr = view.state.update({\n            changes: {\n                from: 0,\n                to: view.state.doc.length,\n                insert: nextValue\n            }\n        });\n        view.dispatch(tr);\n    };\n\n    return elem;\n}\n","export default \"data:image/svg+xml;base64,PHN2ZyBoZWlnaHQ9IjM5MyIgdmlld0JveD0iMCAwIDM5MyAzOTMiIHdpZHRoPSIzOTMiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6eGxpbms9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsiPjxkZWZzPjxsaW5lYXJHcmFkaWVudCBpZD0iYSIgeDE9Ijk4LjYwODY5JSIgeDI9IjUwJSIgeTE9IjUwJSIgeTI9IjUwJSI+PHN0b3Agb2Zmc2V0PSIwIiBzdG9wLWNvbG9yPSIjY2VmYmFkIi8+PHN0b3Agb2Zmc2V0PSIuODM2OTcyNTM1IiBzdG9wLWNvbG9yPSIjY2VmYmFkIi8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLW9wYWNpdHk9IjAiLz48L2xpbmVhckdyYWRpZW50PjxwYXRoIGlkPSJiIiBkPSJtMTE2IDQ4IDEwNSA2M3YzNC45ODVsLTc1LTQ0Ljk5OTI4OXY2Ny42NjcyODlsNDkuNSAyOS4zNDctNDkuNSAyOS4zNDZ2NjcuNjY4Mjg5bDc1LTQ1LjAwMDI4OXYzNC45ODZsLTEwNSA2M3ptMTQ1IDg3IDEwNSA2My0xMDUgNjN2LTM0Ljk4Nmw0Ni42OTA0ODEtMjguMDE0LTQ2LjY5MDQ4MS0yOC4wMTR6Ii8+PC9kZWZzPjxnIGZpbGw9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCIgdHJhbnNmb3JtPSJtYXRyaXgoLjcwNzEwNjc4IC0uNzA3MTA2NzggLjcwNzEwNjc4IC43MDcxMDY3OCAtODEuMzkyOTY1IDE5Ni41KSI+PGNpcmNsZSBjeD0iMTk2LjUiIGN5PSIxOTYuNSIgZmlsbD0iIzI1MjcyYiIgcj0iMTk2LjUiLz48dXNlIGZpbGw9IiM5MmMxMzEiIHhsaW5rOmhyZWY9IiNiIi8+PHVzZSBmaWxsPSJ1cmwoI2EpIiB4bGluazpocmVmPSIjYiIvPjwvZz48L3N2Zz4=\"","import type { MarkupAbbreviation, StylesheetAbbreviation, UserConfig } from 'emmet';\nimport { markupAbbreviation } from 'emmet';\nimport { ViewPlugin, Decoration, keymap, EditorView, type Tooltip, showTooltip } from '@codemirror/view';\nimport type { DecorationSet, Command, ViewUpdate } from '@codemirror/view';\nimport { StateEffect, StateField } from '@codemirror/state';\nimport type { Range, EditorState, Extension, StateCommand, Transaction } from '@codemirror/state';\nimport { htmlLanguage } from '@codemirror/lang-html';\nimport { cssLanguage } from '@codemirror/lang-css';\nimport { snippet, pickedCompletion, completionStatus, type CompletionResult, type Completion } from '@codemirror/autocomplete';\nimport type { CompletionSource } from '@codemirror/autocomplete';\nimport { getCSSContext, getHTMLContext } from '../lib/context';\nimport { docSyntax, getMarkupAbbreviationContext, getStylesheetAbbreviationContext, getSyntaxType, isCSS, isHTML, isJSX, isSupported } from '../lib/syntax';\nimport getOutputOptions from '../lib/output';\nimport type { CSSContext, AbbreviationError, StartTrackingParams, RangeObject } from '../lib/types';\nimport { contains, getCaret, rangeEmpty, substr } from '../lib/utils';\nimport { expand } from '../lib/emmet';\nimport { type HTMLElementPreview, createPreview } from './AbbreviationPreviewWidget';\nimport icon from '../completion-icon.svg';\nimport getEmmetConfig, { config, EmmetPreviewConfig, type EmmetConfig } from '../lib/config';\n\ninterface EmmetCompletion extends Completion {\n    tracker: AbbreviationTrackerValid;\n    previewConfig: EmmetPreviewConfig;\n    preview?: HTMLElementPreview;\n}\n\ninterface EmmetTooltip extends Tooltip {\n    tracker: AbbreviationTracker;\n}\n\ntype AbbreviationTracker = AbbreviationTrackerValid | AbbreviationTrackerError;\n\n/// CSS property and value keyword completion source.\n// Проблема мигающего автокомплита в том, что он становится ActiveSource,\n// а не ActiveResult, из-за этого помечется как Pending и не обновляется на первый\n// проход.\n// Текущая реализация укладывается в нужную концепцию,\n// но проверка автокомплита обрабатывается раньше, чем обновляется трэкер.\n// Нужно найти способ обновить трэкер раньше, чем отработает код автокомплита\nexport const emmetCompletionSource: CompletionSource = context => {\n    const tracker = context.state.field(trackerField);\n    if (tracker?.type === 'abbreviation' && tracker.preview) {\n        return {\n            from: tracker.range.from,\n            to: tracker.range.to,\n            filter: false,\n            update(current, _from, _to, context) {\n                const tracker = context.state.field(trackerField);\n                if (!tracker || tracker.type === 'error') {\n                    return null;\n                }\n\n                return {\n                    ...current,\n                    from: tracker.range.from,\n                    to: tracker.range.to,\n                    options: completionOptionsFromTracker(context.state, tracker)\n                };\n            },\n            options: completionOptionsFromTracker(context.state, tracker)\n        } as CompletionResult;\n    }\n\n    return null;\n}\n\nconst cssCompletion: Extension = cssLanguage.data.of({ autocomplete: emmetCompletionSource });\n\ninterface AbbreviationTrackerBase {\n    /** Range in editor for abbreviation */\n    range: RangeObject;\n\n    /** Actual abbreviation, tracked by current tracker */\n    abbreviation: string;\n\n    /**\n     * Abbreviation was forced, e.g. must remain in editor even if empty or contains\n     * invalid abbreviation\n     */\n    forced: boolean;\n\n    /** Indicates that current tracker shouldn’t be displayed in editor */\n    inactive: boolean;\n\n    /**\n     * Relative offset from range start where actual abbreviation starts.\n     * Used tp handle prefixes in abbreviation\n     */\n    offset: number;\n\n    config: UserConfig;\n}\n\nexport interface AbbreviationTrackerValid extends AbbreviationTrackerBase {\n    type: 'abbreviation';\n\n    /**\n     * Abbreviation is simple, e.g. contains single element.\n     * It’s suggested to not display preview for simple abbreviation\n     */\n    simple: boolean;\n\n    /** Preview of expanded abbreviation */\n    preview: string;\n}\n\nexport interface AbbreviationTrackerError extends AbbreviationTrackerBase {\n    type: 'error';\n    error: AbbreviationError;\n}\n\nexport const JSX_PREFIX = '<';\n\nconst trackerMark = Decoration.mark({ class: 'emmet-tracker' });\n\nconst resetTracker = StateEffect.define();\nconst forceTracker = StateEffect.define();\n\nexport const enterAbbreviationMode: StateCommand = ({ state, dispatch }) => {\n    const tr = state.update({\n        effects: [forceTracker.of(null)]\n    });\n    dispatch(tr);\n    return true;\n};\n\nconst trackerField = StateField.define<AbbreviationTracker | null>({\n    create: () => null,\n    update(value, tr) {\n        const hasCompletion = tr.annotation(pickedCompletion);\n        if (hasCompletion) {\n            // When completion is applied, always reset tracker\n            return null;\n        }\n\n        for (const effect of tr.effects) {\n            if (effect.is(resetTracker)) {\n                return null;\n            }\n\n            if (effect.is(forceTracker)) {\n                const sel = tr.newSelection.main;\n                const config = getActivationContext(tr.state, sel.from);\n                if (config) {\n                    return createTracker(tr.state, sel, {\n                        forced: true,\n                        config\n                    });\n                }\n            }\n        }\n\n        if (!tr.docChanged) {\n            return value;\n        }\n        return handleUpdate(tr.state, value, tr);\n    }\n});\n\nconst abbreviationPreview = StateField.define<EmmetTooltip | null>({\n    create: getAbbreviationPreview,\n    update(tooltip, tr) {\n        if (!tr.docChanged && !tr.selection) {\n            const tracker = tr.state.field(trackerField);\n            return tracker ? tooltip : null;\n        }\n        return getAbbreviationPreview(tr.state, tooltip);\n    },\n    provide: f => showTooltip.from(f)\n});\n\nfunction getAbbreviationPreview(state: EditorState, prevTooltip?: EmmetTooltip | null): EmmetTooltip | null {\n    const tracker = state.field(trackerField);\n\n    if (tracker && !tracker.inactive && completionStatus(state) !== 'active') {\n        if (tracker.config.type === 'stylesheet') {\n            // Do not display preview for CSS since completions are populated\n            // automatically for this syntax and abbreviation will be a part of\n            // completion list\n            return null;\n        }\n\n        if (prevTooltip && prevTooltip.tracker.type !== tracker.type) {\n            prevTooltip = null;\n        }\n\n        const { range } = tracker;\n\n        if (canDisplayPreview(state, tracker)) {\n            return prevTooltip || {\n                pos: range.from,\n                above: false,\n                arrow: false,\n                tracker,\n                create() {\n                    const previewConfig = state.facet(config).preview;\n                    let preview = '';\n                    let syntax = '';\n\n                    if (tracker.type === 'error') {\n                        preview = tracker.error.message;\n                        syntax = 'error';\n                    } else {\n                        preview = tracker.preview;\n                        syntax = tracker.config.syntax || 'html';\n                    }\n\n                    const dom = createPreview(preview, syntax, previewConfig);\n                    return {\n                        dom,\n                        update({ state }) {\n                            const tracker = state.field(trackerField);\n                            if (tracker && dom.update) {\n                                const value = tracker.type === 'error'\n                                    ? tracker.error.message\n                                    : tracker.preview;\n                                dom.update(value);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return null;\n}\n\nconst abbreviationTracker = ViewPlugin.fromClass(class {\n    decorations: DecorationSet;\n\n    constructor() {\n        this.decorations = Decoration.none;\n    }\n\n    update(update: ViewUpdate) {\n        const { state } = update;\n\n        const tracker = state.field(trackerField);\n        const decors: Range<Decoration>[] = [];\n\n        if (tracker && !tracker.inactive) {\n            const { range } = tracker;\n\n            if (!rangeEmpty(range) ) {\n                decors.push(trackerMark.range(range.from, range.to));\n            }\n            this.decorations = Decoration.set(decors, true);\n        } else {\n            this.decorations = Decoration.none;\n        }\n    }\n}, {\n    decorations: v => v.decorations,\n});\n\nexport function expandTracker(view: EditorView, tracker: AbbreviationTracker): void {\n    const { from, to } = tracker.range;\n    const expanded = expand(view.state, tracker.abbreviation, tracker.config);\n    const fn = snippet(expanded);\n\n    view.dispatch(view.state.update({\n        effects: resetTracker.of(null)\n    }));\n    fn(view, { label: 'expand' }, from, to);\n}\n\nconst tabKeyHandler: Command = (view) => {\n    const { state } = view;\n    if (completionStatus(state)) {\n        // Must be handled by `acceptCompletion` command\n        return false;\n    }\n\n    const tracker = state.field(trackerField, false);\n    if (tracker && !tracker.inactive && contains(tracker.range, getCaret(state))) {\n        expandTracker(view, tracker);\n        return true;\n    }\n    return false;\n};\n\nconst escKeyHandler: Command = ({ state, dispatch }) => {\n    const tracker = state.field(trackerField, false);\n    if (tracker) {\n        dispatch({\n            effects: resetTracker.of(null)\n        });\n        return true;\n    }\n\n    return false;\n};\n\nconst trackerTheme = EditorView.baseTheme({\n    '.emmet-tracker': {\n        textDecoration: 'underline 1px green',\n    },\n    '.emmet-preview': {\n        fontSize: '0.9em'\n    },\n    '.emmet-preview_error': {\n        color: 'red'\n    },\n    '.cm-completionIcon-emmet::after': {\n        content: '\" \"',\n        background: `url(\"${icon}\") center/contain no-repeat`,\n        display: 'inline-block',\n        width: '11px',\n        height: '11px',\n        verticalAlign: 'middle'\n    }\n});\n\n/**\n * A factory function that creates abbreviation tracker for known syntaxes.\n * When user starts typing, it detects whether user writes abbreviation and\n * if so, starts tracking by displaying an underline. Then if user hit Tab key\n * when cursor is inside tracked abbreviation, it will expand it. Or user can\n * press Escape key to reset tracker\n */\nexport default function tracker(options?: Partial<EmmetConfig>): Extension[] {\n    return [\n        trackerField,\n        abbreviationTracker,\n        abbreviationPreview,\n        trackerTheme,\n        cssCompletion,\n        options ? config.of(options) : [],\n        keymap.of([{\n            key: 'Tab',\n            run: tabKeyHandler\n        }, {\n            key: 'Escape',\n            run: escKeyHandler\n        }])\n    ]\n}\n\nexport { resetTracker as trackerResetAction }\n\n/**\n * Check if abbreviation tracking is allowed in editor at given location\n */\nexport function allowTracking(state: EditorState): boolean {\n    return isSupported(docSyntax(state));\n}\n\n/**\n * Detects if user is typing abbreviation at given location\n * @param pos Location where user started typing\n * @param input Text entered at `pos` location\n */\nfunction typingAbbreviation(state: EditorState, pos: number, input: string): AbbreviationTracker | null {\n    if (input.length !== 1) {\n        // Expect single character enter to start abbreviation tracking\n        return null;\n    }\n\n    // Start tracking only if user starts abbreviation typing: entered first\n    // character at the word bound\n    const line = state.doc.lineAt(pos);\n    const prefix = line.text.substring(Math.max(0, pos - line.from - 1), pos - line.from);\n\n    // Check if current syntax is supported for tracking\n    if (!canStartTyping(prefix, input, getSyntaxFromPos(state, pos))) {\n        return null;\n    }\n\n    const config = getActivationContext(state, pos);\n    if (!config) {\n        return null;\n    }\n\n    if (config.type === 'stylesheet' && !canStartTyping(prefix, input, 'css')) {\n        // Additional check for stylesheet abbreviation start: it’s slightly\n        // differs from markup prefix, but we need activation context\n        // to ensure that context under caret is CSS\n        return null;\n    }\n\n    const syntax = config.syntax || 'html';\n    let from = pos;\n    let to = pos + input.length;\n    let offset = 0;\n\n    if (isJSX(syntax) && prefix === JSX_PREFIX) {\n        offset = JSX_PREFIX.length;\n        from -= offset;\n    }\n\n    return createTracker(state, { from, to }, { config });\n}\n\n/**\n * Detects and returns valid abbreviation activation context for given location\n * in editor which can be used for abbreviation expanding.\n * For example, in given HTML code:\n * `<div title=\"Sample\" style=\"\">Hello world</div>`\n * it’s not allowed to expand abbreviations inside `<div ...>` or `</div>`,\n * yet it’s allowed inside `style` attribute and between tags.\n *\n * This method ensures that given `pos` is inside location allowed for expanding\n * abbreviations and returns context data about it.\n */\nexport function getActivationContext(state: EditorState, pos: number): UserConfig | undefined {\n    if (cssLanguage.isActiveAt(state, pos)) {\n        return getCSSActivationContext(state, pos, 'css', getCSSContext(state, pos));\n    }\n\n    const syntax = docSyntax(state);\n\n    if (isHTML(syntax)) {\n        const ctx = getHTMLContext(state, pos);\n\n        if (ctx.css) {\n            return getCSSActivationContext(state, pos, 'css', ctx.css);\n        }\n\n        if (!ctx.current) {\n            return {\n                syntax,\n                type: 'markup',\n                context: getMarkupAbbreviationContext(state, ctx),\n                options: getOutputOptions(state)\n            };\n        }\n    } else {\n        return {\n            syntax,\n            type: getSyntaxType(syntax),\n            options: getOutputOptions(state)\n        };\n    }\n\n    return undefined;\n}\n\nfunction getCSSActivationContext(state: EditorState, pos: number, syntax: string, ctx: CSSContext): UserConfig | undefined {\n    const allowedContext = !ctx.current\n        || ctx.current.type === 'propertyName'\n        || ctx.current.type === 'propertyValue'\n        || isTypingBeforeSelector(state, pos, ctx);\n\n    if (allowedContext) {\n        return {\n            syntax,\n            type: 'stylesheet',\n            context: getStylesheetAbbreviationContext(ctx),\n            options: getOutputOptions(state, ctx.inline)\n        };\n    }\n\n    return;\n}\n\n/**\n * Handle edge case: start typing abbreviation before selector. In this case,\n * entered character becomes part of selector\n * Activate only if it’s a nested section and it’s a first character of selector\n */\nfunction isTypingBeforeSelector(state: EditorState, pos: number, { current }: CSSContext): boolean {\n    if (current?.type === 'selector' && current.range.from === pos - 1) {\n        // Typing abbreviation before selector is tricky one:\n        // ensure it’s on its own line\n        const line = state.doc.lineAt(current.range.from);\n        return line.text.trim().length === 1;\n    }\n\n    return false;\n}\n\nfunction isValidPrefix(prefix: string, syntax: string): boolean {\n    if (isJSX(syntax)) {\n        return prefix === JSX_PREFIX;\n    }\n\n    if (isCSS(syntax)) {\n        return prefix === '' || /^[\\s>;\"\\']$/.test(prefix);\n    }\n\n    return prefix === '' || /^[\\s>;\"\\']$/.test(prefix);\n}\n\nfunction isValidAbbreviationStart(input: string, syntax: string): boolean {\n    if (isJSX(syntax)) {\n        return /^[a-zA-Z.#\\[\\(]$/.test(input);\n    }\n\n    if (isCSS(syntax)) {\n        return /^[a-zA-Z!@#]$/.test(input);\n    }\n\n    return /^[a-zA-Z.#!@\\[\\(]$/.test(input);\n}\n\n/**\n * Creates abbreviation tracker for given range in editor. Parses contents\n * of abbreviation in range and returns either valid abbreviation tracker,\n * error tracker or `null` if abbreviation cannot be created from given range\n */\nfunction createTracker(state: EditorState, range: RangeObject, params: StartTrackingParams): AbbreviationTracker | null {\n    if (range.from > range.to) {\n        // Invalid range\n        return null;\n    }\n\n    let abbreviation = substr(state, range);\n    const { config, forced } = params;\n    if (params.offset) {\n        abbreviation = abbreviation.slice(params.offset);\n    }\n\n    // Basic validation: do not allow empty abbreviations\n    // or newlines in abbreviations\n    if ((!abbreviation && !forced) || hasInvalidChars(abbreviation)) {\n        return null;\n    }\n\n    const base: AbbreviationTrackerBase = {\n        abbreviation,\n        range,\n        config,\n        forced: !!forced,\n        inactive: false,\n        offset: params.offset || 0,\n    }\n\n    try {\n        let parsedAbbr: MarkupAbbreviation | StylesheetAbbreviation | undefined;\n        let simple = false;\n\n        if (config.type === 'markup') {\n            parsedAbbr = markupAbbreviation(abbreviation, {\n                jsx: config.syntax === 'jsx'\n            });\n            simple = isSimpleMarkupAbbreviation(parsedAbbr);\n        }\n\n        const previewConfig = createPreviewConfig(config);\n        const preview = expand(state, parsedAbbr || abbreviation, previewConfig);\n        if (!preview) {\n            // Handle edge case: abbreviation didn’t return any result for preview.\n            // Most likely it means a CSS context where given abbreviation is not applicable\n            return null;\n        }\n\n        return {\n            ...base,\n            type: 'abbreviation',\n            simple,\n            preview,\n        };\n    } catch (error) {\n        return base.forced ? {\n            ...base,\n            type: 'error',\n            error: error as AbbreviationError,\n        } : null;\n    }\n}\n\nfunction hasInvalidChars(abbreviation: string): boolean {\n    return /[\\r\\n]/.test(abbreviation);\n}\n\n/**\n * Check if given parsed markup abbreviation is simple.A simple abbreviation\n * may not be displayed to user as preview to reduce distraction\n */\nfunction isSimpleMarkupAbbreviation(abbr: MarkupAbbreviation): boolean {\n    if (abbr.children.length === 1 && !abbr.children[0].children.length) {\n        // Single element: might be a HTML element or text snippet\n        const first = abbr.children[0];\n        // XXX silly check for common snippets like `!`. Should read contents\n        // of expanded abbreviation instead\n        return !first.name || /^[a-z]/i.test(first.name);\n    }\n    return !abbr.children.length;\n}\n\nfunction createPreviewConfig(config: UserConfig) {\n    return {\n        ...config,\n        options: {\n            ...config.options,\n            'output.field': previewField,\n            'output.indent': '  ',\n            'output.baseIndent': ''\n        }\n    };\n}\n\nfunction previewField(_: number, placeholder: string) {\n    return placeholder;\n}\n\nfunction handleUpdate(state: EditorState, tracker: AbbreviationTracker | null, update: Transaction): AbbreviationTracker | null {\n    if (hasSnippet(state)) {\n        return null;\n    }\n\n    if (!tracker || tracker.inactive) {\n        // Start abbreviation tracking\n        update.changes.iterChanges((_fromA, _toA, fromB, _toB, text) => {\n            if (text.length) {\n                tracker = typingAbbreviation(state, fromB, text.toString()) || tracker;\n            }\n        });\n\n        if (!tracker || !tracker.inactive) {\n            return tracker;\n        }\n    }\n\n    // Continue abbreviation tracking\n    update.changes.iterChanges((fromA, toA, fromB, toB, text) => {\n        if (!tracker) {\n            return;\n        }\n\n        const { range } = tracker;\n        if (!contains(range, fromA)) {\n            // Update is outside of abbreviation, reset it only if it’s not inactive\n            if (!tracker.inactive) {\n                tracker = null;\n            }\n        } else if (contains(range, fromB)) {\n            const removed = toA - fromA;\n            const inserted = toB - fromA;\n            const to = range.to + inserted - removed;\n            if (to <= range.from || hasInvalidChars(text.toString())) {\n                tracker = null;\n            } else {\n                const abbrRange = tracker.inactive ? range : { from: range.from, to };\n                const nextTracker = createTracker(state, abbrRange, {\n                    config: tracker.config,\n                    forced: tracker.forced\n                });\n\n                if (!nextTracker) {\n                    // Next tracker is empty mostly due to invalid abbreviation.\n                    // To allow users to fix error, keep previous tracker\n                    // instance as inactive\n                    tracker = { ...tracker, inactive: true };\n                } else {\n                    tracker = nextTracker;\n                }\n            }\n        }\n    });\n\n    return tracker;\n}\n\nfunction getSyntaxFromPos(state: EditorState, pos: number): string {\n    if (cssLanguage.isActiveAt(state, pos)) {\n        return 'css';\n    }\n\n    if (htmlLanguage.isActiveAt(state, pos)) {\n        return 'html';\n    }\n\n    return '';\n}\n\nfunction canStartTyping(prefix: string, input: string, syntax: string) {\n    return isValidPrefix(prefix, syntax) && isValidAbbreviationStart(input, syntax);\n}\n\n/**\n * It’s a VERY hacky way to detect if snippet is currently active in given state.\n * Should ask package authors how to properly detect it\n */\nfunction hasSnippet(state: any): boolean {\n    if (Array.isArray(state.values)) {\n        return state.values.some((item: any) => item && item.constructor?.name === 'ActiveSnippet');\n    }\n\n    return false;\n}\n\nexport function canDisplayPreview(state: EditorState, tracker: AbbreviationTracker): boolean {\n    if (completionStatus(state) === 'active') {\n        return false;\n    }\n\n    const config = getEmmetConfig(state);\n    if (!config.previewEnabled) {\n        return false;\n    }\n\n    if (Array.isArray(config.previewEnabled)) {\n        const { type, syntax } = tracker.config;\n        if (!config.previewEnabled.includes(type!) && !config.previewEnabled.includes(syntax!)) {\n            return false;\n        }\n    }\n\n    return tracker.type === 'error' || (!tracker.simple || tracker.forced) && !!tracker.abbreviation && contains(tracker.range, getCaret(state));\n}\n\nfunction completionOptionsFromTracker(state: EditorState, tracker: AbbreviationTrackerValid, prev?: EmmetCompletion): EmmetCompletion[] {\n    const opt = state.facet(config);\n    return [{\n        label: 'Emmet abbreviation',\n        type: 'emmet',\n        boost: opt.completionBoost,\n        tracker,\n        previewConfig: opt.preview,\n        preview: prev?.preview,\n        info: completionInfo,\n        apply: (view, completion) => {\n            view.dispatch({\n                annotations: pickedCompletion.of(completion)\n            });\n            expandTracker(view, tracker);\n        }\n    }];\n}\n\nfunction completionInfo(completion: Completion): Node {\n    let { tracker, previewConfig, preview } = completion as EmmetCompletion;\n    if (preview?.update) {\n        preview.update(tracker.preview);\n    } else {\n        (completion as EmmetCompletion).preview = preview = createPreview(tracker.preview, tracker.config.syntax || 'html', previewConfig);\n    }\n\n    return preview;\n}\n","import type { StateCommand } from '@codemirror/state';\nimport { expand, extract, getOptions } from '../lib/emmet';\nimport { getSyntaxType } from '../lib/syntax';\nimport { snippet } from '@codemirror/autocomplete';\nimport { getActivationContext } from '../tracker';\n\nexport const expandAbbreviation: StateCommand = ({ state, dispatch }) => {\n    const sel = state.selection.main;\n    const line = state.doc.lineAt(sel.anchor);\n    const options = getOptions(state, sel.anchor);\n    const abbr = extract(line.text, sel.anchor - line.from, getSyntaxType(options.syntax));\n\n    if (abbr) {\n        const start = line.from + abbr.start;\n        const expanded = expand(state, abbr.abbreviation, getActivationContext(state, start) || options);\n        const fn = snippet(expanded);\n        fn({ state, dispatch }, { label: 'expand' }, start, line.from + abbr.end);\n        return true;\n    }\n\n    return false;\n};\n\n","import { syntaxTree } from '@codemirror/language';\nimport { EditorSelection } from '@codemirror/state';\nimport type { EditorState, SelectionRange, StateCommand } from '@codemirror/state';\nimport { cssLanguage } from '@codemirror/lang-css';\nimport { htmlLanguage } from '@codemirror/lang-html';\nimport type { SyntaxNode } from '@lezer/common';\nimport type { RangeObject } from '../lib/types';\nimport { contains, fullCSSDeclarationRange, last, narrowToNonSpace, rangeContains, rangesEqual } from '../lib/utils';\nimport { getPropertyRanges } from '../lib/context';\n\n// TODO use RangeObject instead of TextRange\n\nexport const balanceOutward: StateCommand = ({ state, dispatch }) => {\n    const nextSel: SelectionRange[] = [];\n    let hasMatch = false;\n\n    for (const sel of state.selection.ranges) {\n        const ranges = getOutwardRanges(state, sel.from);\n        if (ranges) {\n            hasMatch = true;\n            const targetRange = ranges.find(r => rangeContains(r, sel) && !rangesEqual(r, sel)) || sel;\n            nextSel.push(EditorSelection.range(targetRange.from, targetRange.to));\n        } else {\n            nextSel.push(sel);\n        }\n    }\n\n    if (hasMatch) {\n        const tr = state.update({\n            selection: EditorSelection.create(nextSel)\n        });\n\n        dispatch(tr);\n        return true;\n    }\n\n    return false;\n};\n\nexport const balanceInward: StateCommand = ({ state, dispatch }) => {\n    const nextSel: SelectionRange[] = [];\n    let hasMatch = false;\n    for (const sel of state.selection.ranges) {\n        const ranges = getInwardRanges(state, sel.from);\n        if (ranges) {\n            hasMatch = true;\n            // Try to find range which equals to selection: we should pick leftmost\n            let ix = ranges.findIndex(r => rangesEqual(sel, r));\n            let targetRange: RangeObject = sel;\n\n            if (ix < ranges.length - 1) {\n                targetRange = ranges[ix + 1];\n            } else if (ix !== -1) {\n                // No match found, pick closest region\n                targetRange = ranges.slice(ix).find(r => rangeContains(r, sel)) || sel;\n            }\n\n            nextSel.push(EditorSelection.range(targetRange.from, targetRange.to));\n        } else {\n            nextSel.push(sel);\n        }\n    }\n\n    if (hasMatch) {\n        const tr = state.update({\n            selection: EditorSelection.create(nextSel)\n        });\n\n        dispatch(tr);\n        return true;\n    }\n\n    return false;\n};\n\nfunction getOutwardRanges(state: EditorState, pos: number): RangeObject[] | undefined {\n    if (cssLanguage.isActiveAt(state, pos)) {\n        return getCSSOutwardRanges(state, pos);\n    }\n\n    if (htmlLanguage.isActiveAt(state, pos)) {\n        return getHTMLOutwardRanges(state, pos);\n    }\n\n    return;\n}\n\nfunction getInwardRanges(state: EditorState, pos: number): RangeObject[] | undefined {\n    if (cssLanguage.isActiveAt(state, pos)) {\n        return getCSSInwardRanges(state, pos);\n    }\n\n    if (htmlLanguage.isActiveAt(state, pos)) {\n        return getHTMLInwardRanges(state, pos);\n    }\n\n    return;\n}\n\nfunction getHTMLOutwardRanges(state: EditorState, pos: number): RangeObject[] {\n    const result: RangeObject[] = [];\n    const tree = syntaxTree(state).resolveInner(pos, -1);\n\n    for (let node: SyntaxNode | null = tree; node; node = node.parent) {\n        if (node.name === 'Element') {\n            pushHTMLRanges(node, result);\n        }\n    }\n\n    return compactRanges(result, false);\n}\n\nfunction getHTMLInwardRanges(state: EditorState, pos: number): RangeObject[] {\n    const result: RangeObject[] = [];\n    let node: SyntaxNode | null = syntaxTree(state).resolveInner(pos, 1);\n\n    // Find closest element\n    while (node && node.name !== 'Element') {\n        node = node.parent;\n    }\n\n    // Find all first child elements\n    while (node) {\n        pushHTMLRanges(node, result);\n        node = node.getChild('Element');\n    }\n\n    return compactRanges(result, true);\n}\n\nfunction getCSSOutwardRanges(state: EditorState, pos: number): RangeObject[]  {\n    const result: RangeObject[] = [];\n    let node: SyntaxNode | null = syntaxTree(state).resolveInner(pos, -1);\n\n    while (node) {\n        pushCSSRanges(state, node, pos, result);\n        node = node.parent;\n    }\n\n    return compactRanges(result, false);\n}\n\nfunction getCSSInwardRanges(state: EditorState, pos: number): RangeObject[] {\n    const result: RangeObject[] = [];\n    const knownNodes = ['Block', 'RuleSet', 'Declaration'];\n    let node: SyntaxNode | null = syntaxTree(state).resolveInner(pos, 1);\n\n    while (node && !knownNodes.includes(node.name)) {\n        node = node.parent;\n    }\n\n    while (node) {\n        pushCSSRanges(state, node, pos, result);\n        node = getChildOfType(node, knownNodes);\n    }\n\n    return result;\n}\n\n\nfunction pushHTMLRanges(node: SyntaxNode, ranges: RangeObject[]): void {\n    const selfClose = node.getChild('SelfClosingTag');\n    if (selfClose) {\n        ranges.push(selfClose);\n    } else {\n        const open = node.getChild('OpenTag');\n        if (open) {\n            const close = node.getChild('CloseTag');\n            if (close) {\n                // Inner range\n                ranges.push({ from: open.to, to: close.from });\n                // Outer range\n                ranges.push({ from: open.from, to: close.to });\n            } else {\n                ranges.push(open);\n            }\n        }\n    }\n}\n\nfunction pushCSSRanges(state: EditorState, node: SyntaxNode, pos: number, ranges: RangeObject[]): void {\n    if (node.name === 'Block') {\n        ranges.push(narrowToNonSpace(state, {\n            from: node.from + 1,\n            to: node.to - 1\n        }));\n    } else if (node.name === 'RuleSet') {\n        ranges.push(node);\n    } else if (node.name === 'Declaration') {\n        const { name, value } = getPropertyRanges(node);\n        if (value && contains(value, pos)) {\n            ranges.push(value);\n        }\n        if (name && contains(name, pos)) {\n            ranges.push(name);\n        }\n\n        ranges.push(fullCSSDeclarationRange(node));\n    }\n}\n\nfunction compactRanges(ranges: RangeObject[], inward: boolean): RangeObject[] {\n    const result: RangeObject[] = [];\n    ranges = [...ranges].sort(inward\n            ? ((a, b) => a.from - b.from || b.to - a.to)\n            : ((a, b) => b.from - a.from || a.to - b.to));\n\n    for (const range of ranges) {\n        const prev = last(result);\n        if (!prev || prev.from !== range.from || prev.to !== range.to) {\n            result.push(range)\n        }\n    }\n\n    return result;\n}\n\nfunction getChildOfType(node: SyntaxNode, types: string[]): SyntaxNode | null {\n    const cur = node.cursor();\n    if (cur.firstChild()) {\n        for (;;) {\n            for (const t of types) {\n                if (cur.node.name === t) {\n                    return cur.node;\n                }\n            }\n            if (!cur.nextSibling()) {\n                break;\n            }\n        }\n    }\n\n    return null;\n}\n","import { syntaxTree } from '@codemirror/language';\nimport type { LRLanguage } from '@codemirror/language';\nimport { htmlLanguage } from '@codemirror/lang-html';\nimport { cssLanguage } from '@codemirror/lang-css';\nimport type { ChangeSpec, EditorState, StateCommand } from '@codemirror/state';\nimport type { SyntaxNode } from '@lezer/common';\nimport { narrowToNonSpace } from '../lib/utils';\n\ntype CommentTokens = [string, string];\n\nconst htmlComment: CommentTokens = ['<!--', '-->'];\nconst cssComment: CommentTokens = ['/*', '*/'];\n\nexport const toggleComment: StateCommand = ({ state, dispatch }) => {\n    let changes: ChangeSpec[] = [];\n\n    for (const sel of state.selection.ranges) {\n        if (cssLanguage.isActiveAt(state, sel.from)) {\n            changes = changes.concat(toggleCSSComment(state, sel.from));\n        } else if (htmlLanguage.isActiveAt(state, sel.from)) {\n            changes = changes.concat(toggleHTMLComment(state, sel.from));\n        }\n    }\n\n    if (!changes.length) {\n        return false;\n    }\n\n    const tr = state.update({ changes });\n    dispatch(tr);\n\n    return true;\n};\n\nfunction toggleHTMLComment(state: EditorState, pos: number): ChangeSpec[] {\n    let result: ChangeSpec[] = [];\n    const ctx = getContextOfType(state, pos, ['Element', 'Comment']);\n    if (ctx) {\n        if (ctx.name === 'Comment') {\n            result = result.concat(stripComment(state, ctx, htmlComment))\n        } else {\n            result = result.concat(addComment(state, ctx, htmlComment, htmlLanguage));\n        }\n    }\n\n    return result;\n}\n\nfunction toggleCSSComment(state: EditorState, pos: number): ChangeSpec[] {\n    let result: ChangeSpec[] = [];\n    const ctx = getContextOfType(state, pos, ['RuleSet', 'Declaration', 'Comment']);\n    if (ctx) {\n        if (ctx.name === 'Comment') {\n            result = result.concat(stripComment(state, ctx, cssComment));\n        } else {\n            result = result.concat(addComment(state, ctx, cssComment, cssLanguage));\n        }\n    }\n\n    return result;\n}\n\nfunction getContextOfType(state: EditorState, pos: number, types: string[]): SyntaxNode | undefined {\n    const names = new Set(types);\n    let node: SyntaxNode | null = syntaxTree(state).resolve(pos, 1);\n    while (node) {\n        if (names.has(node.name)) {\n            return node;\n        }\n        node = node.parent;\n    }\n\n    return;\n}\n\nfunction stripComment(state: EditorState, node: SyntaxNode, comment: CommentTokens): ChangeSpec[] {\n    const innerRange = narrowToNonSpace(state, {\n        from: node.from + comment[0].length,\n        to: node.to - comment[1].length\n    });\n    return [\n        { from: node.from, to: innerRange.from },\n        { from: innerRange.to, to: node.to },\n    ];\n}\n\nfunction addComment(state: EditorState, node: SyntaxNode, comment: CommentTokens, lang: LRLanguage): ChangeSpec[] {\n    // Add comment tokens around element\n    let { to } = node;\n    if (node.name === 'Declaration' && node.nextSibling?.name === ';') {\n        // edge case for CSS property\n        to = node.nextSibling.to;\n    }\n\n    let result: ChangeSpec[] = [\n        { from: node.from, insert: comment[0] + ' ' },\n        { from: to, insert: ' ' + comment[1] },\n    ];\n\n    // Remove nested comments\n    result = result.concat(stripChildComments(state, node, comment, lang));\n\n    if (node.name === 'RuleSet') {\n        // Edge case for CSS rule set: find nested block first\n        const block = node.getChild('Block');\n        if (block) {\n            result = result.concat(stripChildComments(state, block, comment, lang));\n        }\n    }\n\n    return result;\n}\n\nfunction stripChildComments(state: EditorState, node: SyntaxNode, comment: CommentTokens, lang: LRLanguage): ChangeSpec[] {\n    let result: ChangeSpec[] = [];\n    for (const child of node.getChildren('Comment')) {\n        if (lang.isActiveAt(state, child.from)) {\n            result = result.concat(stripComment(state, child, comment));\n        }\n    }\n\n    return result;\n}\n","const defaultQuotedOptions = {\n    escape: 92,\n    throws: false\n};\n/**\n * Check if given code is a number\n */\nfunction isNumber(code) {\n    return code > 47 && code < 58;\n}\n/**\n * Check if given character code is alpha code (letter through A to Z)\n */\nfunction isAlpha(code, from, to) {\n    from = from || 65; // A\n    to = to || 90; // Z\n    code &= ~32; // quick hack to convert any char code to uppercase char code\n    return code >= from && code <= to;\n}\n/**\n * Check if given character code is alpha-numeric (letter through A to Z or number)\n */\nfunction isAlphaNumeric(code) {\n    return isNumber(code) || isAlpha(code);\n}\nfunction isAlphaNumericWord(code) {\n    return isNumber(code) || isAlphaWord(code);\n}\nfunction isAlphaWord(code) {\n    return code === 95 /* _ */ || isAlpha(code);\n}\n/**\n * Check if given character code is a white-space character: a space character\n * or line breaks\n */\nfunction isWhiteSpace(code) {\n    return code === 32 /* space */\n        || code === 9 /* tab */\n        || code === 160; /* non-breaking space */\n}\n/**\n * Check if given character code is a space character\n */\nfunction isSpace(code) {\n    return isWhiteSpace(code)\n        || code === 10 /* LF */\n        || code === 13; /* CR */\n}\n/**\n * Consumes 'single' or \"double\"-quoted string from given string, if possible\n * @return `true` if quoted string was consumed. The contents of quoted string\n * will be available as `stream.current()`\n */\nfunction eatQuoted(stream, options) {\n    options = Object.assign(Object.assign({}, defaultQuotedOptions), options);\n    const start = stream.pos;\n    const quote = stream.peek();\n    if (stream.eat(isQuote)) {\n        while (!stream.eof()) {\n            switch (stream.next()) {\n                case quote:\n                    stream.start = start;\n                    return true;\n                case options.escape:\n                    stream.next();\n                    break;\n            }\n        }\n        // If we’re here then stream wasn’t properly consumed.\n        // Revert stream and decide what to do\n        stream.pos = start;\n        if (options.throws) {\n            throw stream.error('Unable to consume quoted string');\n        }\n    }\n    return false;\n}\n/**\n * Check if given character code is a quote character\n */\nfunction isQuote(code) {\n    return code === 39 /* ' */ || code === 34 /* \" */;\n}\n/**\n * Eats paired characters substring, for example `(foo)` or `[bar]`\n * @param open Character code of pair opening\n * @param close Character code of pair closing\n * @return Returns `true` if character pair was successfully consumed, it’s\n * content will be available as `stream.current()`\n */\nfunction eatPair(stream, open, close, options) {\n    options = Object.assign(Object.assign({}, defaultQuotedOptions), options);\n    const start = stream.pos;\n    if (stream.eat(open)) {\n        let stack = 1;\n        let ch;\n        while (!stream.eof()) {\n            if (eatQuoted(stream, options)) {\n                continue;\n            }\n            ch = stream.next();\n            if (ch === open) {\n                stack++;\n            }\n            else if (ch === close) {\n                stack--;\n                if (!stack) {\n                    stream.start = start;\n                    return true;\n                }\n            }\n            else if (ch === options.escape) {\n                stream.next();\n            }\n        }\n        // If we’re here then paired character can’t be consumed\n        stream.pos = start;\n        if (options.throws) {\n            throw stream.error(`Unable to find matching pair for ${String.fromCharCode(open)}`);\n        }\n    }\n    return false;\n}\n\n/**\n * A streaming, character code-based string reader\n */\nclass Scanner {\n    constructor(str, start, end) {\n        if (end == null && typeof str === 'string') {\n            end = str.length;\n        }\n        this.string = str;\n        this.pos = this.start = start || 0;\n        this.end = end || 0;\n    }\n    /**\n     * Returns true only if the stream is at the end of the file.\n     */\n    eof() {\n        return this.pos >= this.end;\n    }\n    /**\n     * Creates a new stream instance which is limited to given `start` and `end`\n     * range. E.g. its `eof()` method will look at `end` property, not actual\n     * stream end\n     */\n    limit(start, end) {\n        return new Scanner(this.string, start, end);\n    }\n    /**\n     * Returns the next character code in the stream without advancing it.\n     * Will return NaN at the end of the file.\n     */\n    peek() {\n        return this.string.charCodeAt(this.pos);\n    }\n    /**\n     * Returns the next character in the stream and advances it.\n     * Also returns <code>undefined</code> when no more characters are available.\n     */\n    next() {\n        if (this.pos < this.string.length) {\n            return this.string.charCodeAt(this.pos++);\n        }\n    }\n    /**\n     * `match` can be a character code or a function that takes a character code\n     * and returns a boolean. If the next character in the stream 'matches'\n     * the given argument, it is consumed and returned.\n     * Otherwise, `false` is returned.\n     */\n    eat(match) {\n        const ch = this.peek();\n        const ok = typeof match === 'function' ? match(ch) : ch === match;\n        if (ok) {\n            this.next();\n        }\n        return ok;\n    }\n    /**\n     * Repeatedly calls <code>eat</code> with the given argument, until it\n     * fails. Returns <code>true</code> if any characters were eaten.\n     */\n    eatWhile(match) {\n        const start = this.pos;\n        while (!this.eof() && this.eat(match)) { /* */ }\n        return this.pos !== start;\n    }\n    /**\n     * Backs up the stream n characters. Backing it up further than the\n     * start of the current token will cause things to break, so be careful.\n     */\n    backUp(n) {\n        this.pos -= (n || 1);\n    }\n    /**\n     * Get the string between the start of the current token and the\n     * current stream position.\n     */\n    current() {\n        return this.substring(this.start, this.pos);\n    }\n    /**\n     * Returns substring for given range\n     */\n    substring(start, end) {\n        return this.string.slice(start, end);\n    }\n    /**\n     * Creates error object with current stream state\n     */\n    error(message, pos = this.pos) {\n        return new ScannerError(`${message} at ${pos + 1}`, pos, this.string);\n    }\n}\nclass ScannerError extends Error {\n    constructor(message, pos, str) {\n        super(message);\n        this.pos = pos;\n        this.string = str;\n    }\n}\n\nexport default Scanner;\nexport { ScannerError, eatPair, eatQuoted, isAlpha, isAlphaNumeric, isAlphaNumericWord, isAlphaWord, isNumber, isQuote, isSpace, isWhiteSpace };\n//# sourceMappingURL=scanner.es.js.map\n","import Scanner, { isWhiteSpace, isNumber, isSpace } from '@emmetio/scanner';\n\nconst nullary = token(\"null\" /* Null */, 0);\n/**\n * Parses given expression in forward direction\n */\nfunction parse(expr) {\n    const scanner = typeof expr === 'string' ? new Scanner(expr) : expr;\n    let ch;\n    let priority = 0;\n    let expected = (1 /* Primary */ | 4 /* LParen */ | 16 /* Sign */);\n    const tokens = [];\n    while (!scanner.eof()) {\n        scanner.eatWhile(isWhiteSpace);\n        scanner.start = scanner.pos;\n        if (consumeNumber(scanner)) {\n            if ((expected & 1 /* Primary */) === 0) {\n                error('Unexpected number', scanner);\n            }\n            tokens.push(number(scanner.current()));\n            expected = (2 /* Operator */ | 8 /* RParen */);\n        }\n        else if (isOperator(scanner.peek())) {\n            ch = scanner.next();\n            if (isSign(ch) && (expected & 16 /* Sign */)) {\n                if (isNegativeSign(ch)) {\n                    tokens.push(op1(ch, priority));\n                }\n                expected = (1 /* Primary */ | 4 /* LParen */ | 16 /* Sign */);\n            }\n            else {\n                if ((expected & 2 /* Operator */) === 0) {\n                    error('Unexpected operator', scanner);\n                }\n                tokens.push(op2(ch, priority));\n                expected = (1 /* Primary */ | 4 /* LParen */ | 16 /* Sign */);\n            }\n        }\n        else if (scanner.eat(40 /* LeftParenthesis */)) {\n            if ((expected & 4 /* LParen */) === 0) {\n                error('Unexpected \"(\"', scanner);\n            }\n            priority += 10;\n            expected = (1 /* Primary */ | 4 /* LParen */ | 16 /* Sign */ | 32 /* NullaryCall */);\n        }\n        else if (scanner.eat(41 /* RightParenthesis */)) {\n            priority -= 10;\n            if (expected & 32 /* NullaryCall */) {\n                tokens.push(nullary);\n            }\n            else if ((expected & 8 /* RParen */) === 0) {\n                error('Unexpected \")\"', scanner);\n            }\n            expected = (2 /* Operator */ | 8 /* RParen */ | 4 /* LParen */);\n        }\n        else {\n            error('Unknown character', scanner);\n        }\n    }\n    if (priority < 0 || priority >= 10) {\n        error('Unmatched \"()\"', scanner);\n    }\n    const result = orderTokens(tokens);\n    if (result === null) {\n        error('Parity', scanner);\n    }\n    return result;\n}\n/**\n * Consumes number from given stream\n * @return Returns `true` if number was consumed\n */\nfunction consumeNumber(scanner) {\n    const start = scanner.pos;\n    if (scanner.eat(46 /* Dot */) && scanner.eatWhile(isNumber)) {\n        // short decimal notation: .025\n        return true;\n    }\n    if (scanner.eatWhile(isNumber) && (!scanner.eat(46 /* Dot */) || scanner.eatWhile(isNumber))) {\n        // either integer or decimal: 10, 10.25\n        return true;\n    }\n    scanner.pos = start;\n    return false;\n}\n/**\n * Orders parsed tokens (operands and operators) in given array so that they are\n * laid off in order of execution\n */\nfunction orderTokens(tokens) {\n    const operators = [];\n    const operands = [];\n    let nOperators = 0;\n    for (let i = 0; i < tokens.length; i++) {\n        const t = tokens[i];\n        if (t.type === \"num\" /* Number */) {\n            operands.push(t);\n        }\n        else {\n            nOperators += t.type === \"op1\" /* Op1 */ ? 1 : 2;\n            while (operators.length) {\n                if (t.priority <= operators[operators.length - 1].priority) {\n                    operands.push(operators.pop());\n                }\n                else {\n                    break;\n                }\n            }\n            operators.push(t);\n        }\n    }\n    return nOperators + 1 === operands.length + operators.length\n        ? operands.concat(operators.reverse())\n        : null /* parity */;\n}\n/**\n * Number token factory\n */\nfunction number(value, priority) {\n    return token(\"num\" /* Number */, parseFloat(value), priority);\n}\n/**\n * Unary operator factory\n * @param value    Operator  character code\n * @param priority Operator execution priority\n */\nfunction op1(value, priority = 0) {\n    if (value === 45 /* Minus */) {\n        priority += 2;\n    }\n    return token(\"op1\" /* Op1 */, value, priority);\n}\n/**\n * Binary operator factory\n * @param value Operator  character code\n * @param priority Operator execution priority\n */\nfunction op2(value, priority = 0) {\n    if (value === 42 /* Multiply */) {\n        priority += 1;\n    }\n    else if (value === 47 /* Divide */ || value === 92 /* IntDivide */) {\n        priority += 2;\n    }\n    return token(\"op2\" /* Op2 */, value, priority);\n}\nfunction error(name, scanner) {\n    if (scanner) {\n        name += ` at column ${scanner.pos} of expression`;\n    }\n    throw new Error(name);\n}\nfunction isSign(ch) {\n    return isPositiveSign(ch) || isNegativeSign(ch);\n}\nfunction isPositiveSign(ch) {\n    return ch === 43 /* Plus */;\n}\nfunction isNegativeSign(ch) {\n    return ch === 45 /* Minus */;\n}\nfunction isOperator(ch) {\n    return ch === 43 /* Plus */ || ch === 45 /* Minus */ || ch === 42 /* Multiply */\n        || ch === 47 /* Divide */ || ch === 92 /* IntDivide */;\n}\nfunction token(type, value, priority = 0) {\n    return { type, value, priority };\n}\n\nconst defaultOptions = {\n    lookAhead: true,\n    whitespace: true\n};\nfunction extract(text, pos = text.length, options) {\n    const opt = Object.assign(Object.assign({}, defaultOptions), options);\n    const scanner = { text, pos };\n    let ch;\n    if (opt.lookAhead && cur(scanner) === 41 /* RightParenthesis */) {\n        // Basically, we should consume right parenthesis only with optional whitespace\n        scanner.pos++;\n        const len = text.length;\n        while (scanner.pos < len) {\n            ch = cur(scanner);\n            if (ch !== 41 /* RightParenthesis */ && !(opt.whitespace && isSpace(ch))) {\n                break;\n            }\n            scanner.pos++;\n        }\n    }\n    const end = scanner.pos;\n    let braces = 0;\n    while (scanner.pos >= 0) {\n        if (number$1(scanner)) {\n            continue;\n        }\n        ch = prev(scanner);\n        if (ch === 41 /* RightParenthesis */) {\n            braces++;\n        }\n        else if (ch === 40 /* LeftParenthesis */) {\n            if (!braces) {\n                break;\n            }\n            braces--;\n        }\n        else if (!((opt.whitespace && isSpace(ch)) || isSign(ch) || isOperator(ch))) {\n            break;\n        }\n        scanner.pos--;\n    }\n    if (scanner.pos !== end && !braces) {\n        // Trim whitespace\n        while (isSpace(cur(scanner))) {\n            scanner.pos++;\n        }\n        return [scanner.pos, end];\n    }\n    return null;\n}\n/**\n * Backward-consumes number from given scanner, if possible\n */\nfunction number$1(scanner) {\n    if (isNumber(prev(scanner))) {\n        scanner.pos--;\n        let dot = false;\n        let ch;\n        while (scanner.pos >= 0) {\n            ch = prev(scanner);\n            if (ch === 46 /* . */) {\n                if (dot) {\n                    // Decimal delimiter already consumed, abort\n                    break;\n                }\n                dot = true;\n            }\n            else if (!isNumber(ch)) {\n                break;\n            }\n            scanner.pos--;\n        }\n        return true;\n    }\n    return false;\n}\nfunction prev(scanner) {\n    return scanner.text.charCodeAt(scanner.pos - 1);\n}\nfunction cur(scanner) {\n    return scanner.text.charCodeAt(scanner.pos);\n}\n\nconst ops1 = {\n    [45 /* Minus */]: num => -num\n};\nconst ops2 = {\n    [43 /* Plus */]: (a, b) => a + b,\n    [45 /* Minus */]: (a, b) => a - b,\n    [42 /* Multiply */]: (a, b) => a * b,\n    [47 /* Divide */]: (a, b) => a / b,\n    [92 /* IntDivide */]: (a, b) => Math.floor(a / b)\n};\n/**\n * Evaluates given math expression\n * @param expr Expression to evaluate\n */\nfunction evaluate(expr) {\n    if (!Array.isArray(expr)) {\n        expr = parse(expr);\n    }\n    if (!expr || !expr.length) {\n        return null;\n    }\n    const nStack = [];\n    let n1;\n    let n2;\n    let f;\n    for (let i = 0, il = expr.length; i < il; i++) {\n        const token = expr[i];\n        if (token.type === \"num\" /* Number */) {\n            nStack.push(token.value);\n        }\n        else if (token.type === \"op2\" /* Op2 */) {\n            n2 = nStack.pop();\n            n1 = nStack.pop();\n            f = ops2[token.value];\n            nStack.push(f(n1, n2));\n        }\n        else if (token.type === \"op1\" /* Op1 */) {\n            n1 = nStack.pop();\n            f = ops1[token.value];\n            nStack.push(f(n1));\n        }\n        else {\n            throw new Error('Invalid expression');\n        }\n    }\n    if (nStack.length > 1) {\n        throw new Error('Invalid Expression (parity)');\n    }\n    return nStack[0];\n}\n\nexport default evaluate;\nexport { extract, parse };\n//# sourceMappingURL=math.es.js.map\n","import { EditorSelection } from '@codemirror/state';\nimport type { ChangeSpec, SelectionRange, StateCommand } from '@codemirror/state';\nimport evaluate, { extract } from '@emmetio/math-expression';\n\nexport const evaluateMath: StateCommand = ({ state, dispatch }) => {\n    const changes: ChangeSpec[] = [];\n    const nextSel: SelectionRange[] = [];\n\n    for (const sel of state.selection.ranges) {\n        let { from, to } = sel;\n        if (from === to) {\n            const line = state.doc.lineAt(sel.from);\n            const expr = extract(line.text, sel.from - line.from);\n            if (expr) {\n                from = expr[0] + line.from;\n                to = expr[1] + line.from;\n            }\n        }\n\n        if (from !== to) {\n            try {\n                const result = evaluate(state.doc.sliceString(from ,to));\n                if (result !== null) {\n                    const insert = result.toFixed(4).replace(/\\.?0+$/, '');\n                    changes.push({ from, to, insert });\n                    nextSel.push(EditorSelection.range(from + insert.length, from + insert.length));\n                }\n            } catch (err) {\n                nextSel.push(sel);\n                console.error(err);\n            }\n        }\n    }\n\n    if (changes.length) {\n        const tr = state.update({\n            changes,\n            selection: EditorSelection.create(nextSel)\n        });\n        dispatch(tr);\n        return true;\n    }\n\n    return false;\n}\n","import { EditorSelection } from '@codemirror/state';\nimport type { EditorState, SelectionRange, StateCommand } from '@codemirror/state';\nimport { isQuote, isSpace } from '../lib/utils';\n\nexport const goToNextEditPoint: StateCommand = ({ state, dispatch }) => {\n    const tr = state.update({\n        selection: getNextSel(state, 1)\n    });\n    dispatch(tr);\n    return true;\n};\n\nexport const goToPreviousEditPoint: StateCommand = ({ state, dispatch }) => {\n    const tr = state.update({\n        selection: getNextSel(state, -1)\n    });\n    dispatch(tr);\n    return true;\n};\n\nfunction getNextSel(state: EditorState, inc: number): EditorSelection {\n    const nextSel: SelectionRange[] = [];\n    for (const sel of state.selection.ranges) {\n        const nextPos = findNewEditPoint(state, sel.from + inc, inc);\n        if (nextPos != null) {\n            nextSel.push(EditorSelection.cursor(nextPos));\n        } else {\n            nextSel.push(sel);\n        }\n    }\n\n    return EditorSelection.create(nextSel);\n}\n\nfunction findNewEditPoint(state: EditorState, pos: number, inc: number): number | undefined {\n    const doc = state.doc.toString();\n    const docSize = doc.length;\n    let curPos = pos;\n\n    while (curPos < docSize && curPos >= 0) {\n        curPos += inc;\n        const cur = doc[curPos];\n        const next = doc[curPos + 1];\n        const prev = doc[curPos - 1];\n\n        if (isQuote(cur) && next === cur && prev === '=') {\n            // Empty attribute value\n            return curPos + 1;\n        }\n\n        if (cur === '<' && prev === '>') {\n            // Between tags\n            return curPos;\n        }\n\n        if (isNewLine(cur)) {\n            const line = state.doc.lineAt(curPos + inc);\n            if (!line.length || isSpace(line.text)) {\n                // Empty line\n                return line.from + line.text.length;\n            }\n        }\n    }\n\n    return;\n}\n\nfunction isNewLine(ch: string) {\n    return ch === '\\r' || ch === '\\n';\n}\n","import { EditorSelection } from '@codemirror/state';\nimport type { SelectionRange, StateCommand } from '@codemirror/state';\nimport { htmlLanguage } from '@codemirror/lang-html';\nimport { getTagContext } from '../lib/emmet';\n\nexport const goToTagPair: StateCommand = ({ state, dispatch }) => {\n    const nextRanges: SelectionRange[] = [];\n    let found = false;\n    for (const sel of state.selection.ranges) {\n        const pos = sel.from;\n        let nextSel = sel;\n        if (htmlLanguage.isActiveAt(state, pos)) {\n            const ctx = getTagContext(state, pos);\n            if (ctx && ctx.open && ctx.close) {\n                found = true;\n                const { open, close } = ctx;\n                const nextPos = open.from <= pos && pos < open.to\n                    ? close.from\n                    : open.from;\n                nextSel = EditorSelection.cursor(nextPos);\n            }\n        }\n\n        nextRanges.push(nextSel);\n    }\n\n    if (found) {\n        const tr = state.update({\n            selection: EditorSelection.create(nextRanges)\n        });\n        dispatch(tr);\n        return true;\n    }\n\n    return false;\n};\n","import { EditorSelection } from '@codemirror/state';\nimport type { StateCommand, TransactionSpec } from '@codemirror/state';\nimport type { StateCommandTarget } from '../lib/types';\n\nexport const incrementNumber1: StateCommand = target => incDecNumber(target, 1);\nexport const decrementNumber1: StateCommand = target => incDecNumber(target, -1);\nexport const incrementNumber01: StateCommand = target => incDecNumber(target, .1);\nexport const decrementNumber01: StateCommand = target => incDecNumber(target, -.1);\nexport const incrementNumber10: StateCommand = target => incDecNumber(target, 10);\nexport const decrementNumber10: StateCommand = target => incDecNumber(target, -10);\n\nfunction incDecNumber({ state, dispatch }: StateCommandTarget, delta: number): boolean {\n    const specs: TransactionSpec[] = [];\n\n    for (const sel of state.selection.ranges) {\n        let { from, to } = sel;\n        if (from === to) {\n            // No selection, extract number\n            const line = state.doc.lineAt(from);\n            const numRange = extractNumber(line.text, from - line.from);\n            if (numRange) {\n                from = line.from + numRange[0];\n                to = line.from + numRange[1];\n            }\n        }\n\n        if (from !== to) {\n            // Try to update value in given region\n            let value = updateNumber(state.doc.sliceString(from, to), delta);\n            specs.push({\n                changes: { from, to, insert: value },\n                selection: EditorSelection.range(from, from + value.length)\n            });\n        } else {\n            specs.push({ selection: sel });\n        }\n    }\n\n    if (specs.some(s => s.changes)) {\n        const tr = state.update(...specs);\n        dispatch(tr);\n        return true;\n    }\n\n    return false;\n}\n\n/**\n * Extracts number from text at given location\n */\nfunction extractNumber(text: string, pos: number): [number, number] | undefined {\n    let hasDot = false;\n    let end = pos;\n    let start = pos;\n    let ch: number;\n    const len = text.length;\n\n    // Read ahead for possible numbers\n    while (end < len) {\n        ch = text.charCodeAt(end);\n        if (isDot(ch)) {\n            if (hasDot) {\n                break;\n            }\n            hasDot = true;\n        } else if (!isNumber(ch)) {\n            break;\n        }\n        end++;\n    }\n\n    // Read backward for possible numerics\n    while (start >= 0) {\n        ch = text.charCodeAt(start - 1);\n        if (isDot(ch)) {\n            if (hasDot) {\n                break;\n            }\n            hasDot = true;\n        } else if (!isNumber(ch)) {\n            break;\n        }\n        start--;\n    }\n\n    // Negative number?\n    if (start > 0 && text[start - 1] === '-') {\n        start--;\n    }\n\n    if (start !== end) {\n        return [start, end];\n    }\n\n    return;\n}\n\nfunction updateNumber(num: string, delta: number, precision = 3): string {\n    const value = parseFloat(num) + delta;\n\n    if (isNaN(value)) {\n        return num;\n    }\n\n    const neg = value < 0;\n    let result = Math.abs(value).toFixed(precision);\n\n    // Trim trailing zeroes and optionally decimal number\n    result = result.replace(/\\.?0+$/, '');\n\n    // Trim leading zero if input value doesn't have it\n    if ((num[0] === '.' || num.startsWith('-.')) && result[0] === '0') {\n        result = result.slice(1);\n    }\n\n    return (neg ? '-' : '') + result;\n}\n\nfunction isDot(ch: number) {\n    return ch === 46;\n}\n\n/**\n * Check if given code is a number\n */\nexport function isNumber(code: number): boolean {\n    return code > 47 && code < 58;\n}\n","import type { ChangeSpec, EditorState, StateCommand, TransactionSpec } from '@codemirror/state';\nimport { getTagContext } from '../lib/emmet';\nimport type { ContextTag } from '../lib/types';\nimport { lineIndent } from '../lib/output';\nimport { narrowToNonSpace, rangeEmpty, isSpace } from '../lib/utils';\n\nexport const removeTag: StateCommand = ({ state, dispatch }) => {\n    const specs: TransactionSpec[] = [];\n    for (const sel of state.selection.ranges) {\n        const tag = getTagContext(state, sel.from);\n        if (tag) {\n            specs.push(removeTagSpec(state, tag));\n        } else {\n            specs.push({ selection: sel });\n        }\n    }\n\n    if (specs.some(t => t.changes)) {\n        const tr = state.update(...specs);\n        dispatch(tr);\n        return true;\n    }\n\n    return false;\n};\n\nfunction removeTagSpec(state: EditorState, { open, close }: ContextTag): TransactionSpec {\n    const changes: ChangeSpec[] = [];\n    if (close) {\n        // Remove open and close tag and dedent inner content\n        const innerRange = narrowToNonSpace(state, { from: open.to, to: close.from });\n        if (!rangeEmpty(innerRange)) {\n            // Gracefully remove open and close tags and tweak indentation on tag contents\n            changes.push({ from: open.from, to: innerRange.from });\n\n            const lineStart = state.doc.lineAt(open.from);\n            const lineEnd = state.doc.lineAt(close.to);\n            if (lineStart.number !== lineEnd.number) {\n                // Skip two lines: first one for open tag, on second one\n                // indentation will be removed with open tag\n                let lineNum = lineStart.number + 2;\n                const baseIndent = getLineIndent(state, open.from);\n                const innerIndent = getLineIndent(state, innerRange.from);\n\n                while (lineNum <= lineEnd.number) {\n                    const line = state.doc.line(lineNum);\n                    if (isSpace(line.text.slice(0, innerIndent.length))) {\n                        changes.push({\n                            from: line.from,\n                            to: line.from + innerIndent.length,\n                            insert: baseIndent\n                        });\n                    }\n                    lineNum++;\n                }\n            }\n\n            changes.push({ from: innerRange.to, to: close.to });\n        } else {\n            changes.push({ from: open.from, to: close.to });\n        }\n    } else {\n        changes.push(open);\n    }\n\n    return { changes };\n}\n\n/**\n * Returns indentation for line found from given character location\n */\nfunction getLineIndent(state: EditorState, pos: number): string {\n    return lineIndent(state.doc.lineAt(pos));\n}\n","import { syntaxTree } from '@codemirror/language';\nimport type { EditorState, SelectionRange, StateCommand } from '@codemirror/state';\nimport { EditorSelection } from '@codemirror/state';\nimport { cssLanguage } from '@codemirror/lang-css';\nimport type { SyntaxNode, TreeCursor } from '@lezer/common';\nimport type { RangeObject, StateCommandTarget } from '../lib/types';\nimport { fullCSSDeclarationRange, isQuote, isSpace, rangeContains, substr } from '../lib/utils';\nimport { getPropertyRanges, getSelectorRange } from '../lib/context';\n\nexport const selectNextItem: StateCommand = target => selectItemCommand(target, false);\nexport const selectPreviousItem: StateCommand = target => selectItemCommand(target, true);\n\nconst htmlParents = new Set(['OpenTag', 'CloseTag', 'SelfClosingTag']);\nconst cssEnter = new Set(['Block', 'RuleSet', 'StyleSheet']);\nconst cssParents = new Set(['RuleSet', 'Block', 'StyleSheet', 'Declaration']);\n\nfunction selectItemCommand({ state, dispatch }: StateCommandTarget, reverse: boolean): boolean {\n    let handled = false;\n    const selections: SelectionRange[] = [];\n    for (const sel of state.selection.ranges) {\n        const range = cssLanguage.isActiveAt(state, sel.from)\n            ? getCSSRange(state, sel, reverse)\n            : getHTMLRange(state, sel, reverse);\n        if (range) {\n            handled = true;\n            selections.push(EditorSelection.range(range.from, range.to));\n        } else {\n            selections.push(sel);\n        }\n    }\n\n    if (handled) {\n        const tr = state.update({\n            selection: EditorSelection.create(selections)\n        });\n        dispatch(tr);\n        return true;\n    }\n\n    return false;\n}\n\nfunction getHTMLRange(state: EditorState, sel: SelectionRange, reverse?: boolean): RangeObject | undefined {\n    const node = getStartHTMLNode(state, sel);\n    const cursor = node.cursor();\n\n    do {\n        if (cursor.name === 'OpenTag' || cursor.name === 'SelfClosingTag') {\n            const ranges = getHTMLCandidates(state, cursor.node);\n            const range = findRange(sel, ranges, reverse);\n            if (range) {\n                return range;\n            }\n        }\n    } while (moveHTMLCursor(cursor, reverse));\n\n    return;\n}\n\nfunction getCSSRange(state: EditorState, sel: SelectionRange, reverse?: boolean) {\n    const node = getStartCSSNode(state, sel);\n    const cursor = node.cursor();\n\n    do {\n        const ranges = getCSSCandidates(state, cursor.node);\n        const range = findRange(sel, ranges, reverse);\n        if (range) {\n            return range;\n        }\n    } while (moveCSSCursor(cursor, reverse));\n\n    return;\n}\n\nfunction moveHTMLCursor(cursor: TreeCursor, reverse?: boolean): boolean {\n    const enter = cursor.name === 'Element';\n    return reverse ? cursor.prev(enter) : cursor.next(enter);\n}\n\nfunction moveCSSCursor(cursor: TreeCursor, reverse?: boolean): boolean {\n    const enter = cssEnter.has(cursor.name);\n    return reverse ? cursor.prev(enter) : cursor.next(enter);\n}\n\nfunction getStartHTMLNode(state: EditorState, sel: SelectionRange): SyntaxNode {\n    let node: SyntaxNode = syntaxTree(state).resolveInner(sel.to, 1);\n\n    // In case if we’re inside tag, find closest start node\n    let ctx: SyntaxNode | null = node;\n    while (ctx) {\n        if (htmlParents.has(ctx.name)) {\n            return ctx;\n        }\n        ctx = ctx.parent;\n    }\n\n    return node;\n}\n\nfunction getStartCSSNode(state: EditorState, sel: SelectionRange): SyntaxNode {\n    let node: SyntaxNode = syntaxTree(state).resolveInner(sel.to, 1);\n\n    // In case if we’re inside tag, find closest start node\n    let ctx: SyntaxNode | null = node.parent;\n    while (ctx) {\n        if (cssParents.has(ctx.name)) {\n            return ctx;\n        }\n        ctx = ctx.parent;\n    }\n\n    return node;\n}\n\n/**\n * Returns candidates for selection from given StartTag or SelfClosingTag\n */\nfunction getHTMLCandidates(state: EditorState, node: SyntaxNode): RangeObject[] {\n    let result: RangeObject[] = [];\n    let child = node.firstChild;\n    while (child) {\n        if (child.name === 'TagName') {\n            result.push(child);\n        } else if (child.name === 'Attribute') {\n            result.push(child);\n            const attrName = child.getChild('AttributeName');\n            const attrValue = attrValueRange(state, child);\n            if (attrName && attrValue) {\n                result.push(attrName, attrValue);\n                if (substr(state, attrName).toLowerCase() === 'class') {\n                    // For class names, split value into space-separated tokens\n                    result = result.concat(tokenList(substr(state, attrValue)));\n                }\n            }\n        }\n        child = child.nextSibling;\n    }\n\n    return result;\n}\n\n/**\n * Returns candidates for RuleSet node\n */\nfunction getCSSCandidates(state: EditorState, node: SyntaxNode): RangeObject[] {\n    let result: RangeObject[] = [];\n    if (node.name === 'RuleSet') {\n        const selector = getSelectorRange(node);\n        result.push(selector);\n        const block = node.getChild('Block');\n        if (block) {\n            for (const child of block.getChildren('Declaration')) {\n                result = result.concat(getCSSCandidates(state, child));\n            }\n        }\n    } else if (node.name === 'Declaration') {\n        result.push(fullCSSDeclarationRange(node));\n        const { name, value } = getPropertyRanges(node);\n        name && result.push(name);\n        value && result.push(value);\n    }\n\n    return result;\n}\n\nfunction attrValueRange(state: EditorState, attr: SyntaxNode): RangeObject | undefined {\n    const value = attr.getChild('AttributeValue');\n    if (value) {\n        let { from, to } = value;\n        const valueStr = substr(state, value);\n        if (isQuote(valueStr[0])) {\n            from++;\n            if (valueStr[0] === valueStr[valueStr.length - 1]) {\n                to--;\n            }\n        }\n\n        if (from !== to) {\n            return { from, to };\n        }\n    }\n\n    return;\n}\n\n/**\n * Returns ranges of tokens in given value. Tokens are space-separated words.\n */\nfunction tokenList(value: string, offset = 0): RangeObject[] {\n    const ranges: RangeObject[] = [];\n    const len = value.length;\n    let pos = 0;\n    let start = 0;\n    let end = len;\n\n    while (pos < len) {\n        end = pos;\n        const ch = value.charAt(pos++);\n        if (isSpace(ch)) {\n            if (start !== end) {\n                ranges.push({\n                    from: offset + start,\n                    to: offset + end\n                });\n            }\n\n            while (isSpace(value.charAt(pos))) {\n                pos++;\n            }\n\n            start = pos;\n        }\n    }\n\n    if (start !== pos) {\n        ranges.push({\n            from: offset + start,\n            to: offset + pos\n        });\n    }\n\n    return ranges;\n}\n\nfunction findRange(sel: SelectionRange, ranges: RangeObject[], reverse = false): RangeObject | undefined {\n    if (reverse) {\n        ranges = ranges.slice().reverse();\n    }\n\n    let needNext = false;\n    let candidate: RangeObject | undefined;\n\n    for (const r of ranges) {\n        if (needNext) {\n            return r;\n        }\n        if (r.from === sel.from && r.to === sel.to) {\n            // This range is currently selected, request next\n            needNext = true;\n        } else if (!candidate && (rangeContains(r, sel) || (reverse && r.from <= sel.from) || (!reverse && r.from >= sel.from))) {\n            candidate = r;\n        }\n    }\n\n    return !needNext ? candidate : undefined;\n}\n","import type { ChangeSpec, EditorState, StateCommand } from '@codemirror/state';\nimport { getTagContext } from '../lib/emmet';\nimport { isSpace } from '../lib/utils';\n\nexport const splitJoinTag: StateCommand = ({ state, dispatch }) => {\n    const changes: ChangeSpec[] = [];\n    for (const sel of state.selection.ranges) {\n        const tag = getTagContext(state, sel.from);\n        if (tag) {\n            const { open, close } = tag;\n            if (close) {\n                // Join tag: remove tag contents, if any, and add closing slash\n                let closing = isSpace(getChar(state, open.to - 2)) ? '/' : ' /';\n                changes.push({\n                    from: open.to - 1,\n                    to: close.to,\n                    insert: `${closing}>`\n                });\n            } else {\n                // Split tag: add closing part and remove closing slash\n                let insert = `</${tag.name}>`;\n                let from = open.to;\n                let to = open.to;\n\n                if (getChar(state, open.to - 2) === '/') {\n                    from -= 2;\n                    if (isSpace(getChar(state, from - 1))) {\n                        from--;\n                    }\n                    insert = '>' + insert;\n                }\n\n                changes.push({ from, to, insert });\n            }\n        }\n    }\n\n    if (changes.length) {\n        const tr = state.update({ changes });\n        dispatch(tr);\n        return true;\n    }\n\n    return false;\n};\n\nfunction getChar(state: EditorState, pos: number): string {\n    return state.doc.sliceString(pos, pos + 1);\n}\n","import type { UserConfig } from 'emmet';\nimport { EditorView, keymap, ViewPlugin } from '@codemirror/view';\nimport type { ViewUpdate } from '@codemirror/view';\nimport { EditorState, StateEffect, StateField } from '@codemirror/state';\nimport type { Extension, StateCommand, } from '@codemirror/state';\nimport { undo } from '@codemirror/commands';\nimport { expand, getOptions, getTagContext } from '../lib/emmet';\nimport { getSelectionsFromSnippet, narrowToNonSpace, rangeEmpty, substr } from '../lib/utils';\nimport type { RangeObject, ContextTag } from '../lib/types';\nimport { lineIndent } from '../lib/output';\n\ninterface WrapAbbreviation {\n    abbreviation: string;\n    range: RangeObject;\n    options: UserConfig;\n    context?: ContextTag;\n}\n\nconst updateAbbreviation = StateEffect.define<WrapAbbreviation | null>();\n\nconst wrapAbbreviationField = StateField.define<WrapAbbreviation | null>({\n    create: () => null,\n    update(value, tr) {\n        for (const effect of tr.effects) {\n            if (effect.is(updateAbbreviation)) {\n                value = effect.value;\n            }\n        }\n        return value;\n    }\n});\n\nconst wrapTheme = EditorView.baseTheme({\n    '.emmet-wrap-with-abbreviation': {\n        position: 'absolute',\n        top: 0,\n        zIndex: 2,\n        width: '100%'\n    },\n    '.emmet-wrap-with-abbreviation__content': {\n        background: '#fff',\n        margin: '0 auto',\n        padding: '5px',\n        boxSizing: 'border-box',\n        width: '100%',\n        maxWidth: '30em',\n        borderBottomLeftRadius: '5px',\n        borderBottomRightRadius: '5px',\n        boxShadow: '0 3px 10px rgba(0, 0, 0, 0.3)',\n    },\n    '.emmet-wrap-with-abbreviation__content input': {\n        width: '100%',\n        boxSizing: 'border-box'\n    }\n});\n\nconst enterWrapWithAbbreviation: StateCommand = ({ state, dispatch }) => {\n    const abbr = state.field(wrapAbbreviationField);\n    if (abbr === null) {\n        const sel = state.selection.main;\n        const context = getTagContext(state, sel.from);\n        const wrapRange = getWrapRange(state, sel, context);\n        const options = getOptions(state, wrapRange.from);\n        options.text = getContent(state, wrapRange);\n\n        const tr = state.update({\n            effects: [updateAbbreviation.of({\n                abbreviation: '',\n                range: wrapRange,\n                options,\n                context\n            })]\n        });\n        dispatch(tr);\n        return true;\n    }\n\n    return false;\n}\n\nconst wrapWithAbbreviationPlugin = ViewPlugin.fromClass(class WrapWithAbbreviationViewPlugin {\n    private widget: HTMLElement | null = null;\n    private input: HTMLInputElement | null = null;\n\n    update(update: ViewUpdate) {\n        const { state, view } = update;\n        const abbr = state.field(wrapAbbreviationField);\n        if (abbr) {\n            if (!this.widget) {\n                this.createInputPanel(view);\n            }\n            this.updateAbbreviation(abbr.abbreviation);\n        } else if (this.widget) {\n            this.disposeWidget();\n            view.focus();\n        }\n    }\n\n    // TODO use @codemirror/panel instead\n    private createInputPanel(view: EditorView) {\n        const widget = document.createElement('div');\n        widget.className = 'emmet-wrap-with-abbreviation';\n\n        const content = document.createElement('div');\n        content.className = 'emmet-wrap-with-abbreviation__content';\n\n        const input = document.createElement('input');\n        input.placeholder = 'Enter abbreviation';\n\n        let updated = false;\n\n        const undoUpdate = () => {\n            if (updated) {\n                undo(view);\n                updated = false;\n            }\n        };\n\n        input.addEventListener('input', () => {\n            const abbr = view.state.field(wrapAbbreviationField);\n            if (abbr) {\n                const nextAbbreviation = input.value;\n                undoUpdate();\n\n                const nextAbbr: WrapAbbreviation = {\n                    ...abbr,\n                    abbreviation: nextAbbreviation\n                };\n\n                if (nextAbbr.abbreviation) {\n                    updated = true;\n                    const { from, to } = nextAbbr.range;\n                    const expanded = expand(view.state, nextAbbr.abbreviation, nextAbbr.options);\n                    const { ranges, snippet } = getSelectionsFromSnippet(expanded, from);\n                    const nextSel = ranges[0];\n\n                    view.dispatch({\n                        effects: [updateAbbreviation.of(nextAbbr)],\n                        changes: [{\n                            from,\n                            to,\n                            insert: snippet\n                        }],\n                        selection: {\n                            head: nextSel.from,\n                            anchor: nextSel.to\n                        }\n                    });\n                } else {\n                    view.dispatch({\n                        effects: [updateAbbreviation.of(nextAbbr)],\n                    });\n                }\n            }\n        });\n\n        input.addEventListener('keydown', evt => {\n            if (evt.key === 'Escape' || evt.key === 'Enter') {\n                if (evt.key === 'Escape') {\n                    undoUpdate();\n                }\n                evt.preventDefault();\n                view.dispatch({\n                    effects: [updateAbbreviation.of(null)]\n                });\n            }\n        });\n\n        content.append(input)\n        widget.append(content);\n        view.dom.append(widget);\n        this.widget = widget;\n        this.input = input;\n        input.focus();\n    }\n\n    private updateAbbreviation(value: string) {\n        if (this.input && this.input.value !== value) {\n            this.input.value = value;\n        }\n    }\n\n    private disposeWidget() {\n        if (this.widget) {\n            this.widget.remove();\n            this.widget = this.input = null;\n        }\n    }\n});\n\nexport function wrapWithAbbreviation(key = 'Ctrl-w'): Extension[] {\n    return [\n        wrapAbbreviationField,\n        wrapWithAbbreviationPlugin,\n        wrapTheme,\n        keymap.of([{\n            key,\n            run: enterWrapWithAbbreviation\n        }])\n    ];\n}\n\nfunction getWrapRange(editor: EditorState, range: RangeObject, context?: ContextTag): RangeObject {\n    if (rangeEmpty(range) && context) {\n        // No selection means user wants to wrap current tag container\n        const { open, close } = context;\n        const pos = range.from;\n\n        // Check how given point relates to matched tag:\n        // if it's in either open or close tag, we should wrap tag itself,\n        // otherwise we should wrap its contents\n\n        if (inRange(open, pos) || (close && inRange(close, pos))) {\n            return {\n                from: open.from,\n                to: close ? close.to : open.to\n            };\n        }\n\n        if (close) {\n            return narrowToNonSpace(editor, { from: open.to, to: close.from });\n        }\n    }\n\n    return range;\n}\n\nfunction inRange(range: RangeObject, pt: number): boolean {\n    return range.from < pt && pt < range.to;\n}\n\n/**\n * Returns contents of given region, properly de-indented\n */\nfunction getContent(state: EditorState, range: RangeObject): string | string[] {\n    const baseIndent = lineIndent(state.doc.lineAt(range.from));\n    const srcLines = substr(state, range).split('\\n');\n    const destLines = srcLines.map(line => {\n        return line.startsWith(baseIndent)\n            ? line.slice(baseIndent.length)\n            : line;\n    });\n\n    return destLines;\n}\n"],"names":["isNumber","code","isAlpha","isWhiteSpace","isSpace","isQuote","Scanner","ScannerError","tokenScanner","peek","readable","consume","token","error","element","isSiblingOperator","isBracket","isOperator","createLiteral","literal","quote","isLiteral","tokenize","getToken","field","whiteSpace","literal$1","operator","bracket","isQuote$1","isOpenBracket","operatorType","consumePlaceholder","repeater","stringify","last","text","stringifyValue","isField","isValue","consumeNumber","color","property","isCloseBracket","parse","config","attrName","prev","next","snippet","parse$2","cur","parse$3","parse$1","outputValue","defaultOptions","defaultConfig","defaultOptions$1","opt","abbreviation","expandAbbreviation","tagName","extract","selfClose","css","html","tracker","context","state","markupAbbreviation","operators"],"mappings":"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"}